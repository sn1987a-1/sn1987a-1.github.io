{"meta":{"title":"SN1987A","subtitle":"LAYのBLOG","description":"Learn not and know not.","author":"SN1987A","url":"http://sn1987a-1.github.io","root":"/"},"pages":[{"title":"关于本站","date":"2020-04-19T04:58:56.000Z","updated":"2022-02-06T09:39:54.349Z","comments":false,"path":"about/index.html","permalink":"http://sn1987a-1.github.io/about/index.html","excerpt":"","text":"SN1987ALearn not and know not. USTC cser 2020. =^= 联系我QQ：945093063phone:18306552190main:lay_sn1987a@mail.ustc.edu.cn"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2022-01-27T13:30:38.046Z","comments":true,"path":"archives/index.html","permalink":"http://sn1987a-1.github.io/archives/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-06-07T14:17:49.000Z","updated":"2022-01-27T13:30:38.046Z","comments":true,"path":"link/index.html","permalink":"http://sn1987a-1.github.io/link/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-10-31T02:11:28.000Z","updated":"2022-02-06T09:31:49.319Z","comments":true,"path":"comments/index.html","permalink":"http://sn1987a-1.github.io/comments/index.html","excerpt":"","text":"new Artitalk({ appId: 'o2lydQokojD1IP8EGhex24WU-MdYXbMMI', appKey: '8ykSyPm9CwzCDdR5dbid1AWT' })"},{"title":"我的歌单","date":"2019-05-17T08:14:00.000Z","updated":"2022-01-27T13:30:38.046Z","comments":true,"path":"music/index.html","permalink":"http://sn1987a-1.github.io/music/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-24T07:14:39.000Z","updated":"2022-01-27T13:30:38.046Z","comments":false,"path":"tags/index.html","permalink":"http://sn1987a-1.github.io/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-01-27T13:30:37.996Z","updated":"2022-01-27T13:30:37.996Z","comments":false,"path":"List/gallery/index.html","permalink":"http://sn1987a-1.github.io/List/gallery/index.html","excerpt":"","text":"壁纸 收藏的一些壁纸 OH MY GIRL 关于OH MY GIRL的图片"},{"title":"","date":"2019-08-10T08:41:10.000Z","updated":"2022-01-27T13:30:37.996Z","comments":false,"path":"List/movies/index.html","permalink":"http://sn1987a-1.github.io/List/movies/index.html","excerpt":"","text":"励志视频"},{"title":"Music-BBOX","date":"2020-04-23T04:58:56.000Z","updated":"2022-02-06T09:31:49.319Z","comments":false,"path":"List/music/index.html","permalink":"http://sn1987a-1.github.io/List/music/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-11-24T07:12:19.000Z","updated":"2022-01-27T13:30:38.046Z","comments":false,"path":"categories/index.html","permalink":"http://sn1987a-1.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-11-24T08:05:01.000Z","updated":"2022-01-27T13:30:37.996Z","comments":false,"path":"List/gallery/ohmygirl/index.html","permalink":"http://sn1987a-1.github.io/List/gallery/ohmygirl/index.html","excerpt":"","text":""},{"title":"","date":"2022-01-27T13:30:37.996Z","updated":"2022-01-27T13:30:37.996Z","comments":false,"path":"List/gallery/wallpaper/index.html","permalink":"http://sn1987a-1.github.io/List/gallery/wallpaper/index.html","excerpt":"","text":""}],"posts":[{"title":"WSL2美化","slug":"WSL2美化","date":"2022-01-21T14:12:20.000Z","updated":"2022-02-06T03:59:16.429Z","comments":true,"path":"posts/15684.html","link":"","permalink":"http://sn1987a-1.github.io/posts/15684.html","excerpt":"","text":"WSL2美化本文简要记录基于Windows11对WSL的终端进行美化的主要步骤。 环境：Ubuntu 20.04，Windows Terminal(WT) 主要工具和插件：zsh，oh my zsh, povwerlevel10k(powerlevel9k也可以),autozsh-autosuggestions , zsh-syntax-highlig 下图是我的美化结果。 对Windows terminal的外观进行美化在微软应用商店搜索Windows terminal即可下载最新版本，如果不想用Windows Terminal，也可以下载另外一个跨平台终端——Tabby Terminal，点击下载)，配置方案也类似，但亲测效果不如WT。 修改默认配置打开Windows Terminal，点击上方栏中“v”按钮，选择侧边栏中的“setting.json”文件并打开，后文中对WT的配置均对该文件进行修改（可以用VScode打开）。 例如，若要规定默认打开的界面是WSL2/WSL的界面，即可在actions一栏进行修改： \"defaultProfile\": \"{07b52e3e-de2c-5db4-bd2d-ba144ed6c273}\",//括号内对应的序列可在setting.json文件里查找到Ubuntu对应的GUID 修改配色方案在setting.json最后部分有schemes一栏，代表WT的配色方案，每个配色方案的name项即为名称，系统默认提供了一部分配色方案以及名称，但都不是很好看，将自定义配色添加到schemes底下即可新增配色方案，自定义配色网站)提供了较多推荐的配色，可以直接复制。 以下为我选择的配色： { \"name\": \"ChallengerDeep\", \"black\": \"#141228\", \"red\": \"#ff5458\", \"green\": \"#62d196\", \"yellow\": \"#ffb378\", \"blue\": \"#65b2ff\", \"purple\": \"#906cff\", \"cyan\": \"#63f2f1\", \"white\": \"#a6b3cc\", \"brightBlack\": \"#565575\", \"brightRed\": \"#ff8080\", \"brightGreen\": \"#95ffa4\", \"brightYellow\": \"#ffe9aa\", \"brightBlue\": \"#91ddff\", \"brightPurple\": \"#c991e1\", \"brightCyan\": \"#aaffe4\", \"brightWhite\": \"#cbe3e7\", \"background\": \"#1e1c31\", \"foreground\": \"#cbe1e7\", \"selectionBackground\": \"#cbe1e7\", \"cursorColor\": \"#fbfcfc\" }, 添加完配色方案后，还应该对profiles部分进行修改，以便于使用最新配色方案。如果只需要对虚拟机部分添加如下文本，可以只修改name为“Ubuntu-xx.xx”的部分（当然其他部分也只是复制粘贴）。 \"colorScheme\": \"ChallengerDeep\", 修改字体Windows原装字体不支持很多符号的显示，这里推荐修改默认字体 比较简单的，可以在微软官方下载)Cascadia Code PL字体，或者是下载文件后右键单击该字体对应的.otf/.ttf文件并选择安装。 当然有功能更加强大，应用更加广泛的字体Nerd Fond(Hack Nerd Fond)，包含了更多字符库，点击下载]( https://github.com/ryanoasis/nerd-fonts ))。 安装完成后，同样在profiles目录的Ubuntu-xx.xx里修改： \"fontFace\": \"Hack Nerd Fond\" \"fontSize\": 10, 设置背景和透明效果均是在perfiles目录内 添加背景图： \"backgroundImage\": \"E:\\\\wallpaper\\\\wp3.jpg\",//背景的地址 添加透明效果（0~1，越小表示越透明） \"acrylicOpacity\": 0.8, \"useAcrylic\": true 指定启动时的默认路径： \"startingDirectory\": \"./\", 这样Windows Terminal基本就配置好了。 美化WSL2步骤： 将原有的shell替换为zsh 安装oh my zsh 关键字高亮以及自动填充插件 安装powerlevel10k 安装完自动填充以及高亮插件后对文件zshrc进行的主要添加为： source /usr/share/zsh-autosuggestions/zsh-autosuggestions.zsh source /usr/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh 这里主要从安装powerlevel10k开始记录。 在命令行输入： sudo vim ~/.zshrc 打开配置文件后，找到THEME一行，修改为： ZSH_THEME=\"powerlevel10k/powerlevel10k\" 之后重启或输入命令 p10k configure 之后填写弹出的问卷即可自定义并保存当前配置文件。如果需要使用其他路径的文件，可以使用source命令进行导入。","categories":[{"name":"WSL2","slug":"WSL2","permalink":"http://sn1987a-1.github.io/categories/WSL2/"}],"tags":[{"name":"美化","slug":"美化","permalink":"http://sn1987a-1.github.io/tags/%E7%BE%8E%E5%8C%96/"},{"name":"Unix","slug":"Unix","permalink":"http://sn1987a-1.github.io/tags/Unix/"}]},{"title":"2021数据结构复习","slug":"2021数据结构复习","date":"2022-01-11T12:12:20.000Z","updated":"2022-02-06T14:48:14.321Z","comments":true,"path":"posts/131000.html","link":"","permalink":"http://sn1987a-1.github.io/posts/131000.html","excerpt":"","text":"2021数据结构复习 考试范围数据结构 算法时间复杂度空间复杂度分析 线性表 顺序表示 链式表示 线性链表 循环链表 双向链表 一元多项式（实验内容） 栈 数值转换，括号匹配，行编辑程序，迷宫求解，表达式求值 队列 定义 链队列 循环队列 串 定长顺序存储 堆分配存储 串的块链存储 数组 顺序表示 特殊存储：特殊矩阵，稀疏矩阵 广义表 定义和存储结构 *广义表的递归算法 求广义表深度 复制广义表 建立广义表的存储结构 树和二叉树 二叉树 定义，性质，存储结构 遍历二叉树 线索二叉树 树和森林 树的存储结构 树和二叉树之间的转换 树和森林的遍历 Huffman树相关问题 图 定义和术语 存储结构 数组表示法 邻接表 十字链表 邻接多重表 图的遍历 DFS BFS 图的连通性问题 无向图连通分量和生成树 最小生成树 最短路径问题 从某一点到其他各个顶点的最短距离 每一对顶点之间的最短路径 查找 静态查找表 顺序表查找 有序表查找 索引顺序表查找 动态查找 二叉排序树和 *平衡二叉树 B-树和B+树 哈希表 构造方法 处理冲突 查找 define INFEASIBLE -1define OVERFLOW -2 线性表顺序表逻辑上相邻，物理上相邻，随机存取 #define LIST_SIZE 100 #define LISTINCREMENT 10 typedef struct { ElemType *elem; int length; int listsize; }SqList; 动态分配： void *malloc(); free(void *p); void *realloc(void *p,unsigned int size);//可变大/变小 基本操作略 链表表示逻辑上相邻不代表物理上相邻，非随机存取 （区别不同逻辑结构的插入删除操作） 单链表typedef struct LNode { elemtype data; struct LNode *next; }Lnode ,*LinkList; 基本操作： Status GetElem_L(LinkList L,int i,ElemType &amp;e); Status ListInsert_L(LinkList &amp;L,int i，ElemType e); //获取结点的前驱耗时间，T(N)=O(N) Status ListDelete_L(LinkList &amp;L,int i，ElemType &amp;e); Status CreateList_L(LinkList &amp;L); 创建：头插法（$T(N)=O(N)$），尾插法($T(N)=O(N^2)$)(头插法创建较好) 作业习题：就地逆置单链表 有头结点：L指向头结点，除头结点各点均有前驱； 无头结点：空表时L为NULL； 循环链表 便于从一个结点出发，访问全部的结点 在O(1)的时间内找到链表的第一个结点和最后一个结点（头指针==尾指针） 静态链表和动态链表静态链表(若语言不支持指针类型的存储的情况) #define MAXSIZE 1000 typedef struct{ ElemType data; int cur;//代替指针域 }component,SLinkList[MAXSIZE]; 数组的第0个分量可以视为（备用链的）头结点； 静态链表的模拟动态分配与释放（未利用的点i[cur]=0;) 动态链表与静态链表的运用：例：求差集 双向链表typedef struct DuLNode{ ElemType data; struct DuLNode *prior; struct DuLNode *next; }DuLNode ,*DuLinkList; 可带头结点，可不带（多半是带的）。 其他表示根据题目要求规定进行设计，如同时存储单链表的头和尾，特殊线性表——有序表。 例题1.双向循环链表的自身变换，如将$L={a_1,a_2,…..a_n}$变换为$L’={a_1,a_3,….a_n,…a_4,a_2}$ ​ (顺着后向链，前向链进行插入) 栈与队列难点：递归与非递归实现，循环队列 栈LIFO 只能在Top端进行插入删除操作 Traverse操作是从栈底到栈顶进行访问 多为顺序栈：约定：S.top指向栈顶元素的下一个位置 #define STACK_INT_SIZE 100 #define STACKINCREMENT 10 typedef struct { ElemType *base; ElemType *top; int stacksize;//当前分配容量 }SqStack； 栈空：S.base==S.top 栈满：S.top-S.base&gt;=S.stacksize 入栈：S.top++; 出栈: S.top - - ； 链栈：无栈满问题，可以不必引入头结点（在第一个结点处进行插入删除操作）。 栈的基本应用1.数制转换 2.行编辑程序（已不常用） ​ 用栈保存终端输入的一行字符进行逐行处理；遇到‘#’退一格（出栈），遇到‘@’退一行（清空栈ClearStack），其他字符入栈，最后遍历，清空栈。 3.表达式求值 表达式表示方法： 中缀表达式，记得加括号 前缀表达式（波兰式）-+abc d-ea 后缀表达式（逆波兰式）ab+cdea- - 表达式求值也可以用二叉树表示：分支保存运算符，叶子结点保存操作数，中序访问：中缀表达式；先序访问：前缀表达式；后序访问：后缀表达式 要先确保中缀表达式合法：括号匹配 默认运算式结尾为’#’ 可以进行的操作：中缀表达式转化为先/后缀表达式，先/后缀表达式求值，中缀表达式直接求值。注意：不涉及中缀表达式的运算不需考虑优先级。 [1]中缀表达式转后缀表达式：运算符入栈 [2]中缀表达式求值：运算符（包括左括号）和运算数两个栈，按照操作符优先级进行运算，'#'优先级最低。 [3]前缀表达式串求值：运算符和运算数入同一个栈，如果有两个运算数则进行运算 [4]前缀表达式与后缀表达式相互转化：思路相反，同样用栈，类似波兰式/逆波兰式求值，将字符串视作运算数。 [5]后缀表达式求值：运算数入栈 4.栈与递归的实现 应用：构建其他数据结构：表，图，树和二叉树 ​ 问题求解：Hanoi塔问题，迷宫问题/N皇后问题（回溯） 队列FIFO，允许在队尾rear插入，队头head删除（获取队头元素GetHead(L,&amp;e),遍历操作Traverse(L，visit())从head到rear）. 链队列（通常）typedef struct QNode{ ElemType data; struct QNode *next; }QNode,*QueuePtr; typedef struct { QueuePtr front; QueuePtr rear; }LinkQueue; （最好是引入头结点——队空：L.front ==L.rear） 循环队列(处理假溢出)#define MAXSIZE 100 typedef struct{ ElemType *base; int front; int rear;//指向队尾元素的下一个位置 }SqQueue； 队空标志：Q.front==Q.rear 多申请一个空间，队满标志：Q.front==(Q.rear+1)%MAXSIZE INCREMENT：重新分配空间，并遍历原队列进行复制 应用：离散事件模拟 串概念：串的长度，空串，子串，主串，子串/字符在串中的位置 是特殊的线性表：处理对象为个体（字符）或整体（子串） 操作： StrAssign(S,\"...\");//赋值 StrCpoy(T,S);//复制串 StrCompare(S,T);//比较 ConCat(T,\"...\");//拼接 SubString(Sub,S,i,j);//取子串Sub为Si,...Sj Index(s,\"a\",i);//返回S中i后第一层出现子串的首个字母的位置 Replace(S,\"..\",\"..\");//将子串全部替换为目标子串 StrInsert(S,i,\"...\");//在i处插入子串 StrDelete(S,i,j);//删除Si到Sj的子串 具体存储结构顺序映像存储密度低 定长顺序存储，下表为0的位置存储串的长度（basic)或串值最后加入无关字符，如’\\0’ (C)。 堆分配存储——顺序映像 typedef struct{ char *ch;//malloc() 动态分配 int length; }HString; ​ 块链存储——链式映像 typedef struct Chunk{ char ch[CHUNKSIZE]; struct Chunk *next; }Chunk; typedef struct{ Chunk *head,*tail; int curlen }LString; 块链存储中的插入，删除，寻找子串，定位，拼接算法复杂化处理（作业题目） 串的模式匹配算法好像不考。 应用举例应用于文本编辑，页插入/删除，行插入/删除，页表，行表，起始地址，长度… 建立关键词词索引表 数组和广义表数组的操作貌似也不考，补充三元表，特殊数组在后续算法课中。 广义表广义表是线性表的推广，元素类型可以是原子或子表，习惯上用大写字母表示子表，小写字母表示原子。（也可以看作特殊定义的图） 表处理语言LISP中，将广义表视作基本的数据结构。 表头：表中的第一个元素 GetHead(L) 表尾：除去第一个元素外的其余元素组成的表 GetTail(L) 基本定义 空表 A=( ) 长度：元素个数，如B=(a,(b,c,d))长度为2，第二个元素为表 A=(a,A) 可以递归定义的表 GetHead(((())))=(()); GetTail((()))=() 深度：括号的重数的最大值 广义表的存储结构数据元素不同，难以用顺序表存储。 头尾链表存储typedef enum{ATOM,LIST}ElemTag; typedef struct GLNode{ ElemTag tag; union{ AtomType atom; struct {GLNode *hp,*tp;}ptr; }; }*GList; 拓展线性链表存储typedef enum{ATOM,LIST}ElemTag; typedef struct GNode{ ElemTag tag; union{ AtomType atom; struct GLNode *hp; }; struct GLNode *tp; }*GLIst; 广义表的相关操作此部分不考代码设计，可能有读代码分析的题目 递归算法，归纳思维 广义表的深度规定：LS为原子：DEPTH=0； ​ LS为空表：DEPTH=1； ​ 归纳项：$DEPTH(LS)=1+Max{DEPTH(a_i)},\\ n&gt;=1$ 假设采用头尾链表存储： int GListDepth(GLIst L)//递归 { if(!L) return 1; if(L-&gt;tag==ATOM) return 0; for(max=0,pp=L;pp;pp=pp-&gt;ptr.tp) { dep=GListDepth(pp-&gt;ptr.hp); if(dep&gt;max) max=dep; } return max+1; } //可以用队列实现非递归算法，在每层开始处设置标志 复制广义表归纳：复制LS—&gt;复制表头+复制表尾 Status CpoyList(GList &amp;T,GList L) {//假定头尾链表存储 if(!L) { T=NULL; return OK;} T=(GList)malloc(sizeof(GLNode)); T-&gt;tag=L-&gt;tag; if(T-&gt;tag==ATOM) {T-&gt;atom=L-&gt;atom; return OK:} CopyList(T-&gt;ptr.hp,L-&gt;ptr.hp); CopyList(Y-&gt;ptr.tp,L-&gt;ptr.tp); return OK; } 可以用栈实现非递归算法。 广义表结构的建立由字符串建立广义表 表头+表尾递归处理 ... 其他应用作业题目：就地逆置广义表(逆转所有子表)递归处理 ``` 注：广义表的存储格式一般可以自选 常见思路：1.将广义表看作表头表尾两部分进行递归处理 ​ 2.将广义表看作n个并列子表组成的表 ## 树和二叉树 **二叉树的遍历，二叉树和森林的相互转换等相关算法设计** ### 定义 空树n=0; 表示方法： 树形表示，嵌套表示，广义表表示，凹入表示 术语：高度，层次（1，2，...，h），度，祖先，子孙，有序树，无序树，终端结点，非终端结点，内部结点... 操作： ```c++ TreeDepth(T); Parent(T,cur_e); LeftChild(T,cur_e); RightSibling(T,cur_e); InsertChild(&amp;T,p,i,c);//插入子树 DeleteChild(&amp;T,p,i); TraverseTree(T,visit()); 二叉树每个结点最多有两个子树，度数一定是2，分左右。 性质： 第i层最多有$2^{n-1}$个结点 深度为h的二叉树最多$2^{h}-1$个结点（上述两条可以推广到n叉树的情况） $n_0=n_2+1;\\ \\ \\ n=n_0+n_1+n_2;\\ \\ \\ n-1=n_1+n_2$ 若包含n个结点的树只有叶子结点和度数为k的结点，则树中包含的叶子结点为：$n_0=n-(n-1)/k$ 满二叉树：深度为h且含有$2^{h}-1$个结点的二叉树 完全二叉树：前k-1层为满二叉树，第k层结点全在靠左边 具有n个结点的完全二叉树的深度：$h=[log_2n]+1$ 若对一有n个结点的完全二叉树按层序编号，则对任意结点有： 若i=1，为根结点，无双亲；若i&gt;1，双亲结点为[i/2] 若2i&gt;n,则结点i无左孩子，否则左孩子为2i。 若2i+1&gt;n，则i无右孩子，否则右孩子是2i+1. 上述结论可以大致推广到k叉树 二叉树的存储结构： 顺序存储：空间开销大 链式存储：二叉链（保存双亲结点变成三叉链） typedef struct{ ElemType data; struct BiTNode *lchild,*rchild; }BiTNode,*BiTree; 二叉树的相关算法遍历先/中/后序遍历：每个结点均被访问三次 递归/非递归（栈）算法实现。 最好使用函数调用的结果而不是返回值：为实现函数出现异常时改变Status及时终止 相关运用： 创建二叉树：类比先序访问 清空释放二叉树，或以某个结点为祖先的子树：后序访问 先序/后序拓补序列可以唯一确定一个二叉树。 非递归后序遍历要注意：设置访问标志tag 求深度 层次遍历递归/非递归（队列）实现 ​ ——先访问的结点，子结点也会优先访问 对二叉树进行层次遍历可以判断该二叉树是否为完全二叉树。 找到距离x最近的叶子子孙及距离：从x开始进行层次遍历，找到第一个叶子结点即可（每层末尾加一个虚结点进行计算距离 输出距离x最近的所有叶子及其数目 输出x到最近叶子子孙结点的路径：修改原队列：不释放已经遍历的结点并记录每个结点的双亲信息 二叉树的创建 完全二叉树的顺序映射 先序拓扑序列 先序+中序或后序+中序也可唯一确定的一棵二叉树—-线索化二叉树 线索二叉树利用叶子结点的未使用的指针域，加两个标记 typedef enum{Link,Thread}PointerTag; typedef struct BiThrNode { ElemType data; struct BiThrNode *lchild,*rchild; PointerTag ltag,rtag; }BiThrNode,*BiThrTree; 先序/中序/后序线索化二叉树：对应遍历顺序的相应前驱，后继，其算法可以类比相应的遍历算法。 中序线索化中规中矩，基本是中序遍历的拓展，左孩子为前驱，右孩子为后继； 先序/后序线索化二叉树 相互对称，难点：找前驱和后继 后序找到前驱的方法： 若该结点无左孩子，前驱由lchild指向 若该结点有左右孩子，前驱为右孩子 若该结点只有左孩子，前驱为左孩子 后序找到结点的后继 若结点为根结点，后继为空 若结点为双亲的右孩子或没有右兄弟，后继为双亲 若为有右兄弟的左孩子，且右兄弟为叶子结点，后继为右兄弟 若为有右兄弟的左孩子，且右兄弟不是叶子结点，则后继为右兄弟后序遍历的第一个结点 后序找到结点的后继 若结点为根结点，前驱为空 若结点为双亲的左孩子或没有左兄弟，前驱为双亲 若为有左兄弟的右孩子，且左兄弟为叶子结点，前驱为左兄弟 若为有左兄弟的右孩子，且左兄弟不是叶子结点，则前驱为左兄弟先序遍历的最后一个结点 先序找到后继的方法 若该结点无右孩子，后继由右孩子指向 若该节有左右孩子，其后继为左孩子 若该结点有右孩子且无左孩子，其后继为右孩子 涉及求结点的双亲的问题———三叉链表 树的存储结构双亲表示法可以用于顺序存储 #define MAX_TREE_SIZE 100 typedef struct{ ElemType data; int parent; }PTNode; typedef struct{ PTNode nodes[MAX_TREE_SIZE]; int n;//结点数 }PTree; 孩子表示法#define MAX_TREE_SIZE 100 typedef struct{ int child; struct CTNode *next; }*ChildPtr; typedef struct{ ElemType data; ChildPtr firstchild; }CTBox; typedef struct { CTBox nodes[MAX_TREE_SIZE]; int n,r;//结点数和根的位置 }CTree; 孩子兄弟表示法typedef struct CSNode{ ElemType data; struct CSNode *firstchild,*nextsibling; }CSNode,*CSTree; 树的遍历先根遍历&lt;—-&gt;二叉树的先序遍历 后根遍历&lt;—-&gt;二叉树的中序遍历 应用：通常以孩子-兄弟链表示 统计树的高度 统计树中叶子结点的个数（叶子结点的标志：Firstchild为空） 求树的度 树和森林与二叉树之间的转换…没讲，不知道考不考 Huffman树相关概念：最优树，路径长度（带权），结点带权路径长度，$WPL=\\sum_{i=1}^nw_il_i$ Huffman编码（算法应该不考，考也无所谓） 开拓问题求解相关思路课本没讲？。？应该不考OvO 划分等价类，回溯法求解问题，树的计数/编号 图相关概念：有向图，无向图，带权/无权图路径和连通性，连通和强连通，子图，生成树，顶点/弧（相关概念复习图论再写） 一般算法中不考虑带权图的权值为负数的情况 基本操作 PS:操作包含对点vex，对边arc的操作 Status LocateVex(G,u); Status GetVex(G,v); Status FirstAdjVex(G,v); Status NextAdjVex(G,v,w); Status InsertVex(G,v); Status InsertArc(&amp;G,v,w); Status DeleteVex(&amp;G,v); Status DeleteArc(&amp;G,v,w); Status DFSTraverse(G,v,Visit()); Status BFSTraverse(G,v,Visit()); 图的存储结构用顺序表存储顶点集，不是顺序映像 最常用的还是邻接表 用以下方法存储关系集合 数组表示—邻接矩阵#define INFINITY INT_MAX typedef enum{DG,DN,AG,AN}GraphKind;//有向/无向，带权/无权 typedef struct ArcCell{ //带权图：adj代表权值，INFINITY代表不相邻 //无权图0代表不相邻，1代表相邻 int adj; InfoType *info;//指向相关信息的指针 }ArcCell,AdjMatrix[MAX_VERTEX_NUM][MAX_VEXTEX_NUM]; typedef struct { VextexType vexs[MAX_VEXTEX_NUM]; AdjMatrix arcs; int vexnum; int arcnum; GraphKind kind; }MGraph; 无向图的邻接矩阵：对阵矩阵 链表表示—邻接表/逆邻接表typedef struct ArcNode{ int adjvex; struct ArcNode *nextarc; InfoType *info; }ArcNode; typedef struct { VexType data; ArcNode *firstarc; }VNode,AdjList[MAX_VERTEX_NUM]; typedef struct{ AdjList vertices; int vexnum,arcnum; GraphKind kind; }ALGraph; 对于有向图，比较容易计算的是顶点的出度，而入度要对所有的边进行遍历才能求出（反之为逆邻接表）。 对于稀疏图（$v&gt;log_2a$），多采用邻接表，避免空间浪费，否则可以选用邻接矩阵。 十字链表—有向图弧结点数=弧数 方便求出顶点的入度和 出度 typedef struct ArcBox{ int tailvex,headvex; struct ArcBox *hlink,*tlink; InfoType *info; }ArcBox; typedef struct VexNode{ VextexType data; ArcBox *firstin,*firstout; }VexNode; typedef struct{ VexNode xlist[MAX_VERTEX_NUM]; int vexnum,arcnum; }OLGraph; 邻接多重表—无向图邻接表中：边结点数==2*边数 临界多重表：边结点数==边数 typedef enum{unvisited ,visited}VisitIf; //边结点 typedef struct EBox{ VisitIf mark; int ivex,jvex; struct Ebox *ilink,jlink; InfoType *info; }EBox; //顶点结点 typedef struct VexBox{ VexType data; EBox *firstedge; }VexBox; //临界多重表 typedef struct { VexBox adjmulist[MAX_VEXTEX_NUM]; int vexnum,edgenum; }AMLGraph; 图的遍历对顶点的遍历——引入标记数组visitd[0,…n-1]，防止顶点被多次访问。 访问结束可以得到图的生成树（连通图可以从一个顶点完成全部的遍历，非连通图要在外部加循环确保所有顶点均被访问，有向图注意强连通），后续连通性模块将讨论。 可以基于图的多种存储结构进行相似的遍历，算法可以基于ADT Graph（调用ADT的函数，如FirstAdjVex，NextAdjVex等）或某种存储结构写。 DFS深度优先遍历——树的先序遍历 生成从起点v出发的深度优先生成树，v可能存在多个子树 非递归实现：利用栈及时进行现场保护和现场维护 BFS广度优先遍历——树的层次遍历 判断两个顶点是否存在路径 得到某点到任意一个顶点之间的最短路径（无权） 求距离v的最短距离最长/最短的顶点 求距离v距离为k的所有顶点 遍历算法的应用 求一条包含图中所有顶点的简单路径 不一定存在，基于DFS寻找，是否能找到与具体顶点的选择有关 对DFS的修改：要回溯，添加计数器记录当前路径的结点数n，查找失败时恢复原来的状态，n-- 可以修改算法，选择输出一条路径或者全部路径（最好是一条？），统计最短路径的条数 求距离v的最短距离最长的顶点和最长的路径值 对BFS进行修改，在每层结尾入队一个特殊元素 最后一个出队列的一定是路径最长的顶点 图的连通性问题基本概念：连通分量的顶点集，生成树，DFS生成树，BFS生成树，生成森林 同样可以基于ADTGraph或具体的存储方式写出不同的算法 BFS/DFS生成树/生成森林 有向图的强连通分量 从某顶点出发，以该顶点为尾做DFS，按照其所有邻接点的搜索都完成的顺序（退出DFS的顺序）存储到数组 从存储到数组的顶点出发，沿着该顶点为头的弧进行逆向DFS，能访问到的顶点则在同一个强连通分量中 复杂度近似和DFS遍历的复杂度相同 最小生成树MST——无向连通网的最小代价生成树 “若（u，v)为具有最小权值的边，则必存在包含该边的最小生成树” Prim算法——最小生成树不断壮大的过程 适用于稠密图$T(N,e)=O(N^2)$ Kruskal算法——连通分量不断合并的过程 适用于稀疏图$T(N,e)=O(N*log (e))$ 关节点和重连通分量 关节点：删除v后一个连通分量变为两个/两个以上 若生成树的根至少有两棵或两棵以上的子树，则该结点必是关节点 若生成树的某非叶子结点v的某棵子树的结点均没有指向v的祖先的边，则v为关节点 叶子结点一定不是关节点 重连通图：不含关节点的图，保证了任意两个顶点至少存在两条路径 连通度：若连通图G至少删去K个顶点才能变成不连通，则该图的连通度为k 改造DFS可以得到图的关节点，判断是否为重连通图 引入数组low[v]:生成树中以v为根的子树中结点到v的祖先的边所关联的祖先的最小次序号 若对于v，v的孩子结点w有low[w]&gt;=visited[v]，则说明v为关节点 有向无环图（ DAG）的应用 检测有向图中是否有环： 从顶点v出发，若DFS结束前发现出现u到v的回边，则有环 DAG是描述一项活动或系统的进行过程的工具： ​ 顶点—子工程，边—子工程之间的约束 应用： 拓扑排序问题描述：偏序-&gt;全序 偏序：集合X上的元素是自反的，反对称的，传递的 一、AOV网：Activity on vextex network 进行拓扑排序的方法： 在有向图中选取一个没有前驱的顶点并输出 在图中删除该顶点和以该顶点为尾的弧 转1，除非已经输出全部顶点或不存在无前驱的顶点 有向无环图保证了该图存在拓扑排序，存在拓扑排序保证了有向图中没有环 对于一个有向无环图，进行DFS遍历，第一个退出循环的顶点即为出度为0的顶点，（可以）是拓扑排序的最后一个顶点 若有向图的邻接矩阵为三角矩阵，则该途中存在拓扑有序序列 二、AOE网：Activity on edge network 问题：完成整项工程的最短时间/关键路径/事件的最早发生时间 关键活动：最早发生时间（e(i)）==最晚发生时间（l(i)） 最早发生时间：拓扑有序 最晚发生时间：逆拓扑有序 关键路径：输出关键活动（可能不止一条） 最短路径无权图的最短路径：广度优先搜索 带权有向图的最短路径——dijkstra算法 按路径长度递增的顺序产生最短路径 求任意两个顶点的最短路径 对Dijkstra算法进行循环：$O(T,e)=O(n^3)$ 具体实现应该不会考，会考画图？ Floyd（Wallshall算法）：求vi，vj之间的最短路径，依次使得中间路径序号不大于k的最短路径，k依次递增。 查找Search Table操作：检索/查找（静态），插入/删除（动态） 关键字：主关键字唯一，次关键字不唯一 静态查找顺序查找通过顺序表/线性链表进行查找 0的位置设置“哨兵”：避免每一次查找都要判断是否查找完毕，减少比较次数 查找成功：ASL=$(n+1)/2$ 查找不成功：ASL=n+1 有序表的查找 折半查找 基本思想：用low/high做标记，查找区间折半缩小 性能分析：查找过程可以用二叉树判定树表示，判定树的形态与n直接相关（不是完全二叉树但胜似完全二叉树），查找层次即为二叉树的层次，也代表ASL 查找成功或不成功：$ASL&lt;=[log_2n]+ 1$ n&gt;=50时，可近似得到结果：$ASL_{bs}\\approx log_2(n+1)-1$ 斐波那契查找 根据斐波那契的特征对标进行分割:开始表中的记录个数比斐波那契数小1，则将定值与F(n-1)进行比较，类似折半查找 特点：分割时只需进性加减运算 平均性能比折半查找好，但最坏的情况比折半查找糟糕 插值查找 $i=\\frac{key-ST.elem[l].key}{ST.elem[h].key-ST.elem[l].key}(h-l+1)$ 只适用于关键字均匀分布的情况，这种情况下平均性能优于折半查找 静态树表查找 根据各个记录的查找概率求ASL PH值：判定树内带权路径长度$PH=\\sum_{i=1}^nw_ih_i$,其中$w_i=c*p_i$为权，$h_i$为层次 PH值最小：静态最优查找树——构造需要的时间开销过高 构造较好的次优查找树 …写到这里发现查找树表不考，再见 索引顺序表 起因：顺序查找表效率低而折半查找等要求查找表有序 思想：分块有序——索引有序（索引包含最大项和起始指针） 过程：先折半查找记录所在的块，再顺序查找元素 $ASL_{bs}=L_b(查找块)+L_w(查找元素)$ 动态查找二叉查找树BSTBinary Search Tree查找算法可以基于二叉树的先序遍历算法写出 中序遍历BST可以得到关键字的有序序列 BST的插入算法：查找失败的同时添加叶子结点 BST的删除算法： 若P为叶子结点，直接删除并修改双亲的指针域 若P只有左子树或右子树，将P删除并使P的双亲指针域指向P的孩子 若P有左右子树，将P与P的右子树的最左边的元素进行互换（中序遍历的首个元素），换言之，将P与P在树中中序访问序列的直接前驱或直接后继进行交换即可，避免树的长高 BST的建立：二叉树的形态与输入的次序直接相关，若原本有序将得到每层只有一个结点的糟糕情况 平均性能分析：$P(n)&lt;=2(1+1\\frac{1}{n})ln\\ n$ 平衡二叉树AVL树深度与log(N)同量级 引入平衡因子BF：-1，0，1 AVL树的旋转部分不会单独考察算法设计，理解过程即可 LL型旋转：在A结点的左孩子的左子树插入结点 RR型旋转：在A结点的右孩子的右子树插入结点 LR型旋转：在A结点的左孩子的右子树插入结点，先左转再右转 RL型旋转：在A结点的右孩子的左子树插入结点，先右转再左转 在对AVL树进行插入和删除操作时及时维护平衡 性能分析：$T(N)=O(log\\ N)$ B-树定义： 每个结点至多有m个子树 若根结点不是叶子结点，至少有两棵子树 除根结点外的非得终端结点至少$\\lceil m/2\\rceil$个子树 非终端结点包含以下信息：$(n,A0,K_1,A_1,K_2,…,K_n,A_n)$，其中n为关键字数目，$K_i$为关键字，$A_i$为指针，且$A{i-1}$指向的所有结点的关键字小于$Ki$,大于$K{i-1}$ 所有叶子结点都出现在同一层次上,且不携带信息，可以视作查找失败，指向这些结点的指针为空，图中表示为F 相关算法 查找：纵向查结点，横向查关键字 通常存储在磁盘中，是数据库的主要索引结构 查找效率的首要因素：层次 通常取m=3，此时又称为2-3树 含有N个关键字的m阶B-树的最大深度：$log_{\\lceil m/e\\rceil}(\\frac{N+1}{2})$ 较为特殊的插入删除操作： …应该不考察算法，要会画图 B+树B-树的变形树，具体区别： 有n棵子树的结点包含了n个关键字 所有叶子结点包含了关键字的信息，以及指向这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大排序 非终端结点为索引部分，结点仅含有最大或者最小关键字 B+树不是树；支持顺序查找（横向），随机查找（纵向） 键树好像不考键树 哈希表Hash函数：H(key) 便于一次存取确定所查记录 将一组关键字利用H(key)和处理冲突的函数映射到有限的连续地址——hash表（散列） Hash函数的构造方法： 直接定址法（x) 数字分析法/平方取中法 折叠发：移位叠加，间界叠加 除留余数法 随机数法 … 处理冲突的方法：s 开放定址法 线性探测再散列+1，+2，… 平方探测再散列+1,-1,+4,-4 伪随机探测再散列 链地址法：关键字为同义词的的各个元素存储在线性链表中 再哈希法：$H_i=RH_i(key),i=1,2,..k$不易产生聚集，但会增加计算的时间 建立公共溢出区域：发生冲突都填入溢出表 ​ 二次聚集：在处理同义词冲突的过程中又添加了非同义词的冲突的现象 Hash表的查找算法根据Hash函数以及冲突处理方法确定 查找的ASL：分成功与不成功计算，时间复杂度为未知 装填因子$\\alpha=$记录数/Hash表表长 通常Hash表长m和除留余数法的p的关系： p&lt;=m,且p为素数或最小不包含小于20的质因子的合数。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://sn1987a-1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"专业课","slug":"专业课","permalink":"http://sn1987a-1.github.io/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"},{"name":"数据结构","slug":"数据结构","permalink":"http://sn1987a-1.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"图论期末复习","slug":"图论","date":"2022-01-05T15:42:30.000Z","updated":"2022-02-06T09:31:49.319Z","comments":true,"path":"posts/12532.html","link":"","permalink":"http://sn1987a-1.github.io/posts/12532.html","excerpt":"","text":"图论复习未完成——不想写了 图的基本概念 阶：图G中顶点的个数$\\nu (G)=|V(G)|$（简记为$\\nu,V$） $\\epsilon (G)=|E(G)|$（简记为$\\epsilon ,E$） 无限图：$\\nu(G)+\\epsilon (G)=+\\infty$，否则成为有限图 关联/相邻/邻顶：$\\psi (e)={u,v}$ 重边/环 简单图：无环无重边 完全图 二分图 完全二分图 零图 星图 度数$deg(\\nu)=d_1(\\nu)+2\\times l(\\nu)$ 最大/最小度数$\\delta (G)=min{\\nu \\in V(G)},\\Delta (G)=max{\\nu\\in V(G)}$ 无向图$\\sum_{\\nu\\in V(G)}{deg(\\nu)=2\\epsilon(G)}$ 给定图G，G中度数为奇数的顶点个数为偶数 真子图，生成子图（V(H)=V(G)），顶点导出子图，边导出子图 补图，边图：边图的边对应原图的顶点，顶点对应原图的边 并，交 积：$G\\times H=(V’,E’)$,边集合分为三类： 两个顶点在的两个分量在原图中均相邻 有一个分量在原图中相邻，另外一个分量为同一个顶点 路径/行迹/轨道/回路/圈 连通/不连通：连通存在距离 图的同构：元素之间的二元关系完全相同 Ulam猜想：G与H全等 等价于 对任何$\\nu \\in V(G),G-\\nu=V-\\nu$ 有向图D：$D=(V(D),E(D),\\psi _D)$ $\\sum{\\nu\\in V(G)}{deg^-(\\nu)}(入度)=\\sum{\\nu\\in V(G)}{deg^+(\\nu)}(出度)=\\epsilon(G)$ 定理：G为二分图当且仅当G中无奇圈 最长轨道 反证例：若G为简单图，$\\delta (G)&gt;=2$，则G中必含圈 ​ 若G为简单图，$\\delta (G)&gt;=3$，则G中必含有偶圈 最短路径问题$\\omega (P_0(u,v))$——Dijkstra算法 ​ 证明略。 类似最短路径的相关思路——如取生成子图最大边数： 任给无向图G，存在H为G的生成子图，满足： H是二分图 任给$u\\in V(G)=V(H),有d_H(u)&gt;=d_G(u)/2$ 取H为边数最大的二分图，假设不满足条件2 树基本概念: 树叶/分支点（树枝） 森林/平凡树 以下命题等价 图的连通性平面图匹配理论Euler图和Hamilton图图的着色有向图网络流理论图矩阵和图空间","categories":[{"name":"图论","slug":"图论","permalink":"http://sn1987a-1.github.io/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"专业课","slug":"专业课","permalink":"http://sn1987a-1.github.io/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"},{"name":"图论","slug":"图论","permalink":"http://sn1987a-1.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"数据结构实验设计2_HUFFMAM Tree","slug":"11-11","date":"2021-11-11T11:46:11.000Z","updated":"2022-01-28T14:22:14.921Z","comments":true,"path":"posts/1120.html","link":"","permalink":"http://sn1987a-1.github.io/posts/1120.html","excerpt":"","text":"Huffman 编码解压缩关于Huffman编码的知识,在上个学期数据结构已经学过,作为较为复杂的一次实验耗费了不少时间,可说实话,上个学期在数据结构投入的经历确实不算大,最终的成绩也相当不理想,但这个学期还得重新学数据结构(信计数据结构不能互认就离谱orz),同样类型的实验,不同的心境 ,不同的要求,只求要一个好一点点的分数啦 大致实验要求基于Huffman编码来实现压缩器和编码器,使其可以对任意文件进行解压缩操作. 实现方法:命令行执行/GUI界面(还不会…)/运行程序交互界面 本实验的测试数据:文件包括:.txt .png .wav .mp4 .zip","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://sn1987a-1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"专业课","slug":"专业课","permalink":"http://sn1987a-1.github.io/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"},{"name":"数据结构","slug":"数据结构","permalink":"http://sn1987a-1.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"模拟与数字电路期中复习","slug":"模拟与数字电路复习","date":"2021-11-05T15:42:30.000Z","updated":"2022-01-28T14:24:00.481Z","comments":true,"path":"posts/15234.html","link":"","permalink":"http://sn1987a-1.github.io/posts/15234.html","excerpt":"","text":"模拟与数字电路[TOC] 2022.1.15 模拟与数字电路期末考试2021.11.11期中考试主要内容： 数字逻辑概论: 数值转换 二进制数的算术运算 逻辑代数&amp;HDL基础 反演规则 对偶规则 最大项/最小项 表达式化简 直接化简 卡诺图 逻辑函数表示方法之间的转换 真值表 表达式 逻辑图 波形图 逻辑门电路 组合逻辑电路/PLD✨ 锁存器和触发器✨ 时序逻辑电路（仅包含同步时序电路）✨ 信号——数字部分；周期性；占空比：高电平占周期的百分比 进制进制：Binary Octal Hexadecimal（0x）二进制转换：“误差不大于$2^{-n}$” &lt;=&gt; “精确到小数点第n位” 第n位“四舍五入”即可 二进制的算术运算：补码=原码取反+1；补码表示范围$-2^{n-1}~2^{n-1}-1$ 补码转原码：从右往左找到第一个‘1’，将这个1之前的取反，该数字和之后的保持原值即可。$$(X+Y)_补=(X)_补+(Y)_补$$ $$(X-Y)_补=(X)_补-\\overline{(Y)_补}+1$$ 溢出：运算结果超出补码的表示范围 ​ 出现场合：同号相加，异号相减———&gt;判断结果是否正确（是否溢出）：判断计算过程中符号位和次高位的进位情况，当且仅当符号位有进位且次高位无进位时计算结果溢出。 溢出解决方案—符号拓展：通过利用两个或多个符号位，初始统一置0或1，最终结果看第一位的状态。 BCD码（无特殊说明BCD码均指8421码）有权码：8421码，5421码，2421码（数字代表各位的权重） 无权码：余3码，余3循环码 余3循环码：（0~9） 数值 0 1 2 3 4 5 6 7 8 9 余3循环码 0010 0110 0111 0101 0100 1100 1101 1111 1110 1010 格雷码编码顺序依次变化时，相邻代码有且仅有一位不同，最大和最小之间也差一位，也称循环码（余3循环码也满足该条件）（0~15） 格雷码——&gt;二进制码转化：从最高位到最低位依次相加 数值 0 1 2 3 4 5 6 7 8 9 A B C D E F 格雷码 0000 0001 0011 0010 0110 0111 0101 0100 1100 1101 1111 1110 1010 1011 1001 1000 二进制码 0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111 进制转换： 任意进制-&gt;十进制：按位权展开后相加$$(N)R=\\sum{i=-m}^{n-1}k_i*R^i$$ ​ 2.十进制-&gt;任意进制： ​ 整数部分：辗转除基取余，先得较低有效位 ​ 小数部分：辗转乘积取整，先得最高有效位 逻辑代数基本定律： 交换律 A* B=B *A; A+B=B+A; 结合律 A(BC)=(AB)C; A+(B+C)=(A+B)+C; 分配律 A(B+C)=AB+AC; A+BC=(A+B)(A+C); 吸收律 A+A* B=A; A*(A+B)=A; 反演律 $\\overline{A+B}=\\overline {A}*\\overline {B}$ ; $\\overline{AB}=\\overline{A}+\\overline{B};$ 代入规则:在任一逻辑恒等式中,若以一个逻辑表达式代替恒等式两边所有出现的某一变量,则所得表达式依然成立.利用该结论可以把上述定律推广到n元的情况,即反演律可以写成:$$\\overline{A_1A_2…*A_n}=\\overline{A_1}+\\overline{A_2}+…+\\overline{A_n}$$ $$\\overline{A_1+A_2+…+A_n}=\\overline{A_1}\\overline{A_2}…*\\overline{A_n}$$ 反演和对偶反演规则:对于任意表达式Y,将所有表达式中的’*’和’+’互换,将所有的’0’与’1’互换,把逻辑变量取反. 对偶规则:对于任意表达式Y,将所有表达式中的’*’和’+’互换,但不改变所有的’0’与’1’互换和逻辑变量. 利用对偶规则可以对上述基本定律进行拓展. 逻辑表达式对于一个逻辑函数,有多个逻辑表达式:(下以/AB+A/C为例) 与或式—–$\\overline {AB}+A\\overline C;$ 或与式——$(A+\\overline B)*(\\overline A+C)$ 与非-与非式——$\\overline {\\overline{\\overline AB}\\ \\ \\overline {A\\overline C}}$———最简与或式求两次反 或非-或非式——$\\overline {(\\overline A+B)+(\\overline A+\\overline C)}$——最简或与式求两次反 与或非式——$\\overline {\\overline A\\ \\overline B+AC}$———-先求/Y的最简与或式,然后求反 最小项与最大项最小项:包含全部输入变量的乘积项,每个变量均以自身变量或反变量出现一次.对于n变量逻辑函数,共有2^n个最小项,记为mi,其中i为最小项的编号[1]. [1]编号:编号方法:原变量和反变量分别带表1和0,带入逻辑表达式得到的二进制数对应的十进制数记为编号i. 对于任意一个最小项,有且仅有一组变量使得mi=1成立,且对于不同的i,对应不同的变量; 全体最小项的并恒等于1; 任意两个最小项的交恒等于0; 最大项:包含全部输入变量的或项,每个变量均以自身变量或反变量出现一次.对于n变量逻辑函数,共有2^n个最大项,记为Mi,其中i为最大项的编号[2]. [2]编号:编号方法:原变量和反变量分别带表1和0,带入逻辑表达式得到的二进制数取反对应的十进制数记为编号i. 性质可以和最小项类似 最大项和最小项的关系:$$\\overline{M_i}=m_i; M_i=\\overline{m_i}$$ 卡诺图卡诺图通常用在逻辑变量在5以内的情况. 卡诺图物理上相邻的逻辑变量在逻辑上相邻(上下相邻,左右相邻,,循环相邻,对角不相邻)—–循环码 无关项x:不允许或不可能出现的最小项/对应的函数值是任意值. 卡诺图化简逻辑表达式 规范作图： 00 01 11 10顺序 注明各个逻辑变量名称 画圈标记—写对应表达式 最简或与式—-圈0取反 圈0取反后不一定是原问题的最简与或式.(?) 逻辑门电路PMOS:高电平不导通,低电平导通.不能接地 NMOS:高电平导通,低电平不导通,不能接高电平 非门:2个CMOS;与非门/或非门:4个CMOS;与门/或门:6个COMS 组合逻辑电路定义:对于一个逻辑电路,在任何一个时刻的输出状态只与输入状态有关,与电路自身状态无关. 电路功能分析思路: 根据输入输出写出各级逻辑表达式,直到输入和输出信号的逻辑表达式; 将各个逻辑表达式化简和变换得到最简表达式; 根据表达式列出真值表; 根据真值表和最简逻辑表达式对组合逻辑电路进行分析,最后确定其功能. 组合逻辑电路设计过程 明确实际问题的逻辑功能,确定输入输出和表示符号; 根据对电路逻辑功能的要求写出真值表; 利用真值表得出逻辑表达式并进程化简变换;(卡诺图) 利用得到的逻辑表达式画出电路图. 画波形图要点: 画出原题的波形,画出时钟信号的边缘的虚线… 典型组合逻辑电路编码器优先编码器CD4532: 8信号输入3信号输出; 输入输出均以高电平有效; EI/EO:输入/输出使能端,均高电平有效,否则输出端均为低电平,EI为低电平时GS,EO必定是低电平, EI是1且输入均为低电平时EO输出为1,可以用于连接下一编码器的使能输入端```````````` ; GS:编码工作状态:EI是一且至少有一个高电平输入(表明正在工作)时为1; 优先级:I7&gt;I6&gt;…&gt;I0. 译码器74x138/74x139 输入输出低电平有效 E_3高电平有效 数据分配器数据选择器数值比较器基本算术电路 半加器 全加器 多位数加法器(串行进位加法器/超前进位加法器) PLD分类 PROM 或阵列可编程逻辑 PLA 与或阵列均可编程逻辑 PAL与阵列可编程逻辑 锁存器和触发器细节: 相对于锁存器,触发器的不同在于沿时钟边沿触发 画图时时钟信号小三角;上升沿一般用CP表示;下降沿/CP;有圆圈通常表示下降沿触发. 激励方程:$$SR ff:Q^{n+1}=S+\\overline RQ^n(SR=0)$$ $$Dff: Q^{n+1}=D$$ $$JKff:Q^{n+1}=J\\overline {Q^n}+\\overline KQ^n$$ 时序逻辑电路时序逻辑电路分析Mealy型:输出是当前状态和输入的函数 Moore型:输出是当前状态的函数 分析思路 根据逻辑图写出逻辑方程 输出方程(判断Mealy/Moore) 激励方程:每个触发器的输入驱动方程(J/K=…) 状态方程:激励方程代入触发器的特征方程得到(Q(n-1)=…) 列出状态表_根据mealy/moore型画出对应的表—–&gt;画出状态图(图例!)/时序图 最后确定电路的逻辑功能 时序逻辑电路设计 给定逻辑功能的要求（文字描述或者是波形图）， 求相应的逻辑电路 设计的一般步骤 建立原始状态图（状态可以用易懂或易写的方式表示）和原始状态表 状态化简（在面对同输入得到同输出和同次态NS的现 Q 态是等价的) 状态编码 求状态方程和输出方程 检查自启动 选择触发器类型，求激励方程（激励表或其他方法） 画出逻辑图 尽量要求自己设计同步时序电路，因为后面在写verilog的时候一般都用统一的时钟 另外异步时序电路输出信号质量差，工作速度低 以上内容为期中考试主要内容，其中的逻辑电路分析和设计的重难点在期末考试中仍会涉及 期末考试额外的内容： 数字系统设计 数字系统结构 算术逻辑单元 寄存器传送 具体问题求解：最大值/排序/乘法电路 Verilog HDL Timing Analysis &amp; Synchronization 存储器，PLD，ListProcessor 二极管 三极管 基本放大电路 集成运放 逻辑门电路 ADC和DAC Verilog HDL/FSM常量表示形式： 整数型&lt;+/-&gt;&lt;位宽&gt;’&lt;基数符号(D/d,B/b,O/o,H/h)&gt;&lt;数值&gt; 实数型：1·科学计数法 2·十进制计数法 符号常量定义 parameter 数据变量类型： net(wire) register(reg) 定义格式： wire/reg [MSB/LSB] r1,r2,... 赋值语句：连续赋值语句assign；过程块赋值inital/always 常用语法（过程块赋值内）case/if else/begin end 模块实例化1.位置映射modulename M(A,B,C)；2.名称映射modulename M(.A(a),.C(c),.B(b))——不可混用 运算符 算术运算符 逐位计算 关系运算符 位运算符：~ ,&amp;,^ , | , ^~ / ~^（同或） 逻辑运算符：&amp;&amp;，！，|| 位拼接符：{, , } {n{}} 移位运算符：&gt;&gt;,&lt;&lt;,&gt;&gt;&gt;(算数右移) 缩位运算符（单目运算符）：&amp;，&amp;，| ，|，^, ^~, ~ ^ 条件运算符：？： 运算符优先级= = module (input i,output o,inout io); wire ...; parameter M=...; reg [M:m]...; assign ...; modulename name(i,o); initial begin ...; end always @(...) begin if ...; else ...; case (敏感表达式) 1:...; 2:...; ... default:...; endcase end endmodule 使用if/case语句时应该避免出现锁存器。 组合逻辑：阻塞赋值（blocking） ：‘=’块内赋值语句顺序执行 时序逻辑：非阻塞赋值（non-locking）：‘&lt;=’块内赋值语句并发进行 FSM 一段式/两段式/三段式 CS：现态；NS：次态；OUT：输出 两段式：一个时序过程描述CS，另一个组合描述NS和OUT 三段式：两个时序描述CS和OUT，一个组合过程描述NS 时序逻辑电路2寄存器寄存器是若干具有相同外观电路结构的共享时钟和控制信号的触发器 普通寄存器/移位寄存器 74x194:双向通用移位寄存器 功能表： 不添加其他逻辑门即可实现位拓展 应用：实现序列检测 计数器累计时钟脉冲次数，可以用来分频，定时，产生节拍脉冲 模：循环遍历的有效状态数 异步递增计数器：电路简单，易于拓展，但工作效率低，不适用 同步递增计数器： 74x161 74x160:模10计数器，与74x161相似 任意进制计数器构成 •用N进制计数器构成 M 进制计数器 •若 M &lt; N ，可在计数过程中设法跳过 N-M 个多余状态 ​ –反馈清零法，简称清零法 ​ –反馈置数法，简称置数法 •若 M &gt; N ，用多片 N 进制计数器级连，配合清零 / 置数法构成 要注意同步清零和异步清零清零时的数值是不一致的，通常同步+1=异步，置数同理——可以画状态图，异步的临界状态可以画虚线 用移位寄存器实现计数器，如环形计数器：将串行输入与串行输出直接相连，计数状态等于寄存器的位数。 扭环型计数器：约翰孙计数器，计数状态是环形计数器的2倍 有效循环：每次状态转换只更改一位 数字系统开关去抖动 数字系统组成：Data Path+Control Unit 实例：时序二进制乘法器，求最大值，排序","categories":[{"name":"数字电路","slug":"数字电路","permalink":"http://sn1987a-1.github.io/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"专业课","slug":"专业课","permalink":"http://sn1987a-1.github.io/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"},{"name":"模拟与数字电路","slug":"模拟与数字电路","permalink":"http://sn1987a-1.github.io/tags/%E6%A8%A1%E6%8B%9F%E4%B8%8E%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"线性筛的理解和应用","slug":"Algorithm","date":"2021-10-24T15:43:35.000Z","updated":"2022-01-28T14:22:32.341Z","comments":true,"path":"posts/15547.html","link":"","permalink":"http://sn1987a-1.github.io/posts/15547.html","excerpt":"","text":"线性筛的理解和应用最近在准备相关算法竞赛，正好班里有写博客的活动，就在此记录下自己菜不成声学习的过程。&gt;v&lt; 为算出小于等于n的素数的个数，较自然也是最暴力的的方法便是对每个小于n的正整数进行判定，这样的方法显然达到最优的复杂度，暴力硬解的结果无疑是最终喜提“Time Limit Exceeded”。 为提高算法效率，就要引入“筛”的思想——主要思想是：我们选出一个数n时无论n是素数还是合数，2n,3n,..都是合数，我们无需对这类数进行是否为素数的判断。 Eratosthenes 筛法 （埃拉托斯特尼筛法，简称埃氏筛）埃氏筛算法的主要思想是：如果我们从小到大考虑每个数，然后同时把当前这个数的所有（比自己大的）倍数记为合数，那么运行结束的时候没有被标记的数就是素数了。具体算法如下： int Eratosthenes(int n) { int p = 0; for (int i = 0; i &lt;= n; ++i) is_prime[i] = 1; is_prime[0] = is_prime[1] = 0; for (int i = 2; i &lt;= n; ++i) { if (is_prime[i]) { prime[p++] = i; // prime[p]是i,后置自增运算代表当前素数数量 for (int j = i * i; j &lt;= n; j += i) // 因为从 2 到 i - 1 的倍数我们之前筛过了，这里直接从 i // 的倍数开始，提高了运行速度 is_prime[j] = 0; //是i的倍数的均不是素数 } } return p; } 埃氏筛通常可以称为普通筛，结构比较简单，也比较容易理解，其核心就是对找到的素数的倍数通过一次循环进行标记，虽然要额外占用O(n)的内存空间保存标记，但非常高效地减少了程序复杂度。 我们应该注意到，埃氏筛在对数字进行标记筛选时，存在重复筛选，比如6既可以被2筛掉，又可以被3筛掉。原因：任意一个整数可以写成一些素数的乘积$$n=p1^ip2^jp3^k$$其中p1&lt;p2&lt;p3，这样这个数n能被p1,p2和p3筛掉,反复被标记，尤其在n比较大的时候，n可能有相当多个素因子，被多次标记，显然浪费了时间。 Euler筛法(线性筛)基于普通筛的不足之处，Euler对其做出了修改——直观地来说，当我们用埃氏筛法对一个素数的n倍进行筛选时，若正在被标记的这个倍数已经足够大，大到超过一特定的数字后，那这个数一定有更大的素因子，能在后续过程中再次被标记，此时就可以停止循环，算法继续对下一个未标记的数进行是否为素数的判断。 通过观察不难发现，若当前正在处理n的i倍数in，i能整除n，那么i与下一个要进行筛选的数的乘积这个合数肯定会被n乘以某个数提前筛掉。因此这里的i便是我们要找的“特定的数字”，利用这一数字提前break掉循环，可以使得每个数字均被筛选一次，将时间复杂度降到最低，这也就是Euler筛的算法思想，实现代码如下所示。 void init() { phi[1] = 1; for (int i = 2; i &lt; MAXN; ++i) { if (!vis[i]) { phi[i] = i - 1; pri[cnt++] = i; } for (int j = 0; j &lt; cnt; ++j) { if (1ll * i * pri[j] &gt;= MAXN) break; vis[i * pri[j]] = 1; if (i % pri[j]) { phi[i * pri[j]] = phi[i] * (pri[j] - 1); } else { // i % pri[j] == 0 // 换言之，i 之前被 pri[j] 筛过了 // 由于 pri 里面质数是从小到大的，所以 i 乘上其他的质数的结果一定会被 // pri[j] 的倍数筛掉，就不需要在这里先筛一次，所以这里直接 break // 掉就好了 phi[i * pri[j]] = phi[i] * pri[j]; break; } } } } 关键之处在：if(i%prime[j]==0) break; 这句代码保证了每个数最多被筛一次，将时间复杂度降到了线性。 证：prime[]数组中的素数是递增的,当i能整除prime[j]，那么iprime[j+1]这个合数肯定会被prime[j]乘以某个数筛掉。因此，这里直接break掉，将iprime[j+1]及之后的给后面的数去筛。这种方法能保证每个数只被筛一遍，又能保证每个数都被筛到。 为了更好的理解，画出前面几次筛的情况: 一般来说，当筛选范围n较小时，埃氏筛和欧氏筛复杂度较相近，甚至埃氏筛表现更好，但随着n的增大，欧氏筛的优越性也逐渐体现出来，可以达到埃氏筛3-4倍的速度。 参考： 1.线性筛的理解及应用 - Rogn - 博客园 (cnblogs.com) 2.线性筛_历尽千帆-CSDN博客_线性筛","categories":[{"name":"算法","slug":"算法","permalink":"http://sn1987a-1.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"practice","slug":"算法/practice","permalink":"http://sn1987a-1.github.io/categories/%E7%AE%97%E6%B3%95/practice/"}],"tags":[{"name":"线性筛","slug":"线性筛","permalink":"http://sn1987a-1.github.io/tags/%E7%BA%BF%E6%80%A7%E7%AD%9B/"},{"name":"算法","slug":"算法","permalink":"http://sn1987a-1.github.io/tags/%E7%AE%97%E6%B3%95/"}]}],"categories":[{"name":"WSL2","slug":"WSL2","permalink":"http://sn1987a-1.github.io/categories/WSL2/"},{"name":"数据结构","slug":"数据结构","permalink":"http://sn1987a-1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"图论","permalink":"http://sn1987a-1.github.io/categories/%E5%9B%BE%E8%AE%BA/"},{"name":"数字电路","slug":"数字电路","permalink":"http://sn1987a-1.github.io/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"},{"name":"算法","slug":"算法","permalink":"http://sn1987a-1.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"practice","slug":"算法/practice","permalink":"http://sn1987a-1.github.io/categories/%E7%AE%97%E6%B3%95/practice/"}],"tags":[{"name":"美化","slug":"美化","permalink":"http://sn1987a-1.github.io/tags/%E7%BE%8E%E5%8C%96/"},{"name":"Unix","slug":"Unix","permalink":"http://sn1987a-1.github.io/tags/Unix/"},{"name":"专业课","slug":"专业课","permalink":"http://sn1987a-1.github.io/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"},{"name":"数据结构","slug":"数据结构","permalink":"http://sn1987a-1.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"图论","permalink":"http://sn1987a-1.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"模拟与数字电路","slug":"模拟与数字电路","permalink":"http://sn1987a-1.github.io/tags/%E6%A8%A1%E6%8B%9F%E4%B8%8E%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"},{"name":"线性筛","slug":"线性筛","permalink":"http://sn1987a-1.github.io/tags/%E7%BA%BF%E6%80%A7%E7%AD%9B/"},{"name":"算法","slug":"算法","permalink":"http://sn1987a-1.github.io/tags/%E7%AE%97%E6%B3%95/"}]}