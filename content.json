{"meta":{"title":"SN1987A","subtitle":"LAYのBLOG","description":"Learn not and know not.","author":"SN1987A","url":"http://sn1987a-1.github.io","root":"/"},"pages":[{"title":"关于本站","date":"2020-04-19T04:58:56.000Z","updated":"2022-01-27T13:30:38.046Z","comments":false,"path":"about/index.html","permalink":"http://sn1987a-1.github.io/about/index.html","excerpt":"","text":"SN1987ALearn not and know not. ustc cser 2020. = = 联系我QQ：945093063 邮箱:lay_sn1987a@mali.ustc.edu.cn"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2022-01-27T13:30:38.046Z","comments":true,"path":"archives/index.html","permalink":"http://sn1987a-1.github.io/archives/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-06-07T14:17:49.000Z","updated":"2022-01-27T13:30:38.046Z","comments":true,"path":"link/index.html","permalink":"http://sn1987a-1.github.io/link/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-10-31T02:11:28.000Z","updated":"2022-01-27T13:30:38.046Z","comments":false,"path":"comments/index.html","permalink":"http://sn1987a-1.github.io/comments/index.html","excerpt":"","text":"new Artitalk({ appId: 'o2lydQokojD1IP8EGhex24WU-MdYXbMMI', appKey: '8ykSyPm9CwzCDdR5dbid1AWT' })"},{"title":"我的歌单","date":"2019-05-17T08:14:00.000Z","updated":"2022-01-27T13:30:38.046Z","comments":true,"path":"music/index.html","permalink":"http://sn1987a-1.github.io/music/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-24T07:14:39.000Z","updated":"2022-01-27T13:30:38.046Z","comments":false,"path":"tags/index.html","permalink":"http://sn1987a-1.github.io/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-01-27T13:30:37.996Z","updated":"2022-01-27T13:30:37.996Z","comments":false,"path":"List/gallery/index.html","permalink":"http://sn1987a-1.github.io/List/gallery/index.html","excerpt":"","text":"壁纸 收藏的一些壁纸 OH MY GIRL 关于OH MY GIRL的图片"},{"title":"","date":"2019-08-10T08:41:10.000Z","updated":"2022-01-27T13:30:37.996Z","comments":false,"path":"List/movies/index.html","permalink":"http://sn1987a-1.github.io/List/movies/index.html","excerpt":"","text":"励志视频"},{"title":"Music-BBOX","date":"2020-04-23T04:58:56.000Z","updated":"2022-01-27T13:30:37.996Z","comments":false,"path":"List/music/index.html","permalink":"http://sn1987a-1.github.io/List/music/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-11-24T07:12:19.000Z","updated":"2022-01-27T13:30:38.046Z","comments":false,"path":"categories/index.html","permalink":"http://sn1987a-1.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-11-24T08:05:01.000Z","updated":"2022-01-27T13:30:37.996Z","comments":false,"path":"List/gallery/ohmygirl/index.html","permalink":"http://sn1987a-1.github.io/List/gallery/ohmygirl/index.html","excerpt":"","text":""},{"title":"","date":"2022-01-27T13:30:37.996Z","updated":"2022-01-27T13:30:37.996Z","comments":false,"path":"List/gallery/wallpaper/index.html","permalink":"http://sn1987a-1.github.io/List/gallery/wallpaper/index.html","excerpt":"","text":""}],"posts":[{"title":"WSL2美化","slug":"WSL2美化","date":"2022-01-21T14:12:20.000Z","updated":"2022-02-05T15:34:13.444Z","comments":true,"path":"posts/15684.html","link":"","permalink":"http://sn1987a-1.github.io/posts/15684.html","excerpt":"","text":"WSL2美化本文简要记录基于Windows11对WSL的终端进行美化的主要步骤。 环境：Ubuntu 20.04，Windows Terminal(WT) 主要工具和插件：zsh，oh my zsh, povwerlevel10k(powerlevel9k也可以),autozsh-autosuggestions , zsh-syntax-highlig 下图是我的美化结果。 对Windows terminal的外观进行美化在微软应用商店搜索Windows terminal即可下载最新版本，如果不想用Windows Terminal，也可以下载另外一个跨平台终端——Tabby Terminal，点击下载)，配置方案也类似，但亲测效果不如WT。 修改默认配置打开Windows Terminal，点击上方栏中“v”按钮，选择侧边栏中的“setting.json”文件并打开，后文中对WT的配置均对该文件进行修改（可以用VScode打开）。 例如，若要规定默认打开的界面是WSL2/WSL的界面，即可在actions一栏进行修改： \"defaultProfile\": \"{07b52e3e-de2c-5db4-bd2d-ba144ed6c273}\",//括号内对应的序列可在setting.json文件里查找到Ubuntu对应的GUID 修改配色方案在setting.json最后部分有schemes一栏，代表WT的配色方案，每个配色方案的name项即为名称，系统默认提供了一部分配色方案以及名称，但都不是很好看，将自定义配色添加到schemes底下即可新增配色方案，自定义配色网站)提供了较多推荐的配色，可以直接复制。 以下为我选择的配色： { \"name\": \"ChallengerDeep\", \"black\": \"#141228\", \"red\": \"#ff5458\", \"green\": \"#62d196\", \"yellow\": \"#ffb378\", \"blue\": \"#65b2ff\", \"purple\": \"#906cff\", \"cyan\": \"#63f2f1\", \"white\": \"#a6b3cc\", \"brightBlack\": \"#565575\", \"brightRed\": \"#ff8080\", \"brightGreen\": \"#95ffa4\", \"brightYellow\": \"#ffe9aa\", \"brightBlue\": \"#91ddff\", \"brightPurple\": \"#c991e1\", \"brightCyan\": \"#aaffe4\", \"brightWhite\": \"#cbe3e7\", \"background\": \"#1e1c31\", \"foreground\": \"#cbe1e7\", \"selectionBackground\": \"#cbe1e7\", \"cursorColor\": \"#fbfcfc\" }, 添加完配色方案后，还应该对profiles部分进行修改，以便于使用最新配色方案。如果只需要对虚拟机部分添加如下文本，可以只修改name为“Ubuntu-xx.xx”的部分（当然其他部分也只是复制粘贴）。 \"colorScheme\": \"ChallengerDeep\", 修改字体Windows原装字体不支持很多符号的显示，这里推荐修改默认字体 比较简单的，可以在微软官方下载)Cascadia Code PL字体，或者是下载文件后右键单击该字体对应的.otf/.ttf文件并选择安装。 当然有功能更加强大，应用更加广泛的字体Nerd Fond(Hack Nerd Fond)，包含了更多字符库，点击下载](https://github.com/ryanoasis/nerd-fonts))。 安装完成后，同样在profiles目录的Ubuntu-xx.xx里修改： \"fontFace\": \"Hack Nerd Fond\" \"fontSize\": 10, 设置背景和透明效果均是在perfiles目录内 添加背景图： \"backgroundImage\": \"E:\\\\wallpaper\\\\wp3.jpg\",//背景的地址 添加透明效果（0~1，越小表示越透明） \"acrylicOpacity\": 0.8, \"useAcrylic\": true 指定启动时的默认路径： \"startingDirectory\": \"./\", 这样Windows Terminal基本就配置好了。 美化WSL2步骤： 将原有的shell替换为zsh 安装oh my zsh 关键字高亮以及自动填充插件 安装powerlevel10k 安装完自动填充以及高亮插件后对文件zshrc进行的主要添加为： source /usr/share/zsh-autosuggestions/zsh-autosuggestions.zsh source /usr/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh 这里主要从安装powerlevel10k开始记录。 在命令行输入： sudo vim ~/.zshrc 打开配置文件后，找到THEME一行，修改为： ZSH_THEME=\"powerlevel10k/powerlevel10k\" 之后重启或输入命令 p10k configure 之后填写弹出的问卷即可自定义并保存当前配置文件。如果需要使用其他路径的文件，可以使用source命令进行导入。","categories":[{"name":"WSL2","slug":"WSL2","permalink":"http://sn1987a-1.github.io/categories/WSL2/"}],"tags":[{"name":"美化","slug":"美化","permalink":"http://sn1987a-1.github.io/tags/%E7%BE%8E%E5%8C%96/"},{"name":"Unix","slug":"Unix","permalink":"http://sn1987a-1.github.io/tags/Unix/"}]},{"title":"数据结构实验设计2_HUFFMAM Tree","slug":"11-11","date":"2021-11-11T11:46:11.000Z","updated":"2022-01-28T14:22:14.921Z","comments":true,"path":"posts/1120.html","link":"","permalink":"http://sn1987a-1.github.io/posts/1120.html","excerpt":"","text":"Huffman 编码解压缩关于Huffman编码的知识,在上个学期数据结构已经学过,作为较为复杂的一次实验耗费了不少时间,可说实话,上个学期在数据结构投入的经历确实不算大,最终的成绩也相当不理想,但这个学期还得重新学数据结构(信计数据结构不能互认就离谱orz),同样类型的实验,不同的心境 ,不同的要求,只求要一个好一点点的分数啦 大致实验要求基于Huffman编码来实现压缩器和编码器,使其可以对任意文件进行解压缩操作. 实现方法:命令行执行/GUI界面(还不会…)/运行程序交互界面 本实验的测试数据:文件包括:.txt .png .wav .mp4 .zip","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://sn1987a-1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"专业课","slug":"专业课","permalink":"http://sn1987a-1.github.io/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"},{"name":"数据结构","slug":"数据结构","permalink":"http://sn1987a-1.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"模拟与数字电路期中复习","slug":"模拟与数字电路复习","date":"2021-11-05T15:42:30.000Z","updated":"2022-01-28T14:24:00.481Z","comments":true,"path":"posts/15234.html","link":"","permalink":"http://sn1987a-1.github.io/posts/15234.html","excerpt":"","text":"模拟与数字电路[TOC] 2022.1.15 模拟与数字电路期末考试2021.11.11期中考试主要内容： 数字逻辑概论: 数值转换 二进制数的算术运算 逻辑代数&amp;HDL基础 反演规则 对偶规则 最大项/最小项 表达式化简 直接化简 卡诺图 逻辑函数表示方法之间的转换 真值表 表达式 逻辑图 波形图 逻辑门电路 组合逻辑电路/PLD✨ 锁存器和触发器✨ 时序逻辑电路（仅包含同步时序电路）✨ 信号——数字部分；周期性；占空比：高电平占周期的百分比 进制进制：Binary Octal Hexadecimal（0x）二进制转换：“误差不大于$2^{-n}$” &lt;=&gt; “精确到小数点第n位” 第n位“四舍五入”即可 二进制的算术运算：补码=原码取反+1；补码表示范围$-2^{n-1}~2^{n-1}-1$ 补码转原码：从右往左找到第一个‘1’，将这个1之前的取反，该数字和之后的保持原值即可。$$(X+Y)_补=(X)_补+(Y)_补$$ $$(X-Y)_补=(X)_补-\\overline{(Y)_补}+1$$ 溢出：运算结果超出补码的表示范围 ​ 出现场合：同号相加，异号相减———&gt;判断结果是否正确（是否溢出）：判断计算过程中符号位和次高位的进位情况，当且仅当符号位有进位且次高位无进位时计算结果溢出。 溢出解决方案—符号拓展：通过利用两个或多个符号位，初始统一置0或1，最终结果看第一位的状态。 BCD码（无特殊说明BCD码均指8421码）有权码：8421码，5421码，2421码（数字代表各位的权重） 无权码：余3码，余3循环码 余3循环码：（0~9） 数值 0 1 2 3 4 5 6 7 8 9 余3循环码 0010 0110 0111 0101 0100 1100 1101 1111 1110 1010 格雷码编码顺序依次变化时，相邻代码有且仅有一位不同，最大和最小之间也差一位，也称循环码（余3循环码也满足该条件）（0~15） 格雷码——&gt;二进制码转化：从最高位到最低位依次相加 数值 0 1 2 3 4 5 6 7 8 9 A B C D E F 格雷码 0000 0001 0011 0010 0110 0111 0101 0100 1100 1101 1111 1110 1010 1011 1001 1000 二进制码 0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111 进制转换： 任意进制-&gt;十进制：按位权展开后相加$$(N)R=\\sum{i=-m}^{n-1}k_i*R^i$$ ​ 2.十进制-&gt;任意进制： ​ 整数部分：辗转除基取余，先得较低有效位 ​ 小数部分：辗转乘积取整，先得最高有效位 逻辑代数基本定律： 交换律 A* B=B *A; A+B=B+A; 结合律 A(BC)=(AB)C; A+(B+C)=(A+B)+C; 分配律 A(B+C)=AB+AC; A+BC=(A+B)(A+C); 吸收律 A+A* B=A; A*(A+B)=A; 反演律 $\\overline{A+B}=\\overline {A}*\\overline {B}$ ; $\\overline{AB}=\\overline{A}+\\overline{B};$ 代入规则:在任一逻辑恒等式中,若以一个逻辑表达式代替恒等式两边所有出现的某一变量,则所得表达式依然成立.利用该结论可以把上述定律推广到n元的情况,即反演律可以写成:$$\\overline{A_1A_2…*A_n}=\\overline{A_1}+\\overline{A_2}+…+\\overline{A_n}$$ $$\\overline{A_1+A_2+…+A_n}=\\overline{A_1}\\overline{A_2}…*\\overline{A_n}$$ 反演和对偶反演规则:对于任意表达式Y,将所有表达式中的’*’和’+’互换,将所有的’0’与’1’互换,把逻辑变量取反. 对偶规则:对于任意表达式Y,将所有表达式中的’*’和’+’互换,但不改变所有的’0’与’1’互换和逻辑变量. 利用对偶规则可以对上述基本定律进行拓展. 逻辑表达式对于一个逻辑函数,有多个逻辑表达式:(下以/AB+A/C为例) 与或式—–$\\overline {AB}+A\\overline C;$ 或与式——$(A+\\overline B)*(\\overline A+C)$ 与非-与非式——$\\overline {\\overline{\\overline AB}\\ \\ \\overline {A\\overline C}}$———最简与或式求两次反 或非-或非式——$\\overline {(\\overline A+B)+(\\overline A+\\overline C)}$——最简或与式求两次反 与或非式——$\\overline {\\overline A\\ \\overline B+AC}$———-先求/Y的最简与或式,然后求反 最小项与最大项最小项:包含全部输入变量的乘积项,每个变量均以自身变量或反变量出现一次.对于n变量逻辑函数,共有2^n个最小项,记为mi,其中i为最小项的编号[1]. [1]编号:编号方法:原变量和反变量分别带表1和0,带入逻辑表达式得到的二进制数对应的十进制数记为编号i. 对于任意一个最小项,有且仅有一组变量使得mi=1成立,且对于不同的i,对应不同的变量; 全体最小项的并恒等于1; 任意两个最小项的交恒等于0; 最大项:包含全部输入变量的或项,每个变量均以自身变量或反变量出现一次.对于n变量逻辑函数,共有2^n个最大项,记为Mi,其中i为最大项的编号[2]. [2]编号:编号方法:原变量和反变量分别带表1和0,带入逻辑表达式得到的二进制数取反对应的十进制数记为编号i. 性质可以和最小项类似 最大项和最小项的关系:$$\\overline{M_i}=m_i; M_i=\\overline{m_i}$$ 卡诺图卡诺图通常用在逻辑变量在5以内的情况. 卡诺图物理上相邻的逻辑变量在逻辑上相邻(上下相邻,左右相邻,,循环相邻,对角不相邻)—–循环码 无关项x:不允许或不可能出现的最小项/对应的函数值是任意值. 卡诺图化简逻辑表达式 规范作图： 00 01 11 10顺序 注明各个逻辑变量名称 画圈标记—写对应表达式 最简或与式—-圈0取反 圈0取反后不一定是原问题的最简与或式.(?) 逻辑门电路PMOS:高电平不导通,低电平导通.不能接地 NMOS:高电平导通,低电平不导通,不能接高电平 非门:2个CMOS;与非门/或非门:4个CMOS;与门/或门:6个COMS 组合逻辑电路定义:对于一个逻辑电路,在任何一个时刻的输出状态只与输入状态有关,与电路自身状态无关. 电路功能分析思路: 根据输入输出写出各级逻辑表达式,直到输入和输出信号的逻辑表达式; 将各个逻辑表达式化简和变换得到最简表达式; 根据表达式列出真值表; 根据真值表和最简逻辑表达式对组合逻辑电路进行分析,最后确定其功能. 组合逻辑电路设计过程 明确实际问题的逻辑功能,确定输入输出和表示符号; 根据对电路逻辑功能的要求写出真值表; 利用真值表得出逻辑表达式并进程化简变换;(卡诺图) 利用得到的逻辑表达式画出电路图. 画波形图要点: 画出原题的波形,画出时钟信号的边缘的虚线… 典型组合逻辑电路编码器优先编码器CD4532: 8信号输入3信号输出; 输入输出均以高电平有效; EI/EO:输入/输出使能端,均高电平有效,否则输出端均为低电平,EI为低电平时GS,EO必定是低电平, EI是1且输入均为低电平时EO输出为1,可以用于连接下一编码器的使能输入端```````````` ; GS:编码工作状态:EI是一且至少有一个高电平输入(表明正在工作)时为1; 优先级:I7&gt;I6&gt;…&gt;I0. 译码器74x138/74x139 输入输出低电平有效 E_3高电平有效 数据分配器数据选择器数值比较器基本算术电路 半加器 全加器 多位数加法器(串行进位加法器/超前进位加法器) PLD分类 PROM 或阵列可编程逻辑 PLA 与或阵列均可编程逻辑 PAL与阵列可编程逻辑 锁存器和触发器细节: 相对于锁存器,触发器的不同在于沿时钟边沿触发 画图时时钟信号小三角;上升沿一般用CP表示;下降沿/CP;有圆圈通常表示下降沿触发. 激励方程:$$SR ff:Q^{n+1}=S+\\overline RQ^n(SR=0)$$ $$Dff: Q^{n+1}=D$$ $$JKff:Q^{n+1}=J\\overline {Q^n}+\\overline KQ^n$$ 时序逻辑电路时序逻辑电路分析Mealy型:输出是当前状态和输入的函数 Moore型:输出是当前状态的函数 分析思路 根据逻辑图写出逻辑方程 输出方程(判断Mealy/Moore) 激励方程:每个触发器的输入驱动方程(J/K=…) 状态方程:激励方程代入触发器的特征方程得到(Q(n-1)=…) 列出状态表_根据mealy/moore型画出对应的表—–&gt;画出状态图(图例!)/时序图 最后确定电路的逻辑功能 时序逻辑电路设计 给定逻辑功能的要求（文字描述或者是波形图）， 求相应的逻辑电路 设计的一般步骤 建立原始状态图（状态可以用易懂或易写的方式表示）和原始状态表 状态化简（在面对同输入得到同输出和同次态NS的现 Q 态是等价的) 状态编码 求状态方程和输出方程 检查自启动 选择触发器类型，求激励方程（激励表或其他方法） 画出逻辑图 尽量要求自己设计同步时序电路，因为后面在写verilog的时候一般都用统一的时钟 另外异步时序电路输出信号质量差，工作速度低 以上内容为期中考试主要内容，其中的逻辑电路分析和设计的重难点在期末考试中仍会涉及 期末考试额外的内容： 数字系统设计 数字系统结构 算术逻辑单元 寄存器传送 具体问题求解：最大值/排序/乘法电路 Verilog HDL Timing Analysis &amp; Synchronization 存储器，PLD，ListProcessor 二极管 三极管 基本放大电路 集成运放 逻辑门电路 ADC和DAC Verilog HDL/FSM常量表示形式： 整数型&lt;+/-&gt;&lt;位宽&gt;’&lt;基数符号(D/d,B/b,O/o,H/h)&gt;&lt;数值&gt; 实数型：1·科学计数法 2·十进制计数法 符号常量定义 parameter 数据变量类型： net(wire) register(reg) 定义格式： wire/reg [MSB/LSB] r1,r2,... 赋值语句：连续赋值语句assign；过程块赋值inital/always 常用语法（过程块赋值内）case/if else/begin end 模块实例化1.位置映射modulename M(A,B,C)；2.名称映射modulename M(.A(a),.C(c),.B(b))——不可混用 运算符 算术运算符 逐位计算 关系运算符 位运算符：~ ,&amp;,^ , | , ^~ / ~^（同或） 逻辑运算符：&amp;&amp;，！，|| 位拼接符：{, , } {n{}} 移位运算符：&gt;&gt;,&lt;&lt;,&gt;&gt;&gt;(算数右移) 缩位运算符（单目运算符）：&amp;，&amp;，| ，|，^, ^~, ~ ^ 条件运算符：？： 运算符优先级= = module (input i,output o,inout io); wire ...; parameter M=...; reg [M:m]...; assign ...; modulename name(i,o); initial begin ...; end always @(...) begin if ...; else ...; case (敏感表达式) 1:...; 2:...; ... default:...; endcase end endmodule 使用if/case语句时应该避免出现锁存器。 组合逻辑：阻塞赋值（blocking） ：‘=’块内赋值语句顺序执行 时序逻辑：非阻塞赋值（non-locking）：‘&lt;=’块内赋值语句并发进行 FSM 一段式/两段式/三段式 CS：现态；NS：次态；OUT：输出 两段式：一个时序过程描述CS，另一个组合描述NS和OUT 三段式：两个时序描述CS和OUT，一个组合过程描述NS 时序逻辑电路2寄存器寄存器是若干具有相同外观电路结构的共享时钟和控制信号的触发器 普通寄存器/移位寄存器 74x194:双向通用移位寄存器 功能表： 不添加其他逻辑门即可实现位拓展 应用：实现序列检测 计数器累计时钟脉冲次数，可以用来分频，定时，产生节拍脉冲 模：循环遍历的有效状态数 异步递增计数器：电路简单，易于拓展，但工作效率低，不适用 同步递增计数器： 74x161 74x160:模10计数器，与74x161相似 任意进制计数器构成 •用N进制计数器构成 M 进制计数器 •若 M &lt; N ，可在计数过程中设法跳过 N-M 个多余状态 ​ –反馈清零法，简称清零法 ​ –反馈置数法，简称置数法 •若 M &gt; N ，用多片 N 进制计数器级连，配合清零 / 置数法构成 要注意同步清零和异步清零清零时的数值是不一致的，通常同步+1=异步，置数同理——可以画状态图，异步的临界状态可以画虚线 用移位寄存器实现计数器，如环形计数器：将串行输入与串行输出直接相连，计数状态等于寄存器的位数。 扭环型计数器：约翰孙计数器，计数状态是环形计数器的2倍 有效循环：每次状态转换只更改一位 数字系统开关去抖动 数字系统组成：Data Path+Control Unit 实例：时序二进制乘法器，求最大值，排序","categories":[{"name":"数字电路","slug":"数字电路","permalink":"http://sn1987a-1.github.io/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"专业课","slug":"专业课","permalink":"http://sn1987a-1.github.io/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"},{"name":"模拟与数字电路","slug":"模拟与数字电路","permalink":"http://sn1987a-1.github.io/tags/%E6%A8%A1%E6%8B%9F%E4%B8%8E%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"线性筛的理解和应用","slug":"Algorithm","date":"2021-10-24T15:43:35.000Z","updated":"2022-01-28T14:22:32.341Z","comments":true,"path":"posts/15547.html","link":"","permalink":"http://sn1987a-1.github.io/posts/15547.html","excerpt":"","text":"线性筛的理解和应用最近在准备相关算法竞赛，正好班里有写博客的活动，就在此记录下自己菜不成声学习的过程。&gt;v&lt; 为算出小于等于n的素数的个数，较自然也是最暴力的的方法便是对每个小于n的正整数进行判定，这样的方法显然达到最优的复杂度，暴力硬解的结果无疑是最终喜提“Time Limit Exceeded”。 为提高算法效率，就要引入“筛”的思想——主要思想是：我们选出一个数n时无论n是素数还是合数，2n,3n,..都是合数，我们无需对这类数进行是否为素数的判断。 Eratosthenes 筛法 （埃拉托斯特尼筛法，简称埃氏筛）埃氏筛算法的主要思想是：如果我们从小到大考虑每个数，然后同时把当前这个数的所有（比自己大的）倍数记为合数，那么运行结束的时候没有被标记的数就是素数了。具体算法如下： int Eratosthenes(int n) { int p = 0; for (int i = 0; i &lt;= n; ++i) is_prime[i] = 1; is_prime[0] = is_prime[1] = 0; for (int i = 2; i &lt;= n; ++i) { if (is_prime[i]) { prime[p++] = i; // prime[p]是i,后置自增运算代表当前素数数量 for (int j = i * i; j &lt;= n; j += i) // 因为从 2 到 i - 1 的倍数我们之前筛过了，这里直接从 i // 的倍数开始，提高了运行速度 is_prime[j] = 0; //是i的倍数的均不是素数 } } return p; } 埃氏筛通常可以称为普通筛，结构比较简单，也比较容易理解，其核心就是对找到的素数的倍数通过一次循环进行标记，虽然要额外占用O(n)的内存空间保存标记，但非常高效地减少了程序复杂度。 我们应该注意到，埃氏筛在对数字进行标记筛选时，存在重复筛选，比如6既可以被2筛掉，又可以被3筛掉。原因：任意一个整数可以写成一些素数的乘积$$n=p1^ip2^jp3^k$$其中p1&lt;p2&lt;p3，这样这个数n能被p1,p2和p3筛掉,反复被标记，尤其在n比较大的时候，n可能有相当多个素因子，被多次标记，显然浪费了时间。 Euler筛法(线性筛)基于普通筛的不足之处，Euler对其做出了修改——直观地来说，当我们用埃氏筛法对一个素数的n倍进行筛选时，若正在被标记的这个倍数已经足够大，大到超过一特定的数字后，那这个数一定有更大的素因子，能在后续过程中再次被标记，此时就可以停止循环，算法继续对下一个未标记的数进行是否为素数的判断。 通过观察不难发现，若当前正在处理n的i倍数in，i能整除n，那么i与下一个要进行筛选的数的乘积这个合数肯定会被n乘以某个数提前筛掉。因此这里的i便是我们要找的“特定的数字”，利用这一数字提前break掉循环，可以使得每个数字均被筛选一次，将时间复杂度降到最低，这也就是Euler筛的算法思想，实现代码如下所示。 void init() { phi[1] = 1; for (int i = 2; i &lt; MAXN; ++i) { if (!vis[i]) { phi[i] = i - 1; pri[cnt++] = i; } for (int j = 0; j &lt; cnt; ++j) { if (1ll * i * pri[j] &gt;= MAXN) break; vis[i * pri[j]] = 1; if (i % pri[j]) { phi[i * pri[j]] = phi[i] * (pri[j] - 1); } else { // i % pri[j] == 0 // 换言之，i 之前被 pri[j] 筛过了 // 由于 pri 里面质数是从小到大的，所以 i 乘上其他的质数的结果一定会被 // pri[j] 的倍数筛掉，就不需要在这里先筛一次，所以这里直接 break // 掉就好了 phi[i * pri[j]] = phi[i] * pri[j]; break; } } } } 关键之处在：if(i%prime[j]==0) break; 这句代码保证了每个数最多被筛一次，将时间复杂度降到了线性。 证：prime[]数组中的素数是递增的,当i能整除prime[j]，那么iprime[j+1]这个合数肯定会被prime[j]乘以某个数筛掉。因此，这里直接break掉，将iprime[j+1]及之后的给后面的数去筛。这种方法能保证每个数只被筛一遍，又能保证每个数都被筛到。 为了更好的理解，画出前面几次筛的情况: 一般来说，当筛选范围n较小时，埃氏筛和欧氏筛复杂度较相近，甚至埃氏筛表现更好，但随着n的增大，欧氏筛的优越性也逐渐体现出来，可以达到埃氏筛3-4倍的速度。 参考： 1.线性筛的理解及应用 - Rogn - 博客园 (cnblogs.com) 2.线性筛_历尽千帆-CSDN博客_线性筛","categories":[{"name":"算法","slug":"算法","permalink":"http://sn1987a-1.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"practice","slug":"算法/practice","permalink":"http://sn1987a-1.github.io/categories/%E7%AE%97%E6%B3%95/practice/"}],"tags":[{"name":"线性筛","slug":"线性筛","permalink":"http://sn1987a-1.github.io/tags/%E7%BA%BF%E6%80%A7%E7%AD%9B/"},{"name":"算法","slug":"算法","permalink":"http://sn1987a-1.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"firsttry","slug":"firsttry","date":"2021-10-23T11:46:29.000Z","updated":"2022-01-27T13:30:38.046Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"http://sn1987a-1.github.io/posts/undefined.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"hexo个人博客搭建教程","slug":"something","date":"2021-10-20T13:40:51.000Z","updated":"2022-01-27T13:30:38.046Z","comments":true,"path":"posts/15548.html","link":"","permalink":"http://sn1987a-1.github.io/posts/15548.html","excerpt":"","text":"hexo博客搭建教程利用github生成自己的个人博客","categories":[{"name":"教程","slug":"教程","permalink":"http://sn1987a-1.github.io/categories/%E6%95%99%E7%A8%8B/"},{"name":"hexo","slug":"教程/hexo","permalink":"http://sn1987a-1.github.io/categories/%E6%95%99%E7%A8%8B/hexo/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://sn1987a-1.github.io/tags/blog/"},{"name":"hexo","slug":"hexo","permalink":"http://sn1987a-1.github.io/tags/hexo/"}]},{"title":"something","slug":"index","date":"2021-06-27T12:00:00.000Z","updated":"2022-01-27T13:30:38.046Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"http://sn1987a-1.github.io/posts/undefined.html","excerpt":"","text":"Welcome to GitHub PagesYou can use the editor on GitHub to maintain and preview the content for your website in Markdown files. Whenever you commit to this repository, GitHub Pages will run Jekyll to rebuild the pages in your site, from the content in your Markdown files. MarkdownMarkdown is a lightweight and easy-to-use syntax for styling your writing. It includes conventions for Syntax highlighted code block # Header 1 ## Header 2 ### Header 3 - Bulleted - List 1. Numbered 2. List **Bold** and _Italic_ and `Code` text [Link](url) and ![Image](src) For more details see GitHub Flavored Markdown. Jekyll ThemesYour Pages site will use the layout and styles from the Jekyll theme you have selected in your repository settings. The name of this theme is saved in the Jekyll _config.yml configuration file. Support or ContactHaving trouble with Pages? Check out our documentation or contact support and we’ll help you sort it out.","categories":[],"tags":[]}],"categories":[{"name":"WSL2","slug":"WSL2","permalink":"http://sn1987a-1.github.io/categories/WSL2/"},{"name":"数据结构","slug":"数据结构","permalink":"http://sn1987a-1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"数字电路","slug":"数字电路","permalink":"http://sn1987a-1.github.io/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"},{"name":"算法","slug":"算法","permalink":"http://sn1987a-1.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"practice","slug":"算法/practice","permalink":"http://sn1987a-1.github.io/categories/%E7%AE%97%E6%B3%95/practice/"},{"name":"教程","slug":"教程","permalink":"http://sn1987a-1.github.io/categories/%E6%95%99%E7%A8%8B/"},{"name":"hexo","slug":"教程/hexo","permalink":"http://sn1987a-1.github.io/categories/%E6%95%99%E7%A8%8B/hexo/"}],"tags":[{"name":"美化","slug":"美化","permalink":"http://sn1987a-1.github.io/tags/%E7%BE%8E%E5%8C%96/"},{"name":"Unix","slug":"Unix","permalink":"http://sn1987a-1.github.io/tags/Unix/"},{"name":"专业课","slug":"专业课","permalink":"http://sn1987a-1.github.io/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"},{"name":"数据结构","slug":"数据结构","permalink":"http://sn1987a-1.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模拟与数字电路","slug":"模拟与数字电路","permalink":"http://sn1987a-1.github.io/tags/%E6%A8%A1%E6%8B%9F%E4%B8%8E%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"},{"name":"线性筛","slug":"线性筛","permalink":"http://sn1987a-1.github.io/tags/%E7%BA%BF%E6%80%A7%E7%AD%9B/"},{"name":"算法","slug":"算法","permalink":"http://sn1987a-1.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"blog","slug":"blog","permalink":"http://sn1987a-1.github.io/tags/blog/"},{"name":"hexo","slug":"hexo","permalink":"http://sn1987a-1.github.io/tags/hexo/"}]}