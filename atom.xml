<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SN1987A</title>
  
  <subtitle>LAYのBLOG</subtitle>
  <link href="http://sn1987a-1.github.io/atom.xml" rel="self"/>
  
  <link href="http://sn1987a-1.github.io/"/>
  <updated>2022-03-07T07:31:27.515Z</updated>
  <id>http://sn1987a-1.github.io/</id>
  
  <author>
    <name>SN1987A</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Knowledge Framework of OS PART II CH3</title>
    <link href="http://sn1987a-1.github.io/posts/22413.html"/>
    <id>http://sn1987a-1.github.io/posts/22413.html</id>
    <published>2022-03-07T07:35:11.000Z</published>
    <updated>2022-03-07T07:31:27.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Part-II-Process-Concept-amp-Operations"><a href="#Part-II-Process-Concept-amp-Operations" class="headerlink" title="Part II : Process Concept &amp; Operations"></a>Part II : Process Concept &amp; Operations</h1><h2 id="Concepts-of-Process"><a href="#Concepts-of-Process" class="headerlink" title="Concepts of Process"></a>Concepts of Process</h2><p><strong> the building of processing </strong></p><ul><li>Pre-processor:like #define,#include —-try “gcc -E hello.c”</li><li>Compiler and Optimizer<ul><li>compiler:Syntax checking and analyzing</li><li>if no syntax:construct the intermediate codes</li><li>i.e,assembly</li><li>Optimizer :optimize the codes</li><li>check the parameter of gcc</li></ul></li><li>Assembler and Linker<ul><li>assembler assembles hello.s and generate hello.o</li><li>the linker puts together the objects files as well as library files</li></ul></li></ul><p>compile multiple files?</p><p>makefile</p><h2 id="What-is-a-process"><a href="#What-is-a-process" class="headerlink" title="What is a process"></a>What is a process</h2><h3 id="process-in-memory"><a href="#process-in-memory" class="headerlink" title="process in memory"></a>process in memory</h3><p>a program is a program in execution</p><ul><li>a executable file load into mermory</li><li>is Active</li><li><p>process in memory :</p><ul><li>text section:program code</li><li>stack</li><li>heap</li><li>data section</li><li>program counter </li><li>content of register</li></ul></li><li><p>process state</p><ul><li>a process executes changes states:</li><li>new</li><li>runnig</li><li>waiting :for I/O</li><li>ready—need CPU resources</li><li>terminated</li></ul></li></ul><p>the state diagram and the switch between</p><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid">graph LRA[new]--admitted--&gt;B[ready]C[wait]--I/O or event completion--&gt;BD[running]--interrupt--&gt;BD--I/O or event wait --&gt;CB--scheduler dispatch--&gt;DD--exit--&gt;E[terminated]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="PCB—process-structure"><a href="#PCB—process-structure" class="headerlink" title="PCB—process structure"></a>PCB—process structure</h3><p><strong>How to locate /represent a process</strong></p><ul><li>PCB:process control block or task control block<ul><li>program state</li><li>program counter</li><li>CPU registers</li><li>CPU scheduling information</li><li>memory-management information</li><li>I/O status information</li><li>Accouting information<br>process data structure in Linux</li><li>represents by struct <em>task_struct</em> in C</li><li><linux sched.h=""></linux></li></ul></li></ul><p>the relationship between program data&amp; PCB</p><p>Conclusion on “what is a process”</p><ol><li>a program in execution</li><li>only one process can be running on any processor at any instant</li><li>two processes maybe associated with one program</li><li>a process can be an execution environment for other codes.</li></ol><h2 id="Process-Operations"><a href="#Process-Operations" class="headerlink" title="Process Operations"></a>Process Operations</h2><p>process:all the files,memory,accouting information</p><p>a system must provide the mechanism for:process identification,process creation,process execution,process termination</p><p>some basic system calls:</p><p>getpid(),fork(),exec*(),wait(),exit()</p><ul><li>Process identification<ul><li>each process was given a unique id:process ID,<strong>PID</strong></li><li>use <code>getpid()</code></li><li><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <unistd.h></unistd.h></h1></li><li>‘.’:当前目录</li><li>use getpid()to check a program several times:get different PID</li></ul></li><li>Process creation <ul><li>a process may create several new processes<ul><li>parent process and chidren process </li></ul></li><li>the first process(the kernel runs when booting up)—-<code>init</code><ul><li>PID=1,is running the program code “/sbin/init”</li><li>the first task is to create more processes</li></ul></li><li>tree hierarchy<ul><li>all the process form a tree hierarchy</li><li>program blossoming:command to view tree:</li><li>“pstree” or “pstree -A”—-for ascii-character-only on display</li><li>the termination can be happen at any time:the parent terminate before the children:turn a tree hierarchy to a forest(a process become a orphan)</li><li><strong>orphan process</strong> may make a difference…become a tree ,and when it terminate nobody will know?</li><li>solve orphan process:re-parent operation</li><li>the relationship between parent and children<ul><li>resource sharing options:all/subset/no</li><li>execution options:execute concurrently/parent wait for children</li><li>address space options:a duplicate of parent/a new program loaded into it</li></ul></li></ul></li><li>to create :system call <code>fork()</code><ul><li><code>printf(...getpid()..);fork;print(...getpid());</code>:you will get three processz(like 1234,1234,1235)</li><li>the last print executed twice</li><li>the fork():the parent and children executes the same codes,but not the same start:<strong>the children starts where the fork()is returned</strong><br>-</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Part-II-Process-Concept-amp-Operations&quot;&gt;&lt;a href=&quot;#Part-II-Process-Concept-amp-Operations&quot; class=&quot;headerlink&quot; title=&quot;Part II : Proces</summary>
      
    
    
    
    <category term="OS" scheme="http://sn1987a-1.github.io/categories/OS/"/>
    
    
    <category term="专业课" scheme="http://sn1987a-1.github.io/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    <category term="OS" scheme="http://sn1987a-1.github.io/tags/OS/"/>
    
    <category term="note" scheme="http://sn1987a-1.github.io/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>Knowledge Framework of OS PART I CH1&amp;CH2</title>
    <link href="http://sn1987a-1.github.io/posts/28913.html"/>
    <id>http://sn1987a-1.github.io/posts/28913.html</id>
    <published>2022-02-28T14:52:11.000Z</published>
    <updated>2022-03-07T07:31:38.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Knowledge-Framework-of-OS-PART-I-CH1-amp-CH2"><a href="#Knowledge-Framework-of-OS-PART-I-CH1-amp-CH2" class="headerlink" title="Knowledge Framework of OS :PART I CH1&amp;CH2"></a>Knowledge Framework of OS :PART I CH1&amp;CH2</h1><p>textbook: Operating System Concepts 10th Edition <a href="https://www.os-book.com/OS10/index.html">check</a></p><p>course home : <a href="http://staff.ustc.edu.cn/~ykli/os2022">http://staff.ustc.edu.cn/~ykli/os2022</a></p><h2 id="ch1-Overview-of-an-Operating-System"><a href="#ch1-Overview-of-an-Operating-System" class="headerlink" title="ch1 Overview of an Operating System"></a>ch1 Overview of an Operating System</h2><h3 id="system-organization"><a href="#system-organization" class="headerlink" title="system organization"></a>system organization</h3><p>computer-system organization</p><ul><li>One or more CPUs, device controllers connect through common bus providing access to shared memory </li><li>Concurrent execution of CPUs and devices competing for memory cycles</li><li><strong>I/O devices and the CPU</strong> can execute <strong>concurrently</strong></li><li>Each device controller is in charge of a particular device type</li><li>Each device controller has a local buffer </li><li>CPU moves data from/to main memory to/from local buffers </li><li>Device controller informs CPU that it has finished its operation by causing an <strong>interrupt</strong></li></ul><p>computer start-up</p><ol><li><strong>bootstrap program</strong> (启动程序)is loaded at power-up or reboot (firmware)</li><li>System processes or system daemons</li><li>After fully booted, waits for events to occur – Signaled by interrupt</li></ol><p><strong>interrupt handling</strong>  :can be triggered by hardware and software:</p><ol><li>Hardware sends signal to CPU </li><li>Software executes a special operation:<strong>system call</strong></li><li>procedure :CPU stop-&gt;executes the service routine-&gt;CPU resumes</li><li>operating system is interrupt driven</li><li>interrupt architecture must save the address of the interrupted instruction</li><li>interrupt timeline:</li></ol><p><img src="https://user-images.githubusercontent.com/74918703/155979009-4974c76f-6119-408f-a6e8-86ceb7b4b9d5.png" alt="image" style="zoom:80%;"></p><p>Interrupt transfers control to the interrupt service routine . A table of pointers to interrupt routines, the <strong>interrupt vector</strong>,can be used to provide necessary speed .The table of pointers is stored in low memory.</p><h3 id="Storage-Structure"><a href="#Storage-Structure" class="headerlink" title="Storage Structure"></a>Storage Structure</h3><p><img src="https://user-images.githubusercontent.com/74918703/155979598-8e6b2eb2-38a1-4280-b98c-bfbb41561456.png" alt="image" style="zoom: 80%;"></p><ul><li>Main memory :random access,typically small size and volatile(易失性)</li><li>Instruction-execution cycle 1.Fetch an instruction from memory and store in register – Decode instruction (fetch operands if necessary) 2. Store result back to memory</li><li>Secondary storage – extension of main memory that provides large nonvolatile storage capacity (like heard disks ,solid-state disks—faster and nonvolatile)</li><li>caching—small ,important principle,in hardware ,opearting system,software.</li><li>I/O structure:interrupt driven</li><li>Direct Memory Access Structure:Device controller transfers blocks of data from buffer storage directly to main memory without CPU intervention,one interrupt per block</li></ul><h3 id="System-Architecture-处理器"><a href="#System-Architecture-处理器" class="headerlink" title="System Architecture(处理器)"></a>System Architecture(处理器)</h3><p>CPU—most use a single general-purpose processor</p><p><strong>Multiprocessors system</strong>:parallel systems,multicore systems,</p><p>advances:Increased throughput;Economy of scale;Increased reliability</p><p>two types:</p><p><strong>SMP</strong>:symmetric multiprocessing,all processors are peers</p><p><img src="https://user-images.githubusercontent.com/74918703/155982308-fe37e15e-cef6-4597-9f3d-8591f500f1b8.png" alt="image" style="zoom:67%;"></p><p><strong>AM</strong>:asymmetric multiprocessing,boss-worker relationship</p><p>Multicore:: include multiple cores on a single chip .More efficient and less power</p><p><img src="https://user-images.githubusercontent.com/74918703/155982347-15bd8cd7-500d-483f-95c5-3d0ef6cfc6d1.png" alt="image" style="zoom:67%;"></p><p>distinguish:multicore &amp;SMP,multicore is more efficient but costs more.</p><p><strong>Clustered Systems</strong>:multiple systems working together</p><p>​        -<strong>SAN</strong>:storage-area network</p><p>​        -some are <strong>HPC</strong>:high-performance computing</p><p>​        -<strong>DLM</strong>:distributed lock manager,to avoid conflicting</p><p>So…</p><p>Where is the OS?</p><blockquote><p>Four components of a computer system </p><p>– Hardware – provides basic computing resources (CPU, memory, I/O devices) </p><p>– Users: People, machines, other computers</p><p> – App. programs – define the ways in which the sys. resources are used to solve the computing problems</p><p>​             • Word processors, compilers, web browsers, database systems, video games, etc.</p><p> – Operating system </p><p>​            • Controls and coordinates use of hardware among various applications and users</p></blockquote><p>What is the OS?</p><blockquote><p>•It stands between the hardware and the user. </p><p>– A program that acts as an intermediary between a user of a computer and the computer hardware </p><p>• Operating system goals: </p><p>– Execute user programs &amp; make solving user problems easier </p><p>– Make the computer system convenient to use</p><p> – Use the computer hardware in an efficient manner </p><p>– Design tradeoff between convenient and efficiency</p><p>• How good is this design? </p><p>– The user does not have to program the hardware directly</p><p>• Processes as the starting point! </p><p>– Whatever programs you run, you create processes. </p><p>​        • i.e., you need processes to open files, utilize system memory, listen to music, etc.</p><p> – So, process lifecycle, process management, and other related issues are essential topics of this course</p></blockquote><p>What Operating Systems Do?</p><ul><li>system view<ul><li>control program</li><li>resource alocator</li></ul></li><li>User view<ul><li>wanr convenience in use and performance</li><li>usability ,battery life, resource utilization,tradeoff…</li></ul></li></ul><p>well..OS has no universalyy accepted defination</p><h3 id="Operating-Systems-Operations"><a href="#Operating-Systems-Operations" class="headerlink" title="Operating Systems Operations"></a>Operating Systems Operations</h3><h4 id="OS-Operations"><a href="#OS-Operations" class="headerlink" title="OS Operations"></a>OS Operations</h4><p>control programs/resource allocator</p><ol><li><strong>Mutliprogramming</strong>:needed for efficiency,job run via job scheduling<ol><li>Time sharing,分时操作系统,logical extension in which CPU switches jobs so frequently that users can interact with each job while it is running, creating interactive computing</li><li>allow many user to share the computer</li><li>issues:– If several jobs ready to run at the same time:<strong>CPU scheduling</strong> . If processes don’t fit in memory, <strong>swapping</strong> moves them in and out to run . <strong>Virtual memory</strong> allows execution of processes not completely in memory</li></ol></li><li><strong>Interrupt Driven Mechanism</strong><ol><li>(in  Multiprogramming)software and hardware</li><li>Hardware interrupt by one of the devices</li><li>software :(exception or trap),needed to request for opaerating system service</li></ol></li><li><strong>Dual-mode Operation</strong>多模式操作<ol><li>user mode or kernel mode,and transistion between them</li></ol></li></ol><h4 id="system-call"><a href="#system-call" class="headerlink" title="system call"></a>system call</h4><p>system call is similar to a function call ,but it is inside the OS,named OS kernel</p><ul><li><p>System calls are the <strong>programming interface</strong> between processes and the OS kernel </p><ul><li>System calls provide the means for a user program to ask the operating system to perform tasks </li></ul></li><li><p>A system call usually takes the form of a trap to a specific location in the interrupt vector, <strong>treated by the hardware as a software interrupt</strong></p></li><li><p>The system call service routine is a part of the OS</p></li><li><p>usually primitive,important,fundamental(like time()system call)</p></li><li><p>Roughly speaking, we can categorize system calls as follows:</p><p>| Process  | FileSystem | Memory |<br>| ———— | ————— | ——— |<br>| Security | Device     |        |</p></li></ul><ul><li>distinguish between system call and library function call(library file:in windows :DLL dynameically linked library ,in Linux SO,shared objects)</li></ul><p>OS standards:</p><p><img src="https://user-images.githubusercontent.com/74918703/155991891-c2f45cd5-3191-424d-bd2a-f45d71deec7d.png" alt="image" style="zoom:67%;"></p><h3 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h3><h4 id="Process-vs-Program"><a href="#Process-vs-Program" class="headerlink" title="Process vs Program"></a>Process vs Program</h4><p>A process is an execution instance of a program,a process is not bounded to execute just one program.A process is active and has its own local states</p><p>command about processes like ps—report a vast amount of information about every process in system(try ps -ef)</p><p>shell—-a process launching pad</p><p><img src="https://user-images.githubusercontent.com/74918703/155994339-75d5f4d4-7244-40c0-93a4-a7238a658cee.png" alt="image" style="zoom:67%;"></p><p>System has many processes, some user, some operating system running concurrently</p><h4 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h4><p><img src="https://user-images.githubusercontent.com/74918703/155995958-b6202a2b-d093-4966-b04f-ec3f022fe50e.png" style="zoom:67%;"></p><p>Java don’t have the above layout,and C is too low</p><h4 id="Storage-Management"><a href="#Storage-Management" class="headerlink" title="Storage Management"></a>Storage Management</h4><p><strong>File System,FS</strong></p><p>like FAT16, FAT32, NTFS, Ext3, Ext4, BtrFS</p><p>a FS must record :directories,files,allocated,space,free space</p><p>Two face of a file system:1.storage design of the file system.(how it stored)2.the opreations of the file systems</p><p>operations:creating can be replaced by opening;copying can be replaced by read and write;moving can be replaced by rename(in one disks),so the necessary operations are open,read,write,close,rename,delete,..</p><p>A FS is independent of an OS,an OS can use many FS</p><h4 id="Kernal-Data-Structures"><a href="#Kernal-Data-Structures" class="headerlink" title="Kernal Data Structures"></a>Kernal Data Structures</h4><p>Lists,Trees,Hash Map and Bitmaps</p><h3 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h3><p><strong>Protection and Security</strong></p><p>this course will discuss the security of File System</p><p><strong>Computing Environments </strong></p><ul><li><p>trandition to mobile:IOS ,Android</p></li><li><p>Distributed computing ,like networkTCP/IP</p></li><li><p>Client-Server(C-S computing)</p></li><li><p>Peer-to-Peer computing—去中心化</p></li><li><p>Virtualization</p></li><li><p>Cloud Computing (较成熟)</p></li><li><p>Real-Time Embedded Systems</p></li></ul><p><strong>Open-sourced OS</strong></p><p>Open-Source Operating Systems—-GNU LINUX,BSD UNIX(including mac OS)</p><h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><ul><li>OS Overview <ul><li>OS Concept </li><li>Multiprogramming &amp; Multitasking </li><li>Dual Mode &amp; System Call </li></ul></li><li>OS Components <ul><li>Process Management </li><li>Memory Management </li><li>Storage Management </li></ul></li><li>Computer System Organization &amp; Architecture <ul><li>Interrupt</li></ul></li></ul><h2 id="ch2-Operating-System-Structures"><a href="#ch2-Operating-System-Structures" class="headerlink" title="ch2 Operating System Structures"></a>ch2 Operating System Structures</h2><h3 id="Operating-System-Services"><a href="#Operating-System-Services" class="headerlink" title="Operating System Services"></a>Operating System Services</h3><p><img src="https://user-images.githubusercontent.com/74918703/156001574-10982645-91ca-4540-9d1f-de15ab2b1a22.png" alt="image" style="zoom:67%;"></p><p>common classes :Convenience of the user and Efficiency of the system</p><p><strong>Operating systems provide an environment for execution of programs and services to programs and users</strong></p><h4 id="User-Operating-System-Interface"><a href="#User-Operating-System-Interface" class="headerlink" title="User Operating System Interface"></a>User Operating System Interface</h4><p>execution:1.Load a program into memory 2.run the program3.end execution(normally or abnormally)</p><p>for Helping Users</p><ul><li>I/O operations</li><li>File-system manipulation</li><li>communications</li><li>implementations:(<strong>shared memory and Message passing</strong>)</li><li>error detection,error types error handling<br>for Ensuring Efficiency</li></ul><p>for ensuring efficiency</p><ul><li>resource allocation</li><li>accounting—to keep track of</li><li>usage (usage statistics)</li><li>the protection and security </li></ul><p>for Helping Users</p><ul><li>user interface(UI)<ul><li>form: CLI(command line),Batch,GUI(Graphics User Interface)</li><li>CLI:shells,two ways of implementing commands:</li><li>1.The command interpreter itself contains the code • Jump to a section of its code &amp; make appropriate system call • Number of commands determines the size of CLI </li><li>2.Implements commands through system program (UNIX) • CLI does not understand the command • Use the command to identify a file to be loaded into memory and executed • Exp: rm file.txt (search for file rm, load into memory and exe w/ file.txt) • Add new commands easily</li></ul></li></ul><p>touchsreen interface…virtual keyboard?voice command</p><h4 id="System-Calls"><a href="#System-Calls" class="headerlink" title="System Calls"></a>System Calls</h4><p><strong>Programming interface</strong> to the service provided by the OS</p><p>Each OS ha its own Program Call</p><p>System Call &amp;&amp; function</p><p>Why us API?</p><p>for System Call,a simple program like copy may make heavy use of OS,and not user friendly</p><p>Mostly accessed by programs via a high-level API rather than direct system call use,and is easy of use(Simple programs may make heavy use of the OS)Program portability(Compile and run on any system that supports the same API )</p><p>remember the logic relationship between API and Program calls</p><p>API:application programming interface</p><p>common APIs:Win32 API for Windows,POSIX API,JAVA API(JAM,java virtual machine) </p><p>How to use API?</p><p>1.via a library of code provided by OS<br>2.Libc:UNIX/Linux with a C language</p><p>API-System Call-OS relationship</p><p><strong>Type of System Call</strong></p><ul><li>Process COntrol<ul><li>example: MS_DOS </li></ul></li><li>File Manipulation</li><li>Device Manipulation</li><li>Information Maintenance</li><li>Communications</li><li>Protection</li></ul><h3 id="Operating-System-Structure"><a href="#Operating-System-Structure" class="headerlink" title="Operating System Structure"></a>Operating System Structure</h3><p>掌握优势和问题，不需要记住例子</p><ul><li>simple structure :MS_DOS</li><li>Monolothic Structure :UNIX</li></ul><p>limited structing beyond simple but not fully layered</p><ul><li>Layered Approach</li></ul><p>not efficient</p><ul><li>Microkernel System Structure</li><li>Modules</li><li>Hybrid System:combine different systems structure</li></ul><p>Examples:Linux,Windows,Mac OS X structure,IOS,Android…</p><h3 id="OPerating-System-Design-and-Implementation"><a href="#OPerating-System-Design-and-Implementation" class="headerlink" title="OPerating System Design and Implementation"></a>OPerating System Design and Implementation</h3><p>… is not solvable</p><ol><li>first problem :design goals and specifications</li><li><p>improtant principle to separate(<strong>Mechanism</strong> for how to do  and <strong>policy</strong> for what will be done）<br>Examples (<strong>Timer Mechanism</strong> for CPU protection and <strong>Priority Mechanism</strong> in job scheduling)</p><p>benefits:maximum flexbility</p></li></ol><p>OS implementation</p><ul><li>much variation,earily in ass,now in C/C++</li><li>Acutually use a mix of language(body in C,lower levels in ass,system programs in C/C++,scripting language)</li><li>pros and cons </li></ul><h3 id="MISC-Debugging-Generation-amp-System-Boot"><a href="#MISC-Debugging-Generation-amp-System-Boot" class="headerlink" title="MISC:Debugging,Generation &amp;System Boot"></a>MISC:Debugging,Generation &amp;System Boot</h3><p><strong>debugging</strong> like GDB</p><ul><li>failure analysis</li><li>performance tuning</li><li>Kernighan’s LAW</li></ul><p><strong>Operation system Generation</strong>—-OS is designed to run on any of a class of machines</p><p>the system must be configured or generate for each specific computer site</p><p>  <strong>SYSGEN</strong>program</p><p><strong>system boot</strong></p><ul><li>?</li><li>?</li></ul><p>Summary of part I :ch1&amp;ch2</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Knowledge-Framework-of-OS-PART-I-CH1-amp-CH2&quot;&gt;&lt;a href=&quot;#Knowledge-Framework-of-OS-PART-I-CH1-amp-CH2&quot; class=&quot;headerlink&quot; title=&quot;Know</summary>
      
    
    
    
    <category term="OS" scheme="http://sn1987a-1.github.io/categories/OS/"/>
    
    
    <category term="专业课" scheme="http://sn1987a-1.github.io/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    <category term="OS" scheme="http://sn1987a-1.github.io/tags/OS/"/>
    
    <category term="note" scheme="http://sn1987a-1.github.io/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>以git-ftp为主的学习记录</title>
    <link href="http://sn1987a-1.github.io/posts/15203.html"/>
    <id>http://sn1987a-1.github.io/posts/15203.html</id>
    <published>2022-02-27T07:46:11.000Z</published>
    <updated>2022-03-01T07:40:06.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="以git-ftp为主的学习记录"><a href="#以git-ftp为主的学习记录" class="headerlink" title="以git-ftp为主的学习记录"></a>以git-ftp为主的学习记录</h1><blockquote><p>原本的目的是美化个人FTP主页（之前都是用FileZilla进行课程pdf文件等的传输，看到同学的个人主页后突然意识到也可以利用hexo完成相关功能，虽说没什么用，但也记录一下学习的过程。</p><p>……遇到了好多问题&gt; _ &lt;尚未完成</p><p>操作环境：win11 wsl2+Ubuntu 20.04 LTS,USTC ftp（默认首页为public_html下的index.html文件</p></blockquote><h2 id="git-ftp关联"><a href="#git-ftp关联" class="headerlink" title="git-ftp关联"></a>git-ftp关联</h2><p>优点：便于管理ftp</p><p>在github中创建名为<code>git-ftp</code>的repo后，使用<code>git clone</code>操作克隆到本地（或者可以在本地进行<code>git init</code>操作，创建.git文件，使用<code>git remote</code>操作与远程链接；</p><p>因为2021年8月13起github不允许在git操作时进行登录确认，因此要提前配置好：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git config --global user.name YOURNAMEgit config --global user.email YOUREMAIL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>要使用git-ftp的功能，需要先安装git-ftp：（确保git已经安装）<code>sudo apt-get install git-ftp</code></p><p>此外，要进行ftp的config操作：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git config git-ftp.url ftp-urlgit config git-ftp.user ftp-usergit config git-ftp.password pswd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>若想对以上内容进行查看，可以在本仓库<code>.git</code>目录进行查看和修改</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">[</span>core<span class="token punctuation">]</span>        repositoryformatversion = 0        filemode = true        bare = false        logallrefupdates = true<span class="token punctuation">[</span>git<span class="token punctuation">-</span>ftp<span class="token punctuation">]</span>        password = pswd        user = name        url = ftp<span class="token punctuation">-</span>url<span class="token punctuation">[</span>remote "origin"<span class="token punctuation">]</span>       <span class="token comment">#后序添加完可以查看url和fetch内容</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于git-ftp的相关操作，可以阅读 <a href="https://github.com/git-ftp/git-ftp/blob/master/man/git-ftp.1.md">官方文档</a> 。</p><p>之后可以对该目录进行初始化:<code>git ftp init</code>,或者对已存在的文件进行<code>git catchup</code>操作。</p><p>之后常用的操作就是<code>git ftp push</code>.顺便提一句，可能会遇到“Dirty repository :Having uncommited changes.Exiting…”的问题，就要先进行<code>git add .</code>,<code>git commit ..</code>,<code>git push</code>的操作。</p><p>此时仍无法进行<code>git ftp push</code>的操作，因为这一操作需要安装lftp：<code>sudo apt-get install lftp</code>,安装后即可使用。</p><h2 id="hexo搭建"><a href="#hexo搭建" class="headerlink" title="hexo搭建"></a>hexo搭建</h2><p>为了防止hexo操作将其他文件一并删除，此处可以新建一个文件夹存储hexo框架：<code>hexo init page</code>,打开目录底下的_config.yml进行修改，并且将deploy进行修改：(对生成的public_dir文件的位置大概也需要改)</p><p>PS:对于_config.yml的内容修改，可以不需要重新进行<code>hexo g</code></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span> <span class="token key atrule">type</span><span class="token punctuation">:</span> ftpsync <span class="token key atrule">host</span><span class="token punctuation">:</span> <span class="token comment"># ftp服务器地址</span> <span class="token key atrule">user</span><span class="token punctuation">:</span> <span class="token comment"># ftp用户名</span> <span class="token key atrule">pass</span><span class="token punctuation">:</span>  <span class="token comment"># 你的ftp用户密码</span> <span class="token key atrule">remote</span><span class="token punctuation">:</span>  <span class="token comment"># 你要上传到的地址，例如/wwwroot</span> <span class="token key atrule">port</span><span class="token punctuation">:</span>  <span class="token comment"># ftp端口，不同的ftp可能会不一样</span> <span class="token key atrule">delete</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment"># 上传本地文件是否删除ftp中的所有文件</span> <span class="token key atrule">verbose</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment"># 是否打印调试信息</span> <span class="token key atrule">ignore_errors</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 是否忽略错误</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大部分的操作为hexo的常规操作，但与利用域名搭建的hexo博客不同，这里需要安装插件：</p><p><code>npm install hexo-deployer-ftpsync –save</code></p><p>这里还有一个问题，<code>hexo d</code>后，我的原本存在public_html底下的文件被删除？</p><p>如果使用git clone安装了新主题，如此次安装了”Archer”主题，若hexo版本在4.0.0以上，需要将/themes/Archer目录下的_config.yml重命名为 _config.archer.yml，并移动到根目录，同时，因为使用的是<code>git clone</code>操作， 会将原repo的.git文件clone到本地，默认为与原repo关联，这个repo我们是没有权限进行修改的，相对于两个git项目进行了嵌套，外层无法update内部的repo，这时在根目录下进行<code>git add .</code>或者<code>git add all</code>操作均是无法将Archer文件的内容进行push的，也就无法进行<code>git ftp push</code>操作，解决方法就是利用<code>git remote remove</code>操作取消内部的git关联。 </p><h2 id="遇到的琐事"><a href="#遇到的琐事" class="headerlink" title="遇到的琐事"></a>遇到的琐事</h2><p>使用hexo操作时 ，发生对于Yaml的报错提示，从StackOverflow得知需要更新npm版本，遂进行更新，使用<code>npm install -g npm</code>时，又发生报错，大致意思为可以检测到新版本但是当前的node.js不兼容新版本，无法完成更新，而且此项更新未完成时，可能会对于npm安装其他的插件有影响。</p><p>google了半天，终于搞清楚了：</p><p>我在一开始安装npm时未安装nvm，二者的关系是：npm时node.js的包管理工具，nvm是node.js的版本管理工具，二者均是node.js应用程序开发的工具，因此要更新Node.js到最近版本，需要先安装nvm，<code>$ wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | sh</code>,其中sh可以替换成shell的具体名称，如我的就是zsh，默认为bash，安装完之后可以在~/.nvm看到该文件夹，不知道为什么，我的执行上述操作后无反应，重新启动了wsl才正常进行，完成后，在对应的配置文件( ~ /.bashrc或者~/.zshrc)中添加：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">export NVM_DIR="$([ -z "${XDG_CONFIG_HOME-}" ] &amp;&amp; printf %s "${HOME}/.nvm" || printf %s "${XDG_CONFIG_HOME}/nvm")"[ -s "$NVM_DIR/nvm.sh" ] &amp;&amp; \. "$NVM_DIR/nvm.sh" # This loads nvm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>完成后保存退出，<code>source ~/.zshrc</code>，即可使用nvm命令</p><p><code>nvm install</code>可以指定安装Node.js 的版本 ，可以选比较近的稳定版本17.0.0，安装完后<code>nvm ls</code>查看已安装版本：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">❯ nvm ls-&gt;      v17.0.0         systemdefault -&gt; v17.0.0iojs -&gt; N/A (default)unstable -&gt; N/A (default)node -&gt; stable (-&gt; v17.0.0) (default)stable -&gt; 17.0 (-&gt; v17.0.0) (default)lts/* -&gt; lts/gallium (-&gt; N/A)lts/argon -&gt; v4.9.1 (-&gt; N/A)lts/boron -&gt; v6.17.1 (-&gt; N/A)lts/carbon -&gt; v8.17.0 (-&gt; N/A)lts/dubnium -&gt; v10.24.1 (-&gt; N/A)lts/erbium -&gt; v12.22.10 (-&gt; N/A)lts/fermium -&gt; v14.19.0 (-&gt; N/A)lts/gallium -&gt; v16.14.0 (-&gt; N/A)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后就可以对npm进行更新了。<code>npm -v</code>可以查看现有的版本，问题解决了</p><p>这里还有一个问题，就是nvm安装的版本居然也不是全局版本，在另外一个目录下进行<code>npm -v</code>或者<code>node -v</code>竟然也是原版本…</p><p>emmmm 后面暴躁到不想记录了呜呜呜 </p><h2 id="利用CSS对界面优化"><a href="#利用CSS对界面优化" class="headerlink" title="利用CSS对界面优化"></a>利用CSS对界面优化</h2><p>2022.3.1update:learn how CSS works</p><p>CSS相关资源：</p><p><a href="https://chokcoco.github.io/CSS-Inspiration/#/">https://chokcoco.github.io/CSS-Inspiration/#/</a></p><p><a href="https://cssreference.io/">https://cssreference.io/</a></p><p>这个网站整合了很多CSS工具：</p><p><a href="https://juejin.cn/post/6982363593241002014">https://juejin.cn/post/6982363593241002014</a></p><p>HTML CSS工具网站,可以copy已有模板（nice！）和实时观察到html,CSS,JS的呈现结果  <a href="https://codepen.io">https://codepen.io</a> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;以git-ftp为主的学习记录&quot;&gt;&lt;a href=&quot;#以git-ftp为主的学习记录&quot; class=&quot;headerlink&quot; title=&quot;以git-ftp为主的学习记录&quot;&gt;&lt;/a&gt;以git-ftp为主的学习记录&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;原本的目的</summary>
      
    
    
    
    <category term="git" scheme="http://sn1987a-1.github.io/categories/git/"/>
    
    
    <category term="wsl2" scheme="http://sn1987a-1.github.io/tags/wsl2/"/>
    
    <category term="git" scheme="http://sn1987a-1.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>WSL2美化</title>
    <link href="http://sn1987a-1.github.io/posts/15684.html"/>
    <id>http://sn1987a-1.github.io/posts/15684.html</id>
    <published>2022-01-21T14:12:20.000Z</published>
    <updated>2022-03-01T08:36:18.595Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><h1 id="WSL2美化"><a href="#WSL2美化" class="headerlink" title="WSL2美化"></a>WSL2美化</h1><p>本文简要记录基于Windows11对WSL的终端进行美化的主要步骤。</p><p>环境：Ubuntu 20.04，Windows Terminal(WT)</p><p>主要工具和插件：zsh，oh my zsh, povwerlevel10k(powerlevel9k也可以),autozsh-autosuggestions , zsh-syntax-highlig</p><p>下图是我的美化结果。</p><p><img src="https://user-images.githubusercontent.com/74918703/152648068-cc3de98c-40c3-401e-983b-a32860435f16.png" alt="image-20220122222259548"></p><h2 id="对Windows-terminal的外观进行美化"><a href="#对Windows-terminal的外观进行美化" class="headerlink" title="对Windows terminal的外观进行美化"></a>对Windows terminal的外观进行美化</h2><p>在微软应用商店搜索Windows terminal即可下载最新版本，如果不想用Windows Terminal，也可以下载另外一个跨平台终端——Tabby Terminal，<a href="[Tabby - a terminal for a more modern age](https://tabby.sh/">点击下载</a>)，配置方案也类似，但亲测效果不如WT。</p><h3 id="修改默认配置"><a href="#修改默认配置" class="headerlink" title="修改默认配置"></a>修改默认配置</h3><p>打开Windows Terminal，点击上方栏中“v”按钮，选择侧边栏中的“setting.json”文件并打开，后文中对WT的配置均对该文件进行修改（可以用VScode打开）。</p><p>例如，若要规定默认打开的界面是WSL2/WSL的界面，即可在actions一栏进行修改：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token string">"defaultProfile"</span><span class="token operator">:</span> <span class="token string">"{07b52e3e-de2c-5db4-bd2d-ba144ed6c273}"</span><span class="token punctuation">,</span><span class="token comment">//括号内对应的序列可在setting.json文件里查找到Ubuntu对应的GUID</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="修改配色方案"><a href="#修改配色方案" class="headerlink" title="修改配色方案"></a>修改配色方案</h3><p>在setting.json最后部分有schemes一栏，代表WT的配色方案，每个配色方案的name项即为名称，系统默认提供了一部分配色方案以及名称，但都不是很好看，将自定义配色添加到schemes底下即可新增配色方案，<a href="[Windows Terminal Themes](https://windowsterminalthemes.dev/">自定义配色网站</a>)提供了较多推荐的配色，可以直接复制。</p><p>以下为我选择的配色：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">{</span>      <span class="token string">"name"</span><span class="token operator">:</span> <span class="token string">"ChallengerDeep"</span><span class="token punctuation">,</span>      <span class="token string">"black"</span><span class="token operator">:</span> <span class="token string">"#141228"</span><span class="token punctuation">,</span>      <span class="token string">"red"</span><span class="token operator">:</span> <span class="token string">"#ff5458"</span><span class="token punctuation">,</span>      <span class="token string">"green"</span><span class="token operator">:</span> <span class="token string">"#62d196"</span><span class="token punctuation">,</span>      <span class="token string">"yellow"</span><span class="token operator">:</span> <span class="token string">"#ffb378"</span><span class="token punctuation">,</span>      <span class="token string">"blue"</span><span class="token operator">:</span> <span class="token string">"#65b2ff"</span><span class="token punctuation">,</span>      <span class="token string">"purple"</span><span class="token operator">:</span> <span class="token string">"#906cff"</span><span class="token punctuation">,</span>      <span class="token string">"cyan"</span><span class="token operator">:</span> <span class="token string">"#63f2f1"</span><span class="token punctuation">,</span>      <span class="token string">"white"</span><span class="token operator">:</span> <span class="token string">"#a6b3cc"</span><span class="token punctuation">,</span>      <span class="token string">"brightBlack"</span><span class="token operator">:</span> <span class="token string">"#565575"</span><span class="token punctuation">,</span>      <span class="token string">"brightRed"</span><span class="token operator">:</span> <span class="token string">"#ff8080"</span><span class="token punctuation">,</span>      <span class="token string">"brightGreen"</span><span class="token operator">:</span> <span class="token string">"#95ffa4"</span><span class="token punctuation">,</span>      <span class="token string">"brightYellow"</span><span class="token operator">:</span> <span class="token string">"#ffe9aa"</span><span class="token punctuation">,</span>      <span class="token string">"brightBlue"</span><span class="token operator">:</span> <span class="token string">"#91ddff"</span><span class="token punctuation">,</span>      <span class="token string">"brightPurple"</span><span class="token operator">:</span> <span class="token string">"#c991e1"</span><span class="token punctuation">,</span>      <span class="token string">"brightCyan"</span><span class="token operator">:</span> <span class="token string">"#aaffe4"</span><span class="token punctuation">,</span>      <span class="token string">"brightWhite"</span><span class="token operator">:</span> <span class="token string">"#cbe3e7"</span><span class="token punctuation">,</span>      <span class="token string">"background"</span><span class="token operator">:</span> <span class="token string">"#1e1c31"</span><span class="token punctuation">,</span>      <span class="token string">"foreground"</span><span class="token operator">:</span> <span class="token string">"#cbe1e7"</span><span class="token punctuation">,</span>      <span class="token string">"selectionBackground"</span><span class="token operator">:</span> <span class="token string">"#cbe1e7"</span><span class="token punctuation">,</span>      <span class="token string">"cursorColor"</span><span class="token operator">:</span> <span class="token string">"#fbfcfc"</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加完配色方案后，还应该对profiles部分进行修改，以便于使用最新配色方案。如果只需要对虚拟机部分添加如下文本，可以只修改name为“Ubuntu-xx.xx”的部分（当然其他部分也只是复制粘贴）。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token string">"colorScheme"</span><span class="token operator">:</span> <span class="token string">"ChallengerDeep"</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="修改字体"><a href="#修改字体" class="headerlink" title="修改字体"></a>修改字体</h3><p>Windows原装字体不支持很多符号的显示，这里推荐修改默认字体</p><p>比较简单的，可以在微软官方<a href="[Windows ターミナル Cascadia Code | Microsoft Docs](https://docs.microsoft.com/ja-jp/windows/terminal/cascadia-code">下载</a>)Cascadia Code PL字体，或者是下载文件后右键单击该字体对应的.otf/.ttf文件并选择安装。</p><p>当然有功能更加强大，应用更加广泛的字体Nerd Fond(Hack Nerd Fond)，包含了更多字符库，<a href="[ryanoasis/nerd-fonts: Iconic font aggregator, collection, &amp; patcher. 3,600+ icons, 50+ patched fonts: Hack, Source Code Pro, more. Glyph collections: Font Awesome, Material Design Icons, Octicons, &amp; more (github.com">点击下载</a>]( <a href="https://github.com/ryanoasis/nerd-fonts">https://github.com/ryanoasis/nerd-fonts</a> ))。</p><p>安装完成后，同样在profiles目录的Ubuntu-xx.xx里修改：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token string">"fontFace"</span><span class="token operator">:</span> <span class="token string">"Hack Nerd Fond"</span><span class="token string">"fontSize"</span><span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="设置背景和透明效果"><a href="#设置背景和透明效果" class="headerlink" title="设置背景和透明效果"></a>设置背景和透明效果</h3><p>均是在perfiles目录内</p><p>添加背景图：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token string">"backgroundImage"</span><span class="token operator">:</span> <span class="token string">"E:\\wallpaper\\wp3.jpg"</span><span class="token punctuation">,</span><span class="token comment">//背景的地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加透明效果（0~1，越小表示越透明）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token string">"acrylicOpacity"</span><span class="token operator">:</span> <span class="token number">0.8</span><span class="token punctuation">,</span><span class="token string">"useAcrylic"</span><span class="token operator">:</span> true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>指定启动时的默认路径：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token string">"startingDirectory"</span><span class="token operator">:</span> <span class="token string">"./"</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样Windows Terminal基本就配置好了。</p><h2 id="美化WSL2"><a href="#美化WSL2" class="headerlink" title="美化WSL2"></a>美化WSL2</h2><p>步骤：</p><ul><li>将原有的shell替换为zsh</li><li>安装oh my zsh</li><li>关键字高亮以及自动填充插件</li><li>安装powerlevel10k</li></ul><p>安装完自动填充以及高亮插件后对文件zshrc进行的主要添加为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">source <span class="token operator">/</span>usr<span class="token operator">/</span>share<span class="token operator">/</span>zsh<span class="token operator">-</span>autosuggestions<span class="token operator">/</span>zsh<span class="token operator">-</span>autosuggestions<span class="token punctuation">.</span>zshsource <span class="token operator">/</span>usr<span class="token operator">/</span>share<span class="token operator">/</span>zsh<span class="token operator">-</span>syntax<span class="token operator">-</span>highlighting<span class="token operator">/</span>zsh<span class="token operator">-</span>syntax<span class="token operator">-</span>highlighting<span class="token punctuation">.</span>zsh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里主要从安装powerlevel10k开始记录。</p><p>在命令行输入：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">sudo vim <span class="token operator">~</span><span class="token operator">/</span><span class="token punctuation">.</span>zshrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打开配置文件后，找到THEME一行，修改为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">ZSH_THEME<span class="token operator">=</span><span class="token string">"powerlevel10k/powerlevel10k"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后重启或输入命令</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">p10k configure<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后填写弹出的问卷即可自定义并保存当前配置文件。如果需要使用其他路径的文件，可以使用source命令进行导入。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot; &quot;&gt;&lt;/a&gt; &lt;/h1&gt;&lt;h1 id=&quot;WSL2美化&quot;&gt;&lt;a href=&quot;#WSL2美化&quot; class=&quot;headerlink&quot; title=&quot;WSL2美化&quot;&gt;&lt;/a&gt;WSL2美化&lt;</summary>
      
    
    
    
    <category term="WSL2" scheme="http://sn1987a-1.github.io/categories/WSL2/"/>
    
    
    <category term="美化" scheme="http://sn1987a-1.github.io/tags/%E7%BE%8E%E5%8C%96/"/>
    
    <category term="Unix" scheme="http://sn1987a-1.github.io/tags/Unix/"/>
    
  </entry>
  
  <entry>
    <title>2021数据结构复习</title>
    <link href="http://sn1987a-1.github.io/posts/131000.html"/>
    <id>http://sn1987a-1.github.io/posts/131000.html</id>
    <published>2022-01-11T12:12:20.000Z</published>
    <updated>2022-03-01T08:36:45.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2021数据结构复习"><a href="#2021数据结构复习" class="headerlink" title="2021数据结构复习"></a>2021数据结构复习</h1><hr><h2 id="考试范围"><a href="#考试范围" class="headerlink" title="考试范围"></a>考试范围</h2><p>数据结构 算法时间复杂度空间复杂度分析</p><ol><li>线性表<ol><li>顺序表示</li><li>链式表示<ol><li>线性链表</li><li>循环链表</li><li>双向链表</li></ol></li><li>一元多项式（实验内容）</li></ol></li><li>栈<ol><li>数值转换，括号匹配，行编辑程序，迷宫求解，表达式求值</li></ol></li><li>队列<ol><li>定义</li><li>链队列</li><li>循环队列</li></ol></li><li>串<ol><li>定长顺序存储</li><li>堆分配存储</li><li>串的块链存储</li></ol></li><li>数组<ol><li>顺序表示</li><li>特殊存储：特殊矩阵，稀疏矩阵</li></ol></li><li>广义表<ol><li>定义和存储结构</li><li>*广义表的递归算法<ol><li>求广义表深度</li><li>复制广义表</li><li>建立广义表的存储结构</li></ol></li></ol></li><li><strong>树和二叉树</strong><ol><li>二叉树<ol><li>定义，性质，存储结构</li><li>遍历二叉树</li><li>线索二叉树</li></ol></li><li>树和森林<ol><li>树的存储结构</li><li>树和二叉树之间的转换</li><li>树和森林的遍历</li></ol></li><li>Huffman树相关问题</li></ol></li><li><strong>图</strong><ol><li>定义和术语</li><li>存储结构<ol><li>数组表示法</li><li>邻接表</li><li>十字链表</li><li>邻接多重表</li></ol></li><li>图的遍历<ol><li>DFS</li><li>BFS</li></ol></li><li>图的连通性问题<ol><li>无向图连通分量和生成树</li><li>最小生成树</li></ol></li><li>最短路径问题<ol><li>从某一点到其他各个顶点的最短距离</li><li>每一对顶点之间的最短路径</li></ol></li></ol></li><li><p>查找</p><ol><li>静态查找表<ol><li>顺序表查找</li><li>有序表查找</li><li>索引顺序表查找</li></ol></li><li><strong>动态查找</strong><ol><li>二叉排序树和 *平衡二叉树</li><li>B-树和B+树</li></ol></li><li>哈希表<ol><li>构造方法</li><li>处理冲突</li><li>查找</li></ol></li></ol><p>`#define INFEASIBLE -1</p><p>`#define OVERFLOW -2</p></li></ol><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>逻辑上相邻，物理上相邻，随机存取</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define LIST_SIZE 100#define LISTINCREMENT 10typedef struct {   ElemType *elem;   int length;   int listsize;}SqList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>动态分配：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void *malloc();free(void *p);void *realloc(void *p,unsigned int size);//可变大/变小<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>基本操作略</p><h3 id="链表表示"><a href="#链表表示" class="headerlink" title="链表表示"></a>链表表示</h3><p>逻辑上相邻不代表物理上相邻，非随机存取</p><p>（区别不同逻辑结构的插入删除操作）</p><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct LNode {elemtype data;   struct LNode *next;}Lnode ,*LinkList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>基本操作：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Status GetElem_L(LinkList L,int i,ElemType &amp;e);Status ListInsert_L(LinkList &amp;L,int i，ElemType e);//获取结点的前驱耗时间，T(N)=O(N)Status ListDelete_L(LinkList &amp;L,int i，ElemType &amp;e);Status CreateList_L(LinkList &amp;L);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建：头插法（$T(N)=O(N)$），尾插法($T(N)=O(N^2)$)(头插法创建较好)</p><p>作业习题：<strong>就地逆置</strong>单链表</p><p>有头结点：L指向头结点，除头结点各点均有前驱；</p><p>无头结点：空表时L为NULL；</p><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><ol><li>便于从一个结点出发，访问全部的结点</li><li>在O(1)的时间内找到链表的第一个结点和最后一个结点（头指针==尾指针）</li></ol><h4 id="静态链表和动态链表"><a href="#静态链表和动态链表" class="headerlink" title="静态链表和动态链表"></a>静态链表和动态链表</h4><p>静态链表(若语言不支持指针类型的存储的情况)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define MAXSIZE 1000typedef struct{   ElemType data;   int cur;//代替指针域}component,SLinkList[MAXSIZE];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数组的第0个分量可以视为（备用链的）头结点；</p><p>静态链表的模拟动态分配与释放（未利用的点i[cur]=0;)</p><p>动态链表与静态链表的运用：例：求差集</p><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct DuLNode{   ElemType data;   struct DuLNode *prior;   struct DuLNode *next;}DuLNode ,*DuLinkList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可带头结点，可不带（多半是带的）。</p><h4 id="其他表示"><a href="#其他表示" class="headerlink" title="其他表示"></a>其他表示</h4><p>根据题目要求规定进行设计，如同时存储单链表的头和尾，特殊线性表——有序表。</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>1.双向循环链表的自身变换，如将$L={a_1,a_2,…..a_n}$变换为$L’={a_1,a_3,….a_n,…a_4,a_2}$</p><p>​    (顺着后向链，前向链进行插入)</p><h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><p>难点：<strong>递归与非递归实现</strong>，循环队列</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>LIFO 只能在Top端进行插入删除操作</p><p><em>Traverse操作是从栈底到栈顶进行访问</em></p><p>多为顺序栈：约定：S.top指向<strong>栈顶元素的下一个位置</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define STACK_INT_SIZE 100#define STACKINCREMENT 10typedef struct {   ElemType *base;   ElemType *top;   int stacksize;//当前分配容量}SqStack；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>栈空：S.base==S.top</p><p>栈满：S.top-S.base&gt;=S.stacksize</p><p>入栈：S.top++;    出栈: S.top - - ；</p><p>链栈：无栈满问题，可以不必引入头结点（在第一个结点处进行插入删除操作）。</p><h3 id="栈的基本应用"><a href="#栈的基本应用" class="headerlink" title="栈的基本应用"></a>栈的基本应用</h3><p>1.数制转换</p><p>2.行编辑程序（已不常用）</p><p>​            用栈保存终端输入的一行字符进行逐行处理；遇到‘#’退一格（出栈），遇到‘@’退一行（清空栈ClearStack），其他字符入栈，最后遍历，清空栈。</p><p>3.<strong>表达式求值</strong></p><p>表达式表示方法：</p><ul><li>中缀表达式，记得加括号</li><li>前缀表达式（波兰式）-<em>+abc </em>d-ea</li><li>后缀表达式（逆波兰式）ab+c<em>dea- </em> -</li></ul><p>表达式求值也可以用二叉树表示：分支保存运算符，叶子结点保存操作数，中序访问：中缀表达式；先序访问：前缀表达式；后序访问：后缀表达式</p><p><strong>要先确保中缀表达式合法：括号匹配</strong>     默认运算式结尾为’#’</p><p>可以进行的操作：中缀表达式转化为先/后缀表达式，先/后缀表达式求值，中缀表达式直接求值。注意：不涉及中缀表达式的运算不需考虑优先级。</p><p><code>[1]中缀表达式转后缀表达式：运算符入栈</code></p><p><code>[2]中缀表达式求值：运算符（包括左括号）和运算数两个栈，按照操作符优先级进行运算，'#'优先级最低。</code></p><p><code>[3]前缀表达式串求值：运算符和运算数入同一个栈，如果有两个运算数则进行运算</code></p><p><code>[4]前缀表达式与后缀表达式相互转化：思路相反，同样用栈，类似波兰式/逆波兰式求值，将字符串视作运算数。</code></p><p><code>[5]后缀表达式求值：运算数入栈</code></p><p>4.<strong>栈与递归的实现</strong></p><p>应用：构建其他数据结构：表，图，树和二叉树</p><p>​            问题求解：Hanoi塔问题，迷宫问题/N皇后问题（回溯）</p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>FIFO，允许在队尾rear插入，队头head删除（获取队头元素GetHead(L,&amp;e),遍历操作Traverse(L，visit())从head到rear）.</p><h4 id="链队列（通常）"><a href="#链队列（通常）" class="headerlink" title="链队列（通常）"></a>链队列（通常）</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct QNode{   ElemType data;   struct QNode *next;}QNode,*QueuePtr;typedef struct {   QueuePtr front;   QueuePtr rear;}LinkQueue;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（最好是引入头结点——队空：L.front ==L.rear）</p><h4 id="循环队列-处理假溢出"><a href="#循环队列-处理假溢出" class="headerlink" title="循环队列(处理假溢出)"></a>循环队列(处理假溢出)</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define MAXSIZE 100typedef struct{   ElemType *base;   int front;   int rear;//指向队尾元素的下一个位置}SqQueue；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>队空标志：Q.front==Q.rear</p><p>多申请一个空间，队满标志：Q.front==(Q.rear+1)%MAXSIZE</p><p>INCREMENT：重新分配空间，并遍历原队列进行复制</p><p>应用：离散事件模拟</p><h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><p>概念：串的长度，空串，子串，主串，子串/字符在串中的位置</p><p>是特殊的线性表：处理对象为个体（字符）或整体（子串）</p><p>操作：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">StrAssign(S,"...");//赋值StrCpoy(T,S);//复制串StrCompare(S,T);//比较ConCat(T,"...");//拼接SubString(Sub,S,i,j);//取子串Sub为Si,...SjIndex(s,"a",i);//返回S中i后第一层出现子串的首个字母的位置Replace(S,"..","..");//将子串全部替换为目标子串StrInsert(S,i,"...");//在i处插入子串StrDelete(S,i,j);//删除Si到Sj的子串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="具体存储结构"><a href="#具体存储结构" class="headerlink" title="具体存储结构"></a>具体存储结构</h3><p>顺序映像存储密度低</p><ul><li><p>定长顺序存储，下表为0的位置存储串的长度（basic)或串值最后加入无关字符，如’\0’ (C)。</p></li><li><p>堆分配存储——顺序映像</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct{   char *ch;//malloc() 动态分配   int length;}HString;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>​    <strong>块链存储——链式映像</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct Chunk{   char ch[CHUNKSIZE];   struct Chunk *next;}Chunk;typedef struct{   Chunk *head,*tail;   int curlen}LString;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>块链存储中的插入，删除，寻找子串，定位，拼接算法复杂化处理（作业题目）</p></li></ul><h3 id="串的模式匹配算法"><a href="#串的模式匹配算法" class="headerlink" title="串的模式匹配算法"></a>串的模式匹配算法</h3><p>好像不考。</p><h3 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h3><p>应用于文本编辑，页插入/删除，行插入/删除，页表，行表，起始地址，长度…</p><p>建立关键词词索引表</p><h2 id="数组和广义表"><a href="#数组和广义表" class="headerlink" title="数组和广义表"></a>数组和广义表</h2><p>数组的操作貌似也不考，补充三元表，特殊数组在后续算法课中。</p><h3 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h3><p>广义表是线性表的推广，元素类型可以是原子或子表，习惯上用大写字母表示子表，小写字母表示原子。（也可以看作特殊定义的图）</p><p>表处理语言LISP中，将广义表视作基本的数据结构。</p><p>表头：表中的第一个元素 GetHead(L)</p><p>表尾：除去第一个元素外的其余元素组成的表 GetTail(L)</p><p>基本定义</p><ul><li>空表 A=( )</li><li>长度：元素个数，如B=(a,(b,c,d))长度为2，第二个元素为表</li><li>A=(a,A) 可以递归定义的表</li><li>GetHead(((())))=(()); GetTail((()))=()</li><li>深度：括号的重数的最大值</li></ul><h3 id="广义表的存储结构"><a href="#广义表的存储结构" class="headerlink" title="广义表的存储结构"></a>广义表的存储结构</h3><p>数据元素不同，难以用顺序表存储。</p><h4 id="头尾链表存储"><a href="#头尾链表存储" class="headerlink" title="头尾链表存储"></a>头尾链表存储</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef enum{ATOM,LIST}ElemTag;typedef struct GLNode{   ElemTag tag;   union{      AtomType atom;      struct {GLNode *hp,*tp;}ptr;   };}*GList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="C:\Users\李\AppData\Roaming\Typora\typora-user-images\image-20211229111630880.png" alt="image-20211229111630880" style="zoom:20%;"></p><h4 id="拓展线性链表存储"><a href="#拓展线性链表存储" class="headerlink" title="拓展线性链表存储"></a>拓展线性链表存储</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef enum{ATOM,LIST}ElemTag;typedef struct GNode{   ElemTag tag;   union{      AtomType atom;      struct GLNode *hp;   };   struct GLNode *tp;}*GLIst;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="C:\Users\李\AppData\Roaming\Typora\typora-user-images\image-20211229111642454.png" alt="image-20211229111642454" style="zoom:25%;"></p><h3 id="广义表的相关操作"><a href="#广义表的相关操作" class="headerlink" title="广义表的相关操作"></a>广义表的相关操作</h3><p><em>此部分不考代码设计，可能有读代码分析的题目</em></p><p><strong>递归算法</strong>，归纳思维</p><h4 id="广义表的深度"><a href="#广义表的深度" class="headerlink" title="广义表的深度"></a>广义表的深度</h4><p>规定：LS为原子：DEPTH=0；</p><p>​            LS为空表：DEPTH=1；</p><p>​            归纳项：$DEPTH(LS)=1+Max{DEPTH(a_i)},\ n&gt;=1$</p><p>假设采用头尾链表存储：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int GListDepth(GLIst L)//递归{   if(!L)      return 1;   if(L-&gt;tag==ATOM)      return 0;   for(max=0,pp=L;pp;pp=pp-&gt;ptr.tp)   {      dep=GListDepth(pp-&gt;ptr.hp);      if(dep&gt;max) max=dep;   }   return max+1;}//可以用队列实现非递归算法，在每层开始处设置标志<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="复制广义表"><a href="#复制广义表" class="headerlink" title="复制广义表"></a>复制广义表</h4><p>归纳：复制LS—&gt;复制表头+复制表尾</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Status CpoyList(GList &amp;T,GList L){//假定头尾链表存储   if(!L)   {   T=NULL;      return OK;}   T=(GList)malloc(sizeof(GLNode));   T-&gt;tag=L-&gt;tag;   if(T-&gt;tag==ATOM)   {T-&gt;atom=L-&gt;atom;return OK:}   CopyList(T-&gt;ptr.hp,L-&gt;ptr.hp);   CopyList(Y-&gt;ptr.tp,L-&gt;ptr.tp);   return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以用栈实现非递归算法。</p><h4 id="广义表结构的建立"><a href="#广义表结构的建立" class="headerlink" title="广义表结构的建立"></a>广义表结构的建立</h4><p>由字符串建立广义表</p><p>表头+表尾递归处理</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="其他应用"><a href="#其他应用" class="headerlink" title="其他应用"></a>其他应用</h3><p>作业题目：就地逆置广义表(逆转所有子表)递归处理</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">```注：广义表的存储格式一般可以自选常见思路：1.将广义表看作表头表尾两部分进行递归处理​2.将广义表看作n个并列子表组成的表## 树和二叉树**二叉树的遍历，二叉树和森林的相互转换等相关算法设计**### 定义空树n=0;表示方法：树形表示，嵌套表示，广义表表示，凹入表示术语：高度，层次（1，2，...，h），度，祖先，子孙，有序树，无序树，终端结点，非终端结点，内部结点...操作：```c++TreeDepth(T);Parent(T,cur_e);LeftChild(T,cur_e);RightSibling(T,cur_e);InsertChild(&amp;T,p,i,c);//插入子树DeleteChild(&amp;T,p,i);TraverseTree(T,visit());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>每个结点最多有两个子树，度数一定是2，分左右。</p><p>性质：</p><ul><li>第i层最多有$2^{n-1}$个结点</li><li>深度为h的二叉树最多$2^{h}-1$个结点（上述两条可以推广到n叉树的情况）</li><li>$n_0=n_2+1;\ \ \ n=n_0+n_1+n_2;\ \ \ n-1=n_1+n_2$</li><li>若包含n个结点的树只有叶子结点和度数为k的结点，则树中包含的叶子结点为：$n_0=n-(n-1)/k$</li><li>满二叉树：深度为h且含有$2^{h}-1$个结点的二叉树</li><li>完全二叉树：前k-1层为满二叉树，第k层结点全在靠左边</li><li>具有n个结点的完全二叉树的深度：$h=[log_2n]+1$</li><li>若对一有n个结点的完全二叉树按层序编号，则对任意结点有：<ul><li>若i=1，为根结点，无双亲；若i&gt;1，双亲结点为[i/2]</li><li>若2i&gt;n,则结点i无左孩子，否则左孩子为2i。</li><li>若2i+1&gt;n，则i无右孩子，否则右孩子是2i+1.</li><li>上述结论可以大致推广到k叉树                                                                                                                     </li></ul></li></ul><p>二叉树的存储结构：</p><p>顺序存储：空间开销大</p><p>链式存储：二叉链（保存双亲结点变成三叉链）</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct{   ElemType data;   struct BiTNode *lchild,*rchild;}BiTNode,*BiTree;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二叉树的相关算法"><a href="#二叉树的相关算法" class="headerlink" title="二叉树的相关算法"></a>二叉树的相关算法</h3><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p><strong>先/中/后序遍历</strong>：每个结点均被访问三次</p><p>递归/非递归（栈）算法实现。</p><p><strong>最好使用函数调用的结果而不是返回值：为实现函数出现异常时改变Status及时终止</strong></p><p>相关运用：</p><ul><li><p>创建二叉树：类比先序访问</p><p>清空释放二叉树，或以某个结点为祖先的子树：后序访问</p></li><li><p>先序/后序拓补序列可以唯一确定一个二叉树。</p></li><li><p>非递归后序遍历要注意：设置访问标志tag</p></li><li><p>求深度</p></li></ul><p><strong>层次遍历</strong>递归/非递归（队列）实现</p><p>​        ——先访问的结点，子结点也会优先访问</p><ul><li>对二叉树进行层次遍历可以<strong>判断该二叉树是否为完全二叉树</strong>。</li><li>找到距离x最近的叶子子孙及距离：从x开始进行层次遍历，找到第一个叶子结点即可（每层末尾加一个虚结点进行计算距离</li><li>输出距离x最近的所有叶子及其数目</li><li>输出x到最近叶子子孙结点的路径：修改原队列：不释放已经遍历的结点并记录每个结点的双亲信息</li></ul><h4 id="二叉树的创建"><a href="#二叉树的创建" class="headerlink" title="二叉树的创建"></a>二叉树的创建</h4><ul><li>完全二叉树的顺序映射</li><li>先序拓扑序列</li><li>先序+中序或后序+中序也可唯一确定的一棵二叉树—-线索化二叉树</li></ul><h4 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h4><p>利用叶子结点的未使用的指针域，加两个标记</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef enum{Link,Thread}PointerTag;typedef struct BiThrNode{   ElemType data;   struct BiThrNode *lchild,*rchild;   PointerTag ltag,rtag;}BiThrNode,*BiThrTree;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先序/中序/后序线索化二叉树：对应遍历顺序的相应前驱，后继，其算法可以类比相应的遍历算法。</p><p>中序线索化中规中矩，基本是中序遍历的拓展，左孩子为前驱，右孩子为后继；</p><p>先序/后序线索化二叉树 相互对称，难点：找前驱和后继</p><p>后序找到前驱的方法：</p><ul><li>若该结点无左孩子，前驱由lchild指向</li><li>若该结点有左右孩子，前驱为右孩子</li><li>若该结点只有左孩子，前驱为左孩子</li></ul><p>后序找到结点的后继</p><ul><li>若结点为根结点，后继为空</li><li>若结点为双亲的右孩子或没有右兄弟，后继为双亲</li><li>若为有右兄弟的左孩子，且右兄弟为叶子结点，后继为右兄弟</li><li><strong>若为有右兄弟的左孩子，且右兄弟不是叶子结点，则后继为右兄弟后序遍历的第一个结点</strong></li></ul><p>后序找到结点的后继</p><ul><li>若结点为根结点，前驱为空</li><li>若结点为双亲的左孩子或没有左兄弟，前驱为双亲</li><li>若为有左兄弟的右孩子，且左兄弟为叶子结点，前驱为左兄弟</li><li><strong>若为有左兄弟的右孩子，且左兄弟不是叶子结点，则前驱为左兄弟先序遍历的最后一个结点</strong></li></ul><p>先序找到后继的方法</p><ul><li>若该结点无右孩子，后继由右孩子指向</li><li>若该节有左右孩子，其后继为左孩子</li><li>若该结点有右孩子且无左孩子，其后继为右孩子</li></ul><p>涉及求结点的双亲的问题———三叉链表</p><h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><h4 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h4><p>可以用于顺序存储</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define MAX_TREE_SIZE 100typedef struct{   ElemType data;   int parent;}PTNode;typedef struct{   PTNode nodes[MAX_TREE_SIZE];   int n;//结点数}PTree;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define MAX_TREE_SIZE 100typedef struct{  int child;   struct CTNode *next;}*ChildPtr;typedef struct{   ElemType data;   ChildPtr firstchild;}CTBox;typedef struct {   CTBox nodes[MAX_TREE_SIZE];   int n,r;//结点数和根的位置}CTree;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct CSNode{   ElemType data;   struct CSNode *firstchild,*nextsibling;}CSNode,*CSTree;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><p>先根遍历&lt;—-&gt;二叉树的先序遍历</p><p>后根遍历&lt;—-&gt;二叉树的中序遍历</p><p>应用：通常以孩子-兄弟链表示</p><ul><li>统计树的高度</li><li>统计树中叶子结点的个数（叶子结点的标志：Firstchild为空）</li><li>求树的度</li></ul><p>树和森林与二叉树之间的转换…没讲，不知道考不考</p><h3 id="Huffman树"><a href="#Huffman树" class="headerlink" title="Huffman树"></a>Huffman树</h3><p>相关概念：最优树，路径长度（带权），结点带权路径长度，$WPL=\sum_{i=1}^nw_il_i$</p><p>Huffman编码（算法应该不考，考也无所谓）</p><h3 id="开拓问题求解相关思路"><a href="#开拓问题求解相关思路" class="headerlink" title="开拓问题求解相关思路"></a>开拓问题求解相关思路</h3><p>课本没讲？。？应该不考OvO</p><p>划分等价类，回溯法求解问题，树的计数/编号</p><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>相关概念：有向图，无向图，带权/无权图路径和连通性，连通和强连通，子图，生成树，顶点/弧（相关概念复习图论再写）</p><p>一般算法中不考虑带权图的权值为负数的情况</p><p>基本操作 PS:操作包含对点vex，对边arc的操作</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Status LocateVex(G,u);Status GetVex(G,v);Status FirstAdjVex(G,v);Status NextAdjVex(G,v,w);Status InsertVex(G,v);Status InsertArc(&amp;G,v,w);Status DeleteVex(&amp;G,v);Status DeleteArc(&amp;G,v,w);Status DFSTraverse(G,v,Visit());Status BFSTraverse(G,v,Visit());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><p>用顺序表存储顶点集，不是顺序映像</p><p>最常用的还是邻接表</p><p>用以下方法存储关系集合</p><h4 id="数组表示—邻接矩阵"><a href="#数组表示—邻接矩阵" class="headerlink" title="数组表示—邻接矩阵"></a>数组表示—邻接矩阵</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define INFINITY INT_MAXtypedef enum{DG,DN,AG,AN}GraphKind;//有向/无向，带权/无权typedef struct ArcCell{   //带权图：adj代表权值，INFINITY代表不相邻   //无权图0代表不相邻，1代表相邻   int adj;   InfoType *info;//指向相关信息的指针}ArcCell,AdjMatrix[MAX_VERTEX_NUM][MAX_VEXTEX_NUM];typedef struct {   VextexType vexs[MAX_VEXTEX_NUM];   AdjMatrix arcs;   int vexnum;   int arcnum;   GraphKind kind;}MGraph;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>无向图的邻接矩阵：对阵矩阵</p><h4 id="链表表示—邻接表-逆邻接表"><a href="#链表表示—邻接表-逆邻接表" class="headerlink" title="链表表示—邻接表/逆邻接表"></a>链表表示—邻接表/逆邻接表</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct ArcNode{   int adjvex;   struct ArcNode *nextarc;   InfoType *info;}ArcNode;typedef struct {   VexType data;   ArcNode *firstarc;}VNode,AdjList[MAX_VERTEX_NUM];typedef struct{   AdjList vertices;   int vexnum,arcnum;   GraphKind kind;}ALGraph;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于有向图，比较容易计算的是顶点的出度，而入度要对所有的边进行遍历才能求出（反之为逆邻接表）。</p><p>对于稀疏图（$v&gt;log_2a$），多采用邻接表，避免空间浪费，否则可以选用邻接矩阵。</p><h4 id="十字链表—有向图"><a href="#十字链表—有向图" class="headerlink" title="十字链表—有向图"></a>十字链表—有向图</h4><p>弧结点数=弧数</p><p>方便求出顶点的入度和 出度</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct ArcBox{   int tailvex,headvex;   struct ArcBox *hlink,*tlink;   InfoType *info;}ArcBox;typedef struct VexNode{   VextexType data;   ArcBox *firstin,*firstout;}VexNode;typedef struct{   VexNode xlist[MAX_VERTEX_NUM];   int vexnum,arcnum;}OLGraph;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="邻接多重表—无向图"><a href="#邻接多重表—无向图" class="headerlink" title="邻接多重表—无向图"></a>邻接多重表—无向图</h4><p>邻接表中：边结点数==2*边数</p><p>临界多重表：边结点数==边数</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef enum{unvisited ,visited}VisitIf;//边结点typedef struct EBox{   VisitIf mark;   int ivex,jvex;   struct Ebox *ilink,jlink;   InfoType *info;}EBox;//顶点结点typedef struct VexBox{   VexType data;   EBox *firstedge;}VexBox;//临界多重表typedef struct {   VexBox adjmulist[MAX_VEXTEX_NUM];   int vexnum,edgenum;}AMLGraph;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>对顶点的遍历——引入标记数组visitd[0,…n-1]，防止<strong>顶点</strong>被多次访问。</p><p>访问结束可以得到图的生成树（连通图可以从一个顶点完成全部的遍历，非连通图要在外部加循环确保所有顶点均被访问，有向图注意强连通），后续连通性模块将讨论。</p><p>可以基于图的多种存储结构进行相似的遍历，算法可以基于ADT Graph（调用ADT的函数，如FirstAdjVex，NextAdjVex等）或某种存储结构写。</p><h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><p>深度优先遍历——树的先序遍历</p><p>生成从起点v出发的深度优先生成树，v可能存在多个子树</p><p>非递归实现：利用栈及时进行现场保护和现场维护</p><h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><p>广度优先遍历——树的层次遍历</p><ul><li>判断两个顶点是否存在路径</li><li>得到某点到任意一个顶点之间的最短路径（无权）</li><li>求距离v的最短距离最长/最短的顶点</li><li>求距离v距离为k的所有顶点</li></ul><p><strong>遍历算法的应用</strong></p><ul><li><code>求一条包含图中所有顶点的简单路径</code><ul><li><code>不一定存在，基于DFS寻找，是否能找到与具体顶点的选择有关</code></li><li><code>对DFS的修改：要回溯，添加计数器记录当前路径的结点数n，查找失败时恢复原来的状态，n--</code></li><li><code>可以修改算法，选择输出一条路径或者全部路径（最好是一条？），统计最短路径的条数</code></li></ul></li><li>求距离v的最短距离最长的顶点和最长的路径值<ul><li>对BFS进行修改，在每层结尾入队一个特殊元素</li><li>最后一个出队列的一定是路径最长的顶点</li></ul></li></ul><h3 id="图的连通性问题"><a href="#图的连通性问题" class="headerlink" title="图的连通性问题"></a>图的连通性问题</h3><p>基本概念：连通分量的顶点集，生成树，DFS生成树，BFS生成树，生成森林</p><p>同样可以基于ADTGraph或具体的存储方式写出不同的算法</p><ul><li>BFS/DFS生成树/生成森林</li><li><code>有向图的强连通分量</code><ul><li><code>从某顶点出发，以该顶点为尾做DFS，按照其所有邻接点的搜索都完成的顺序（退出DFS的顺序）存储到数组</code></li><li><code>从存储到数组的顶点出发，沿着该顶点为头的弧进行逆向DFS，能访问到的顶点则在同一个强连通分量中</code></li><li><code>复杂度近似和DFS遍历的复杂度相同</code></li></ul></li><li><code>最小生成树MST——无向连通网的最小代价生成树</code><ul><li>“若（u，v)为具有最小权值的边，则必存在包含该边的最小生成树”</li><li><code>Prim算法——最小生成树不断壮大的过程</code><ul><li><code>适用于稠密图</code>$T(N,e)=O(N^2)$</li></ul></li><li><code>Kruskal算法——连通分量不断合并的过程</code><ul><li><code>适用于稀疏图</code>$T(N,e)=O(N*log (e))$</li></ul></li></ul></li><li>关节点和重连通分量<ul><li>关节点：删除v后一个连通分量变为两个/两个以上<ul><li>若生成树的根至少有两棵或两棵以上的子树，则该结点必是关节点</li><li>若生成树的某非叶子结点v的某棵子树的结点均没有指向v的祖先的边，则v为关节点</li><li>叶子结点一定不是关节点</li></ul></li><li>重连通图：不含关节点的图，保证了任意两个顶点至少存在两条路径</li><li>连通度：若连通图G至少删去K个顶点才能变成不连通，则该图的连通度为k</li><li>改造DFS可以得到图的关节点，判断是否为重连通图<ul><li>引入数组low[v]:生成树中以v为根的子树中结点到v的祖先的边所关联的祖先的最小次序号</li><li>若对于v，v的孩子结点w有low[w]&gt;=visited[v]，则说明v为关节点</li></ul></li></ul></li></ul><h3 id="有向无环图（-DAG）的应用"><a href="#有向无环图（-DAG）的应用" class="headerlink" title="有向无环图（ DAG）的应用"></a>有向无环图（ DAG）的应用</h3><ul><li>检测有向图中是否有环：<ul><li>从顶点v出发，若DFS结束前发现出现u到v的回边，则有环</li></ul></li></ul><p>DAG是描述一项活动或系统的进行过程的工具：</p><p>​    顶点—子工程，边—子工程之间的约束</p><p>应用：</p><h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><p>问题描述：偏序-&gt;全序</p><p>偏序：集合X上的元素是自反的，反对称的，传递的</p><p>一、AOV网：Activity on vextex network</p><p>进行拓扑排序的方法：</p><ol><li>在有向图中选取一个没有前驱的顶点并输出</li><li>在图中删除该顶点和以该顶点为尾的弧</li><li>转1，除非已经输出全部顶点或不存在无前驱的顶点</li></ol><p>有向无环图保证了该图存在拓扑排序，存在拓扑排序保证了有向图中没有环</p><p><code>对于一个有向无环图，进行DFS遍历，第一个退出循环的顶点即为出度为0的顶点，（可以）是拓扑排序的最后一个顶点</code></p><p><code>若有向图的邻接矩阵为三角矩阵，则该途中存在拓扑有序序列</code></p><p>二、AOE网：Activity on edge network</p><p>问题：完成整项工程的最短时间/关键路径/事件的最早发生时间</p><p>关键活动：最早发生时间（e(i)）==最晚发生时间（l(i)）</p><p>最早发生时间：拓扑有序</p><p>最晚发生时间：逆拓扑有序</p><p><code>关键路径</code>：输出关键活动（可能不止一条）</p><h4 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h4><p>无权图的最短路径：广度优先搜索</p><p>带权有向图的最短路径——<code>dijkstra算法</code></p><p>按路径长度递增的顺序产生最短路径</p><p>求任意两个顶点的最短路径</p><p>对Dijkstra算法进行循环：$O(T,e)=O(n^3)$</p><p>具体实现应该不会考，会考画图？</p><p><code>Floyd</code>（Wallshall算法）：求vi，vj之间的最短路径，依次使得中间路径序号不大于k的最短路径，k依次递增。</p><h2 id="查找Search-Table"><a href="#查找Search-Table" class="headerlink" title="查找Search Table"></a>查找Search Table</h2><p>操作：检索/查找（静态），插入/删除（动态）</p><p>关键字：主关键字唯一，次关键字不唯一</p><h3 id="静态查找"><a href="#静态查找" class="headerlink" title="静态查找"></a>静态查找</h3><h4 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h4><p>通过顺序表/线性链表进行查找</p><p>0的位置设置“哨兵”：避免每一次查找都要判断是否查找完毕，减少比较次数</p><p>查找成功：ASL=$(n+1)/2$</p><p>查找不成功：ASL=n+1</p><h4 id="有序表的查找"><a href="#有序表的查找" class="headerlink" title="有序表的查找"></a>有序表的查找</h4><ol><li>折半查找<ol><li>基本思想：用low/high做标记，查找区间折半缩小</li><li>性能分析：查找过程可以用二叉树判定树表示，判定树的形态与n直接相关（不是完全二叉树但胜似完全二叉树），查找层次即为二叉树的层次，也代表ASL</li><li>查找成功或不成功：$ASL&lt;=[log_2n]+ 1$</li><li>n&gt;=50时，可近似得到结果：$ASL_{bs}\approx log_2(n+1)-1$</li></ol></li><li>斐波那契查找<ol><li>根据斐波那契的特征对标进行分割:开始表中的记录个数比斐波那契数小1，则将定值与F(n-1)进行比较，类似折半查找</li><li>特点：分割时只需进性加减运算</li><li>平均性能比折半查找好，但最坏的情况比折半查找糟糕</li></ol></li><li>插值查找<ol><li>$i=\frac{key-ST.elem[l].key}{ST.elem[h].key-ST.elem[l].key}(h-l+1)$</li><li>只适用于关键字均匀分布的情况，这种情况下平均性能优于折半查找</li></ol></li><li>静态树表查找<ol><li>根据各个记录的查找概率求ASL</li><li>PH值：判定树内带权路径长度$PH=\sum_{i=1}^nw_ih_i$,其中$w_i=c*p_i$为权，$h_i$为层次</li><li>PH值最小：静态最优查找树——构造需要的时间开销过高</li><li>构造较好的次优查找树</li><li>…写到这里发现查找树表不考，再见</li></ol></li><li>索引顺序表<ol><li>起因：顺序查找表效率低而折半查找等要求查找表有序</li><li>思想：分块有序——索引有序（索引包含最大项和起始指针）</li><li>过程：先折半查找记录所在的块，再顺序查找元素</li><li>$ASL_{bs}=L_b(查找块)+L_w(查找元素)$</li></ol></li></ol><h3 id="动态查找"><a href="#动态查找" class="headerlink" title="动态查找"></a>动态查找</h3><h4 id="二叉查找树BST"><a href="#二叉查找树BST" class="headerlink" title="二叉查找树BST"></a>二叉查找树BST</h4><p>Binary  Search Tree查找算法可以基于二叉树的先序遍历算法写出</p><p>中序遍历BST可以得到关键字的有序序列</p><p>BST的插入算法：查找失败的同时添加叶子结点</p><p>BST的删除算法：</p><ol><li>若P为叶子结点，直接删除并修改双亲的指针域</li><li>若P只有左子树或右子树，将P删除并使P的双亲指针域指向P的孩子</li><li>若P有左右子树，将P与P的右子树的最左边的元素进行互换（中序遍历的首个元素），换言之，将P与P在树中中序访问序列的直接前驱或直接后继进行交换即可，避免树的长高</li></ol><p>BST的建立：二叉树的形态与输入的次序直接相关，若原本有序将得到每层只有一个结点的糟糕情况</p><p>平均性能分析：$P(n)&lt;=2(1+1\frac{1}{n})ln\ n$</p><h4 id="平衡二叉树AVL树"><a href="#平衡二叉树AVL树" class="headerlink" title="平衡二叉树AVL树"></a>平衡二叉树AVL树</h4><p>深度与log(N)同量级</p><p>引入平衡因子BF：-1，0，1</p><p>AVL树的旋转部分不会单独考察算法设计，理解过程即可</p><ul><li>LL型旋转：在A结点的左孩子的左子树插入结点</li><li>RR型旋转：在A结点的右孩子的右子树插入结点</li><li>LR型旋转：在A结点的左孩子的右子树插入结点，先左转再右转</li><li>RL型旋转：在A结点的右孩子的左子树插入结点，先右转再左转</li></ul><p>在对AVL树进行插入和删除操作时及时维护平衡</p><p>性能分析：$T(N)=O(log\ N)$</p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h3><p>定义：</p><ul><li>每个结点至多有m个子树</li><li>若根结点不是叶子结点，至少有两棵子树</li><li>除根结点外的非得终端结点至少$\lceil m/2\rceil$个子树</li><li>非终端结点包含以下信息：$(n,A<em>0,K_1,A_1,K_2,…,K_n,A_n)$，其中n为关键字数目，$K_i$为关键字，$A_i$为指针，且$A</em>{i-1}$指向的所有结点的关键字小于$K<em>i$,大于$K</em>{i-1}$</li><li>所有叶子结点都出现在同一层次上,且不携带信息，可以视作查找失败，指向这些结点的指针为空，图中表示为F</li></ul><p>相关算法</p><p>查找：纵向查结点，横向查关键字</p><p>通常存储在磁盘中，是数据库的主要索引结构</p><p>查找效率的首要因素：层次</p><p>通常取m=3，此时又称为2-3树</p><p>含有N个关键字的m阶B-树的最大深度：$log_{\lceil m/e\rceil}(\frac{N+1}{2})$</p><p>较为特殊的插入删除操作：</p><p>…应该不考察算法，要会画图</p><h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h3><p>B-树的变形树，具体区别：</p><ul><li>有n棵子树的结点包含了n个关键字</li><li>所有叶子结点包含了关键字的信息，以及指向这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大排序</li><li>非终端结点为索引部分，结点仅含有最大或者最小关键字</li></ul><p>B+树不是树；支持顺序查找（横向），随机查找（纵向）</p><h3 id="键树"><a href="#键树" class="headerlink" title="键树"></a>键树</h3><p>好像不考键树</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>Hash函数：H(key)</p><p>便于一次存取确定所查记录</p><p>将一组关键字利用H(key)和处理冲突的函数映射到有限的连续地址——hash表（散列）</p><p>Hash函数的构造方法：</p><ul><li>直接定址法（x)</li><li>数字分析法/平方取中法</li><li>折叠发：移位叠加，间界叠加</li><li>除留余数法</li><li>随机数法</li><li>…</li></ul><p>处理冲突的方法：s</p><ul><li>开放定址法<ul><li>线性探测再散列+1，+2，…</li><li>平方探测再散列+1,-1,+4,-4</li><li>伪随机探测再散列</li></ul></li><li>链地址法：关键字为同义词的的各个元素存储在线性链表中</li><li>再哈希法：$H_i=RH_i(key),i=1,2,..k$不易产生聚集，但会增加计算的时间</li><li>建立公共溢出区域：发生冲突都填入溢出表</li></ul><p>​    <code>二次聚集</code>：在处理同义词冲突的过程中又添加了非同义词的冲突的现象</p><h4 id="Hash表的查找算法"><a href="#Hash表的查找算法" class="headerlink" title="Hash表的查找算法"></a>Hash表的查找算法</h4><p>根据Hash函数以及冲突处理方法确定</p><p>查找的ASL：分成功与不成功计算，时间复杂度为未知</p><p>装填因子$\alpha=$记录数/Hash表表长</p><p>通常Hash表长m和除留余数法的p的关系：</p><p>p&lt;=m,且p为素数或最小不包含小于20的质因子的合数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2021数据结构复习&quot;&gt;&lt;a href=&quot;#2021数据结构复习&quot; class=&quot;headerlink&quot; title=&quot;2021数据结构复习&quot;&gt;&lt;/a&gt;2021数据结构复习&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;考试范围&quot;&gt;&lt;a href=&quot;#考试范围&quot; class=</summary>
      
    
    
    
    <category term="数据结构" scheme="http://sn1987a-1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="专业课" scheme="http://sn1987a-1.github.io/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    <category term="数据结构" scheme="http://sn1987a-1.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>图论期末复习</title>
    <link href="http://sn1987a-1.github.io/posts/12532.html"/>
    <id>http://sn1987a-1.github.io/posts/12532.html</id>
    <published>2022-01-05T15:42:30.000Z</published>
    <updated>2022-02-26T07:11:20.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图论复习"><a href="#图论复习" class="headerlink" title="图论复习"></a>图论复习</h1><p>未完成——不想写了</p><h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><ul><li><code>阶</code>：图G中顶点的个数$\nu (G)=|V(G)|$（简记为$\nu,V$）</li><li>$\epsilon (G)=|E(G)|$（简记为$\epsilon ,E$）</li><li><code>无限图</code>：$\nu(G)+\epsilon (G)=+\infty$，否则成为<code>有限图</code></li><li><code>关联/相邻/邻顶</code>：$\psi (e)={u,v}$</li><li><code>重边/环</code></li><li><code>简单图</code>：无环无重边</li><li><code>完全图 二分图  完全二分图</code></li><li><code>零图  星图</code></li><li><code>度数</code>$deg(\nu)=d_1(\nu)+2\times l(\nu)$</li><li><code>最大/最小度数</code>$\delta (G)=min<em>{\nu \in V(G)},\Delta (G)=max</em>{\nu\in V(G)}$</li><li>无向图$\sum_{\nu\in V(G)}{deg(\nu)=2\epsilon(G)}$<ul><li>给定图G，G中度数为奇数的顶点个数为偶数</li></ul></li><li><code>真子图，生成子图（V(H)=V(G)），顶点导出子图，边导出子图</code></li><li><code>补图，边图</code>：边图的边对应原图的顶点，顶点对应原图的边</li><li><code>并，交</code></li><li><code>积</code>：$G\times H=(V’,E’)$,边集合分为三类：<ul><li>两个顶点在的两个分量在原图中均相邻</li><li>有一个分量在原图中相邻，另外一个分量为同一个顶点</li></ul></li><li><code>路径/行迹/轨道/回路/圈</code></li><li><code>连通/不连通</code>：连通存在距离</li><li><code>图的同构</code>：元素之间的二元关系完全相同</li><li><code>Ulam猜想</code>：G与H全等 等价于 对任何$\nu \in V(G),G-\nu=V-\nu$</li><li>有向图D：$D=(V(D),E(D),\psi _D)$</li><li>$\sum<em>{\nu\in V(G)}{deg^-(\nu)}(入度)=\sum</em>{\nu\in V(G)}{deg^+(\nu)}(出度)=\epsilon(G)$</li></ul><p><strong>定理</strong>：G为二分图当且仅当G中无奇圈</p><p><code>最长轨道 反证</code>例：若G为简单图，$\delta (G)&gt;=2$，则G中必含圈</p><p>​                          若G为简单图，$\delta (G)&gt;=3$，则G中必含有偶圈</p><p>最短路径问题$\omega (P_0(u,v))$——Dijkstra算法</p><p>​    证明略。</p><p>类似最短路径的相关思路——如取生成子图最大边数：</p><p>任给无向图G，存在H为G的生成子图，满足：</p><ul><li>H是二分图</li><li>任给$u\in V(G)=V(H),有d_H(u)&gt;=d_G(u)/2$</li></ul><p>取H为边数最大的二分图，假设不满足条件2</p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>基本概念:</p><ul><li><code>树叶/分支点（树枝）</code> <code>森林/平凡树</code></li></ul><p>以下命题等价</p><h2 id="图的连通性"><a href="#图的连通性" class="headerlink" title="图的连通性"></a>图的连通性</h2><h2 id="平面图"><a href="#平面图" class="headerlink" title="平面图"></a>平面图</h2><h2 id="匹配理论"><a href="#匹配理论" class="headerlink" title="匹配理论"></a>匹配理论</h2><h2 id="Euler图和Hamilton图"><a href="#Euler图和Hamilton图" class="headerlink" title="Euler图和Hamilton图"></a>Euler图和Hamilton图</h2><h2 id="图的着色"><a href="#图的着色" class="headerlink" title="图的着色"></a>图的着色</h2><h2 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h2><h2 id="网络流理论"><a href="#网络流理论" class="headerlink" title="网络流理论"></a>网络流理论</h2><h2 id="图矩阵和图空间"><a href="#图矩阵和图空间" class="headerlink" title="图矩阵和图空间"></a>图矩阵和图空间</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图论复习&quot;&gt;&lt;a href=&quot;#图论复习&quot; class=&quot;headerlink&quot; title=&quot;图论复习&quot;&gt;&lt;/a&gt;图论复习&lt;/h1&gt;&lt;p&gt;未完成——不想写了&lt;/p&gt;
&lt;h2 id=&quot;图的基本概念&quot;&gt;&lt;a href=&quot;#图的基本概念&quot; class=&quot;headerl</summary>
      
    
    
    
    <category term="图论" scheme="http://sn1987a-1.github.io/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    
    <category term="专业课" scheme="http://sn1987a-1.github.io/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    <category term="图论" scheme="http://sn1987a-1.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>图论补充内容</title>
    <link href="http://sn1987a-1.github.io/posts/15331.html"/>
    <id>http://sn1987a-1.github.io/posts/15331.html</id>
    <published>2021-12-11T12:12:20.000Z</published>
    <updated>2022-03-01T08:37:18.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图论补充内容"><a href="#图论补充内容" class="headerlink" title="图论补充内容"></a>图论补充内容</h1><p>图论的基本知识汇总已以PDF形式上传至科大个人主页链接，此部分补充内容主要记录图论在实际算法问题方面的知识学习，部分内容来源于网络。</p><h2 id="计算复杂性问题"><a href="#计算复杂性问题" class="headerlink" title="计算复杂性问题"></a>计算复杂性问题</h2><p><code>P问题、NP问题、不可判定问题</code><br><strong>P问题</strong>：能够在多项式时间内可用算法求解的问题。举例：找到Euler回路<br><strong>NP问题</strong>：非确定型多项式时间（nondeterministic polynomial-time）问题，指<strong>不确定是否存在多项式时间的求解算法，但可以在多项式时间内验证一个猜测解的正确性</strong>的问题。举例：找Hamilton回路（实际上是NPC问题，尚且未知有限性算法）。<br><strong>不可判定问题(undecidable problem)</strong>：”不可能“解出的问题。举例：让C编译器找出所有的语法错误和无限循环。</p><p>与NP相关的问题有P，NP，NP Hard ，NPC问题，其中NP Hard 与NPC问题的具体描述为：</p><blockquote><p>NP hard问题：Non-deterministic Polynomial hard problem(NPH)问题，如果所有NP问题可在多项式时间内转化（归约，意思是解决了后者也就相应的解决了前者）成某个问题，则该问题称为NP难问题。<br>这里规约的意思是将一个特殊问题一般化，即将原问题推广为一个最一般的、最有概括性、也更难的、计算复杂度更高的问题，这个问题具有最高的计算复杂度，如果这个最一般的问题也能有多项式时间求解算法，那么那些特殊的原问题也能有多项式时间求解算法。<br>解决了这个NP hard问题，所有NP问题都能够被解决了。</p><p> NP hard问题不一定是NP问题，有可能是不可判定问题。这时候说明原问题也是不可判定的。</p><p>NPC问题：Non-deterministic Polynomial complete problem ，如果所有NP问题可在多项式时间内归约成某个NP问题，则该NP问题称为NP完全问题。NPC包含了NP中最难的问题。<br>解决了这个NPC问题。所有NP问题都能够被解决了。</p><p> NPC问题相当广泛，包括来自操作系统（调度和安全）、数据库系统、运筹学、逻辑学、特别是图论等不同领域的问题。<br>可满足性问题、哈密顿圈问题、巡回售货员问题、最长路径问题都是NPC问题。 装箱(bin packing)问题、背包(knapsack)问题、图的着色(graph coloring)问题以及团(clique)的问题都是著名的NPC问题。NPC问题相当广泛，包括来自操作系统（调度和安全）、数据库系统、运筹学、逻辑学、特别是图论等不同领域的问题。<br> 背包问题(Knapsack problem)是一种组合优化的NP完全问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。问题的名称来源于如何选择最合适的物品放置于给定背包中。相似问题经常出现在商业、组合数学，计算复杂性理论、密码学和应用数学等领域中。也可以将背包问题描述为决定性问题，即在总重量不超过W的前提下，总价值是否能达到V？它是在1978年由Merkel和Hellman提出的。背包问题已经研究了一个多世纪，早期的作品可追溯到1897年数学家托比亚斯·丹齐格（Tobias Dantzig，1884-1956）的早期作品 ，并指的是包装你最有价值或有用的物品而不会超载你的行李的常见问题。</p></blockquote><p>NPC算法的复杂度更倾向于$O(e^n)$,NP Hard 算法的时间复杂度甚至可能达到$O(n^n)$.</p><p>在本课程里出现的NPC问题：</p><ol><li>图着色（边/顶点/面着色）</li><li>Hamilton圈算法</li><li>…?</li></ol><h2 id="随机游走Random-Walk"><a href="#随机游走Random-Walk" class="headerlink" title="随机游走Random Walk"></a>随机游走Random Walk</h2><blockquote><p><strong>随机游走</strong>（英语：Random Walk，缩写为 RW），是一种<a href="https://zh.wikipedia.org/w/index.php?title=數學統計模型&amp;action=edit&amp;redlink=1">数学统计模型</a>，它是一连串的<a href="https://zh.wikipedia.org/wiki/軌跡">轨迹</a>所组成，其中每一次都是<a href="https://zh.wikipedia.org/wiki/随机过程">随机</a>的。<a href="https://zh.wikipedia.org/wiki/隨機漫步#cite_note-Wirth-1">[1]</a><a href="https://zh.wikipedia.org/wiki/隨機漫步#cite_note-2">[2]</a>它能用来表示不规则的变动形式，如同一个人酒后乱步，所形成的<a href="https://zh.wikipedia.org/wiki/随机过程">随机过程</a>记录。1905年，由<a href="https://zh.wikipedia.org/wiki/卡尔·皮尔逊">卡尔·皮尔逊</a>首次提出。</p><p>——来自维基百科</p><p>靠随机游走解出来了tx的自定义阴间一笔画红包</p><p>——来自群友</p></blockquote><p>算法思想：</p><ul><li>该算法要实现的是搜索，从起始点s开始找到目的地t。</li><li>给定一个图，从起点开始走的每一步都让其有一定的概率$\alpha$跳转到图中的任意一个点上，还有$ 1-\alpha$的概率会行走到任意一个与该点相连的点上。不断的重复上述过程，直到找到目的地中。</li></ul><p>步骤</p><ul><li>将实际问题抽象为图的形式，并用临接表、邻接矩阵等存图方式将图存储在计算机中；</li><li>用一个变量记录当前所处的位置（图中点的标号），每次随机一个[0, 1]之间的数，若其小于等于随机跳跃概率$\alpha $则随机一个[1, n]的数字并跳转，否则随机一个$x,x\in S$，其中S为与当前点相连的点的集合；</li><li>不断重复第二步并记录路径，直到找到目的地t.</li></ul><p>该算法的思想也被应用到了PageRank算法中，作为Google等搜索引擎的网页检索算法。（PageRank中心性算法的本质就是随机游走（详见课本中心型算法部分，考试不考）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图论补充内容&quot;&gt;&lt;a href=&quot;#图论补充内容&quot; class=&quot;headerlink&quot; title=&quot;图论补充内容&quot;&gt;&lt;/a&gt;图论补充内容&lt;/h1&gt;&lt;p&gt;图论的基本知识汇总已以PDF形式上传至科大个人主页链接，此部分补充内容主要记录图论在实际算法问题方面的知识学</summary>
      
    
    
    
    <category term="图论" scheme="http://sn1987a-1.github.io/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    
    <category term="专业课" scheme="http://sn1987a-1.github.io/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    <category term="图论" scheme="http://sn1987a-1.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>数据结构实验设计2_HUFFMAM Tree</title>
    <link href="http://sn1987a-1.github.io/posts/1120.html"/>
    <id>http://sn1987a-1.github.io/posts/1120.html</id>
    <published>2021-11-11T11:46:11.000Z</published>
    <updated>2022-02-26T07:09:20.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Huffman-编码解压缩"><a href="#Huffman-编码解压缩" class="headerlink" title="Huffman 编码解压缩"></a>Huffman 编码解压缩</h1><p>关于Huffman编码的知识,在上个学期数据结构已经学过,作为较为复杂的一次实验耗费了不少时间,可说实话,上个学期在数据结构投入的经历确实不算大,最终的成绩也相当不理想,但这个学期还得重新学数据结构(信计数据结构不能互认就离谱orz),同样类型的实验,不同的心境 ,不同的要求,只求要一个好一点点的分数啦</p><h2 id="大致实验要求"><a href="#大致实验要求" class="headerlink" title="大致实验要求"></a>大致实验要求</h2><p>基于Huffman编码来实现压缩器和编码器,使其可以对任意文件进行解压缩操作.</p><p>实现方法:命令行执行/GUI界面(还不会…)/运行程序交互界面</p><p>本实验的测试数据:文件包括:.txt    .png    .wav    .mp4    .zip</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Huffman-编码解压缩&quot;&gt;&lt;a href=&quot;#Huffman-编码解压缩&quot; class=&quot;headerlink&quot; title=&quot;Huffman 编码解压缩&quot;&gt;&lt;/a&gt;Huffman 编码解压缩&lt;/h1&gt;&lt;p&gt;关于Huffman编码的知识,在上个学期数据结构已经</summary>
      
    
    
    
    <category term="数据结构" scheme="http://sn1987a-1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="专业课" scheme="http://sn1987a-1.github.io/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    <category term="数据结构" scheme="http://sn1987a-1.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>模拟与数字电路期中复习</title>
    <link href="http://sn1987a-1.github.io/posts/15234.html"/>
    <id>http://sn1987a-1.github.io/posts/15234.html</id>
    <published>2021-11-05T15:42:30.000Z</published>
    <updated>2022-02-26T07:10:12.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模拟与数字电路"><a href="#模拟与数字电路" class="headerlink" title="模拟与数字电路"></a>模拟与数字电路</h1><p>[TOC]</p><h2 id="2022-1-15-模拟与数字电路期末考试"><a href="#2022-1-15-模拟与数字电路期末考试" class="headerlink" title="2022.1.15 模拟与数字电路期末考试"></a>2022.1.15 模拟与数字电路期末考试</h2><p>2021.11.11期中考试主要内容：</p><ol><li><p>数字逻辑概论:</p><ol><li>数值转换</li><li>二进制数的算术运算</li></ol></li><li><p>逻辑代数&amp;HDL基础</p><ol><li>反演规则</li><li>对偶规则</li><li>最大项/最小项</li><li>表达式化简<ol><li>直接化简</li><li>卡诺图</li></ol></li><li>逻辑函数表示方法之间的转换<ol><li>真值表</li><li>表达式</li><li>逻辑图</li><li>波形图</li></ol></li></ol></li><li><p>逻辑门电路</p></li><li><p>组合逻辑电路/PLD✨</p></li><li><p>锁存器和触发器✨</p></li><li><p>时序逻辑电路（仅包含同步时序电路）✨</p><p>信号——数字部分；周期性；占空比：高电平占周期的百分比</p></li></ol><h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><h3 id="进制：Binary-Octal-Hexadecimal（0x）"><a href="#进制：Binary-Octal-Hexadecimal（0x）" class="headerlink" title="进制：Binary    Octal    Hexadecimal（0x）"></a>进制：Binary    Octal    Hexadecimal（0x）</h3><p>二进制转换：“误差不大于$2^{-n}$” &lt;=&gt; “精确到小数点第n位”</p><p>第n位“四舍五入”即可</p><p>二进制的算术运算：补码=原码取反+1；补码表示范围$-2^{n-1}~2^{n-1}-1$</p><p>补码转原码：从右往左找到第一个‘1’，将这个1之前的取反，该数字和之后的保持原值即可。</p><script type="math/tex; mode=display">(X+Y)_补=(X)_补+(Y)_补</script><script type="math/tex; mode=display">(X-Y)_补=(X)_补-\overline{(Y)_补}+1</script><p>溢出：运算结果超出补码的表示范围</p><p>​        出现场合：同号相加，异号相减———&gt;判断结果是否正确（是否溢出）：判断计算过程中符号位和次高位的进位情况，当且仅当符号位有进位且次高位无进位时计算结果溢出。</p><p>溢出解决方案—-符号拓展：通过利用两个或多个符号位，初始统一置0或1，最终结果看第一位的状态。</p><h3 id="BCD码（无特殊说明BCD码均指8421码）"><a href="#BCD码（无特殊说明BCD码均指8421码）" class="headerlink" title="BCD码（无特殊说明BCD码均指8421码）"></a><strong>BCD码</strong>（无特殊说明BCD码均指8421码）</h3><p>有权码：8421码，5421码，2421码（数字代表各位的权重）</p><p>无权码：余3码，余3循环码</p><p>余3循环码：（0~9）</p><div class="table-container"><table><thead><tr><th>数值</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>余3循环码</td><td>0010</td><td>0110</td><td>0111</td><td>0101</td><td>0100</td><td>1100</td><td>1101</td><td>1111</td><td>1110</td><td>1010</td></tr></tbody></table></div><h3 id="格雷码"><a href="#格雷码" class="headerlink" title="格雷码"></a>格雷码</h3><p>编码顺序依次变化时，相邻代码有且仅有一位不同，最大和最小之间也差一位，也称循环码（余3循环码也满足该条件）（0~15）</p><p>格雷码——&gt;二进制码转化：从最高位到最低位依次相加</p><div class="table-container"><table><thead><tr><th>数值</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th></tr></thead><tbody><tr><td>格雷码</td><td>0000</td><td>0001</td><td>0011</td><td>0010</td><td>0110</td><td>0111</td><td>0101</td><td>0100</td><td>1100</td><td>1101</td><td>1111</td><td>1110</td><td>1010</td><td>1011</td><td>1001</td><td>1000</td></tr><tr><td>二进制码</td><td>0000</td><td>0001</td><td>0010</td><td>0011</td><td>0100</td><td>0101</td><td>0110</td><td>0111</td><td>1000</td><td>1001</td><td>1010</td><td>1011</td><td>1100</td><td>1101</td><td>1110</td><td>1111</td></tr></tbody></table></div><h3 id="进制转换："><a href="#进制转换：" class="headerlink" title="进制转换："></a>进制转换：</h3><ol><li>任意进制-&gt;十进制：按位权展开后相加<script type="math/tex; mode=display">(N)_R=\sum_{i=-m}^{n-1}k_i*R^i</script></li></ol><p>​        2.十进制-&gt;任意进制：</p><p>​                整数部分：辗转除基取余，先得较低有效位</p><p>​                小数部分：辗转乘积取整，先得最高有效位</p><h2 id="逻辑代数"><a href="#逻辑代数" class="headerlink" title="逻辑代数"></a>逻辑代数</h2><h3 id="基本定律："><a href="#基本定律：" class="headerlink" title="基本定律："></a>基本定律：</h3><ul><li>交换律    A<em> B=B </em>A;    A+B=B+A;</li><li>结合律    A(BC)=(AB)C;     A+(B+C)=(A+B)+C;</li><li>分配律    A(B+C)=AB+AC;     A+BC=(A+B)(A+C);</li><li>吸收律    A+A<em> B=A;     A</em>(A+B)=A;</li><li>反演律    $\overline{A+B}=\overline {A}*\overline {B}$ ;      $\overline{AB}=\overline{A}+\overline{B};$</li></ul><p>代入规则:在任一逻辑恒等式中,若以一个逻辑表达式代替恒等式两边所有出现的某一变量,则所得表达式依然成立.利用该结论可以把上述定律推广到n元的情况,即反演律可以写成:</p><script type="math/tex; mode=display">\overline{A_1*A_2*...*A_n}=\overline{A_1}+\overline{A_2}+...+\overline{A_n}</script><script type="math/tex; mode=display">\overline{A_1+A_2+...+A_n}=\overline{A_1}*\overline{A_2}*...*\overline{A_n}</script><h3 id="反演和对偶"><a href="#反演和对偶" class="headerlink" title="反演和对偶"></a>反演和对偶</h3><p>反演规则:对于任意表达式Y,将所有表达式中的’*’和’+’互换,将所有的’0’与’1’互换,把逻辑变量取反.</p><p>对偶规则:对于任意表达式Y,将所有表达式中的’*’和’+’互换,但不改变所有的’0’与’1’互换和逻辑变量.</p><p>利用对偶规则可以对上述基本定律进行拓展.</p><h3 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h3><p>对于一个逻辑函数,有多个逻辑表达式:(下以/AB+A/C为例)</p><ul><li>与或式——-$\overline {AB}+A\overline C;$</li><li>或与式———$(A+\overline B)*(\overline A+C)$</li><li>与非-与非式———$\overline {\overline{\overline AB}\ \ \overline {A\overline C}}$————-最简与或式求两次反</li><li>或非-或非式———$\overline {(\overline A+B)+(\overline A+\overline C)}$———最简或与式求两次反</li><li>与或非式———$\overline {\overline A\ \overline B+AC}$—————先求/Y的最简与或式,然后求反</li></ul><h3 id="最小项与最大项"><a href="#最小项与最大项" class="headerlink" title="最小项与最大项"></a>最小项与最大项</h3><p><strong>最小项</strong>:包含全部输入变量的乘积项,每个变量均以自身变量或反变量出现一次.对于n变量逻辑函数,共有2^n个最小项,记为mi,其中i为最小项的编号[1].</p><p>[1]编号:编号方法:原变量和反变量分别带表1和0,带入逻辑表达式得到的二进制数对应的十进制数记为编号i.</p><p>对于任意一个最小项,有且仅有一组变量使得mi=1成立,且对于不同的i,对应不同的变量;</p><p>全体最小项的并恒等于1;</p><p>任意两个最小项的交恒等于0;</p><p><strong>最大项</strong>:包含全部输入变量的或项,每个变量均以自身变量或反变量出现一次.对于n变量逻辑函数,共有2^n个最大项,记为Mi,其中i为最大项的编号[2].</p><p>[2]编号:编号方法:原变量和反变量分别带表1和0,带入逻辑表达式得到的二进制数取反对应的十进制数记为编号i.</p><p>性质可以和最小项类似</p><p>最大项和最小项的关系:</p><script type="math/tex; mode=display">\overline{M_i}=m_i;   M_i=\overline{m_i}</script><h3 id="卡诺图"><a href="#卡诺图" class="headerlink" title="卡诺图"></a>卡诺图</h3><p>卡诺图通常用在逻辑变量在5以内的情况.</p><p>卡诺图物理上相邻的逻辑变量在逻辑上相邻(上下相邻,左右相邻,,循环相邻,对角不相邻)——-循环码</p><p>无关项x:不允许或不可能出现的最小项/对应的函数值是任意值.</p><p><strong><strong><em>卡诺图化简逻辑表达式</em></strong></strong></p><p><strong>规范作图：</strong></p><ul><li><strong>00 01 11 10顺序</strong></li><li><strong>注明各个逻辑变量名称</strong></li><li><strong>画圈标记—-写对应表达式</strong> </li><li><strong>最简或与式——圈0取反</strong></li><li><strong>圈0取反后不一定是原问题的最简与或式.</strong>(?)</li></ul><h2 id="逻辑门电路"><a href="#逻辑门电路" class="headerlink" title="逻辑门电路"></a>逻辑门电路</h2><p>PMOS:高电平不导通,低电平导通.不能接地</p><p>NMOS:高电平导通,低电平不导通,不能接高电平</p><p>非门:2个CMOS;与非门/或非门:4个CMOS;与门/或门:6个COMS</p><h2 id="组合逻辑电路"><a href="#组合逻辑电路" class="headerlink" title="组合逻辑电路"></a>组合逻辑电路</h2><p>定义:对于一个逻辑电路,在任何一个时刻的输出状态只与输入状态有关,与电路自身状态无关.</p><p>电路功能分析思路:</p><ol><li>根据输入输出写出各级逻辑表达式,直到输入和输出信号的逻辑表达式;</li><li>将各个逻辑表达式化简和变换得到最简表达式;</li><li>根据表达式列出真值表;</li><li>根据真值表和最简逻辑表达式对组合逻辑电路进行分析,最后确定其功能.</li></ol><p>组合逻辑电路设计过程</p><ol><li>明确实际问题的逻辑功能,确定输入输出和表示符号;</li><li>根据对电路逻辑功能的要求写出真值表;</li><li>利用真值表得出逻辑表达式并进程化简变换;(卡诺图)</li><li>利用得到的逻辑表达式画出电路图.</li></ol><p>画波形图要点:    画出原题的波形,画出时钟信号的边缘的虚线…</p><h3 id="典型组合逻辑电路"><a href="#典型组合逻辑电路" class="headerlink" title="典型组合逻辑电路"></a>典型组合逻辑电路</h3><h4 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a><strong>编码器</strong></h4><p>优先编码器CD4532:        8信号输入3信号输出;    输入输出均以高电平有效;    EI/EO:输入/输出使能端,均高电平有效,否则输出端均为低电平,EI为低电平时GS,EO必定是低电平, EI是1且输入均为低电平时EO输出为1,可以用于连接下一编码器的使能输入端````````````    ;    GS:编码工作状态:EI是一且至少有一个高电平输入(表明正在工作)时为1;    优先级:I7&gt;I6&gt;…&gt;I0.</p><h4 id="译码器"><a href="#译码器" class="headerlink" title="译码器"></a><strong>译码器</strong></h4><p>74x138/74x139        输入输出低电平有效        E_3高电平有效</p><p><img src="https://bkimg.cdn.bcebos.com/pic/e61190ef76c6a7eff649c979fdfaaf51f3de6605?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5/format,f_auto" alt="img" style="zoom:70%;"></p><h4 id="数据分配器"><a href="#数据分配器" class="headerlink" title="数据分配器"></a><strong>数据分配器</strong></h4><h4 id="数据选择器"><a href="#数据选择器" class="headerlink" title="数据选择器"></a><strong>数据选择器</strong></h4><h4 id="数值比较器"><a href="#数值比较器" class="headerlink" title="数值比较器"></a><strong>数值比较器</strong></h4><h4 id="基本算术电路"><a href="#基本算术电路" class="headerlink" title="基本算术电路"></a><strong>基本算术电路</strong></h4><ul><li><strong>半加器</strong></li><li><strong>全加器</strong></li><li><strong>多位数加法器(串行进位加法器/超前进位加法器)</strong></li></ul><h3 id="PLD"><a href="#PLD" class="headerlink" title="PLD"></a>PLD</h3><p>分类</p><ul><li>PROM 或阵列可编程逻辑</li><li>PLA 与或阵列均可编程逻辑</li><li>PAL与阵列可编程逻辑</li></ul><h2 id="锁存器和触发器"><a href="#锁存器和触发器" class="headerlink" title="锁存器和触发器"></a>锁存器和触发器</h2><p>细节:</p><ul><li>相对于锁存器,触发器的不同在于沿时钟边沿触发</li><li>画图时时钟信号小三角;上升沿一般用CP表示;下降沿/CP;有圆圈通常表示下降沿触发.</li></ul><p>激励方程:</p><script type="math/tex; mode=display">SR ff:Q^{n+1}=S+\overline RQ^n(SR=0)</script><script type="math/tex; mode=display">Dff: Q^{n+1}=D</script><script type="math/tex; mode=display">JKff:Q^{n+1}=J\overline {Q^n}+\overline KQ^n</script><h2 id="时序逻辑电路"><a href="#时序逻辑电路" class="headerlink" title="时序逻辑电路"></a>时序逻辑电路</h2><h3 id="时序逻辑电路分析"><a href="#时序逻辑电路分析" class="headerlink" title="时序逻辑电路分析"></a>时序逻辑电路分析</h3><p>Mealy型:输出是当前状态和输入的函数</p><p>Moore型:输出是当前状态的函数</p><p>分析思路</p><ol><li>根据逻辑图写出逻辑方程<ol><li>输出方程(判断Mealy/Moore)</li><li>激励方程:每个触发器的输入驱动方程(J/K=…)</li><li>状态方程:激励方程代入触发器的特征方程得到(Q(n-1)=…)</li></ol></li><li>列出状态表_根据mealy/moore型画出对应的表——-&gt;画出状态图(图例!)/时序图</li><li>最后确定电路的逻辑功能</li></ol><h3 id="时序逻辑电路设计"><a href="#时序逻辑电路设计" class="headerlink" title="时序逻辑电路设计"></a>时序逻辑电路设计</h3><ol><li><p>给定逻辑功能的要求（文字描述或者是波形图），</p></li><li><p>求相应的逻辑电路</p></li><li><p>设计的一般步骤</p></li><li><p>建立原始状态图（状态可以用易懂或易写的方式表示）和原始状态表</p></li><li><p>状态化简（在面对同输入得到同输出和同次态NS的现</p><p>Q    态是等价的)</p></li><li><p>状态编码</p></li><li><p>求状态方程和输出方程</p></li><li><p>检查自启动</p></li><li><p>选择触发器类型，求激励方程（激励表或其他方法）</p></li><li><p>画出逻辑图</p></li><li><p>尽量要求自己设计同步时序电路，因为后面在写verilog的时候一般都用统一的时钟</p></li><li><p>另外异步时序电路输出信号质量差，工作速度低</p></li></ol><p>以上内容为期中考试主要内容，其中的逻辑电路分析和设计的重难点在期末考试中仍会涉及</p><hr><p>期末考试额外的内容：</p><ol><li>数字系统设计<ol><li>数字系统结构</li><li>算术逻辑单元</li><li>寄存器传送</li><li>具体问题求解：最大值/排序/乘法电路</li></ol></li><li>Verilog HDL</li><li>Timing Analysis &amp; Synchronization</li><li>存储器，PLD，ListProcessor</li><li>二极管</li><li>三极管</li><li>基本放大电路</li><li>集成运放</li><li>逻辑门电路</li><li>ADC和DAC</li></ol><h2 id="Verilog-HDL-FSM"><a href="#Verilog-HDL-FSM" class="headerlink" title="Verilog  HDL/FSM"></a>Verilog  HDL/FSM</h2><p>常量表示形式：</p><p>整数型&lt;+/-&gt;&lt;位宽&gt;’&lt;基数符号(D/d,B/b,O/o,H/h)&gt;&lt;数值&gt;</p><p>实数型：1·科学计数法            2·十进制计数法</p><p>符号常量定义 <code>parameter</code></p><p>数据变量类型： <code>net(wire)</code> <code>register(reg)</code></p><p>定义格式： <code>wire/reg [MSB/LSB] r1,r2,...</code></p><p>赋值语句：连续赋值语句<code>assign</code>；过程块赋值<code>inital/always</code></p><p>常用语法（过程块赋值内）<code>case/if else/begin end</code></p><p><code>模块实例化</code>1.位置映射modulename M(A,B,C)；2.名称映射modulename M(.A(a),.C(c),.B(b))——不可混用</p><p>运算符</p><ol><li>算术运算符 逐位计算</li><li>关系运算符</li><li>位运算符：~ ,&amp;,^ , | , ^~ / ~^（同或）</li><li>逻辑运算符：&amp;&amp;，！，||</li><li>位拼接符：{, , }   {n{}}</li><li>移位运算符：&gt;&gt;,&lt;&lt;,&gt;&gt;&gt;(算数右移)</li><li>缩位运算符（单目运算符）：&amp;，~&amp;，| ，~|，^, ^~, ~ ^</li><li>条件运算符：？：</li></ol><p>运算符优先级= =</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token punctuation">(</span><span class="token keyword">input</span> i<span class="token punctuation">,</span><span class="token keyword">output</span> o<span class="token punctuation">,</span><span class="token keyword">inout</span> io<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">wire</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>   <span class="token keyword">parameter</span> M<span class="token operator">=</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>   <span class="token keyword">reg</span> <span class="token punctuation">[</span>M<span class="token punctuation">:</span>m<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>   <span class="token keyword">assign</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>   modulename <span class="token function">name</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">initial</span>      <span class="token keyword">begin</span>      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>   <span class="token keyword">end</span>   <span class="token important">always @</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>      <span class="token keyword">begin</span>         <span class="token keyword">if</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>         <span class="token keyword">else</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>         <span class="token keyword">case</span> <span class="token punctuation">(</span>敏感表达式<span class="token punctuation">)</span>            <span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>            <span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token keyword">default</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>         <span class="token keyword">endcase</span>      <span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用if/case语句时应该避免出现锁存器。</p><p>组合逻辑：阻塞赋值（blocking） ：‘=’块内赋值语句顺序执行</p><p>时序逻辑：非阻塞赋值（non-locking）：‘&lt;=’块内赋值语句并发进行</p><p><code>FSM</code></p><p>一段式/两段式/三段式</p><p>CS：现态；NS：次态；OUT：输出</p><p>两段式：一个时序过程描述CS，另一个组合描述NS和OUT</p><p>三段式：两个时序描述CS和OUT，一个组合过程描述NS</p><h2 id="时序逻辑电路2"><a href="#时序逻辑电路2" class="headerlink" title="时序逻辑电路2"></a>时序逻辑电路2</h2><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>寄存器是若干具有相同外观电路结构的共享时钟和控制信号的触发器</p><p>普通寄存器/<code>移位寄存器</code></p><p>74x194:双向通用移位寄存器</p><p><img src="C:\Users\李\AppData\Roaming\Typora\typora-user-images\image-20211231173423377.png" alt="image-20211231173423377" style="zoom:50%;"></p><p>功能表：<img src="C:\Users\李\AppData\Roaming\Typora\typora-user-images\image-20211231173453305.png" alt="image-20211231173453305" style="zoom:57%;"></p><p>不添加其他逻辑门即可实现位拓展</p><p>应用：实现序列检测</p><h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>累计时钟脉冲次数，可以用来分频，定时，产生节拍脉冲</p><p><code>模</code>：循环遍历的有效状态数</p><p>异步递增计数器：电路简单，易于拓展，但工作效率低，不适用</p><p>同步递增计数器：<img src="C:\Users\李\AppData\Roaming\Typora\typora-user-images\image-20211231175954622.png" alt="image-20211231175954622" style="zoom:47%;"></p><p>74x161</p><p><img src="C:\Users\李\AppData\Roaming\Typora\typora-user-images\image-20211231180035128.png" alt="image-20211231180035128" style="zoom:50%;"></p><p>74x160:模10计数器，与74x161相似</p><p><code>任意进制计数器构成</code></p><p>•用N进制计数器构成 M 进制计数器</p><p>•若 M &lt; N ，可在计数过程中设法跳过 N-M 个多余状态</p><p>​    –反馈清零法，简称清零法</p><p>​    –反馈置数法，简称置数法</p><p>•若 M &gt; N ，用多片 N 进制计数器级连，配合清零 / 置数法构成</p><p><code>要注意同步清零和异步清零清零时的数值是不一致的，通常同步+1=异步，置数同理</code>——可以画状态图，异步的临界状态可以画虚线</p><p><code>用移位寄存器实现计数器</code>，如环形计数器：将串行输入与串行输出直接相连，计数状态等于寄存器的位数。</p><p>扭环型计数器：约翰孙计数器，计数状态是环形计数器的2倍</p><p>有效循环：每次状态转换只更改一位</p><p><img src="C:\Users\李\AppData\Roaming\Typora\typora-user-images\image-20211231182730747.png" alt="image-20211231182730747" style="zoom:57%;"></p><h3 id="数字系统"><a href="#数字系统" class="headerlink" title="数字系统"></a>数字系统</h3><p>开关去抖动</p><p>数字系统组成：Data Path+Control Unit</p><p><img src="C:\Users\李\AppData\Roaming\Typora\typora-user-images\image-20211231175222600.png" alt="image-20211231175222600" style="zoom:67%;"></p><p>实例：时序二进制乘法器，求最大值，排序</p><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;模拟与数字电路&quot;&gt;&lt;a href=&quot;#模拟与数字电路&quot; class=&quot;headerlink&quot; title=&quot;模拟与数字电路&quot;&gt;&lt;/a&gt;模拟与数字电路&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;2022-1-15-模拟与数字电路期末考试&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="数字电路" scheme="http://sn1987a-1.github.io/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
    
    <category term="专业课" scheme="http://sn1987a-1.github.io/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    <category term="模拟与数字电路" scheme="http://sn1987a-1.github.io/tags/%E6%A8%A1%E6%8B%9F%E4%B8%8E%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>线性筛的理解和应用</title>
    <link href="http://sn1987a-1.github.io/posts/15547.html"/>
    <id>http://sn1987a-1.github.io/posts/15547.html</id>
    <published>2021-10-24T15:43:35.000Z</published>
    <updated>2022-02-26T07:11:32.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性筛的理解和应用"><a href="#线性筛的理解和应用" class="headerlink" title="线性筛的理解和应用"></a>线性筛的理解和应用</h1><p>最近在准备相关算法竞赛，正好班里有写博客的活动，就在此记录下自己菜不成声学习的过程。&gt;v&lt;</p><p>为算出小于等于n的素数的个数，较自然也是最暴力的的方法便是对每个小于n的正整数进行判定，这样的方法显然达到最优的复杂度，暴力硬解的结果无疑是最终喜提“Time Limit Exceeded”。</p><p>为提高算法效率，就要引入“筛”的思想——主要思想是：我们选出一个数n时无论n是素数还是合数，2n,3n,..都是合数，我们无需对这类数进行是否为素数的判断。</p><h2 id="Eratosthenes-筛法-（埃拉托斯特尼筛法，简称埃氏筛）"><a href="#Eratosthenes-筛法-（埃拉托斯特尼筛法，简称埃氏筛）" class="headerlink" title="Eratosthenes 筛法 （埃拉托斯特尼筛法，简称埃氏筛）"></a><strong>Eratosthenes 筛法</strong> （埃拉托斯特尼筛法，简称埃氏筛）</h2><p>埃氏筛算法的主要思想是：如果我们从小到大考虑每个数，然后同时把当前这个数的所有（比自己大的）倍数记为合数，那么运行结束的时候没有被标记的数就是素数了。具体算法如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">Eratosthenes</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> is_prime<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  is_prime<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> is_prime<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>is_prime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      prime<span class="token punctuation">[</span>p<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>  <span class="token comment">// prime[p]是i,后置自增运算代表当前素数数量</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">*</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>           j <span class="token operator">+=</span> i<span class="token punctuation">)</span>  <span class="token comment">// 因为从 2 到 i - 1 的倍数我们之前筛过了，这里直接从 i</span>                    <span class="token comment">// 的倍数开始，提高了运行速度</span>        is_prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">//是i的倍数的均不是素数</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>埃氏筛通常可以称为普通筛，结构比较简单，也比较容易理解，其核心就是对找到的素数的倍数通过一次循环进行标记，虽然要额外占用O(n)的内存空间保存标记，但非常高效地减少了程序复杂度。</p><p>我们应该注意到，埃氏筛在对数字进行标记筛选时，存在重复筛选，比如6既可以被2筛掉，又可以被3筛掉。原因：任意一个整数可以写成一些素数的乘积 </p><script type="math/tex; mode=display">n=p1^ip2^jp3^k</script><p>其中p1&lt;p2&lt;p3，这样这个数n能被p1,p2和p3筛掉,反复被标记，尤其在n比较大的时候，n可能有相当多个素因子，被多次标记，显然浪费了时间。</p><h2 id="Euler筛法-线性筛"><a href="#Euler筛法-线性筛" class="headerlink" title="Euler筛法(线性筛)"></a>Euler筛法(线性筛)</h2><p>基于普通筛的不足之处，Euler对其做出了修改——直观地来说，当我们用埃氏筛法对一个素数的n倍进行筛选时，若正在被标记的这个倍数已经足够大，大到超过一特定的数字后，那这个数一定有更大的素因子，能在后续过程中再次被标记，此时就可以停止循环，算法继续对下一个未标记的数进行是否为素数的判断。</p><p>通过观察不难发现，若当前正在处理n的i倍数in，i能整除n，那么i与下一个要进行筛选的数的乘积这个合数肯定会被n乘以某个数提前筛掉。因此这里的i便是我们要找的“特定的数字”，利用这一数字提前break掉循环，可以使得每个数字均被筛选一次，将时间复杂度降到最低，这也就是Euler筛的算法思想，实现代码如下所示。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  phi<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAXN<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      phi<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>      pri<span class="token punctuation">[</span>cnt<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> cnt<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">1ll</span> <span class="token operator">*</span> i <span class="token operator">*</span> pri<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> MAXN<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>      vis<span class="token punctuation">[</span>i <span class="token operator">*</span> pri<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> pri<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        phi<span class="token punctuation">[</span>i <span class="token operator">*</span> pri<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> phi<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>pri<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment">// i % pri[j] == 0</span>        <span class="token comment">// 换言之，i 之前被 pri[j] 筛过了</span>        <span class="token comment">// 由于 pri 里面质数是从小到大的，所以 i 乘上其他的质数的结果一定会被</span>        <span class="token comment">// pri[j] 的倍数筛掉，就不需要在这里先筛一次，所以这里直接 break</span>        <span class="token comment">// 掉就好了</span>        phi<span class="token punctuation">[</span>i <span class="token operator">*</span> pri<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> phi<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> pri<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关键之处在：if(i%prime[j]==0) break;</p><p>这句代码保证了每个数最多被筛一次，将时间复杂度降到了线性。</p><p>证：prime[]数组中的素数是递增的,当i能整除prime[j]，那么i<em>prime[j+1]这个合数肯定会被prime[j]乘以某个数筛掉。因此，这里直接break掉，将i</em>prime[j+1]及之后的给后面的数去筛。这种方法能保证每个数只被筛一遍，又能保证每个数都被筛到。</p><p>为了更好的理解，画出前面几次筛的情况:</p><p><img src="C:\Users\李\AppData\Roaming\Typora\typora-user-images\image-20211029190053110.png" alt="image-20211029190053110"></p><p>一般来说，当筛选范围n较小时，埃氏筛和欧氏筛复杂度较相近，甚至埃氏筛表现更好，但随着n的增大，欧氏筛的优越性也逐渐体现出来，可以达到埃氏筛3-4倍的速度。</p><p>参考：</p><p>1.<a href="https://www.cnblogs.com/lfri/p/11679306.html">线性筛的理解及应用 - Rogn - 博客园 (cnblogs.com)</a></p><p>2.<a href="https://blog.csdn.net/qq_41653433/article/details/88976544">线性筛<em>历尽千帆-CSDN博客</em>线性筛</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线性筛的理解和应用&quot;&gt;&lt;a href=&quot;#线性筛的理解和应用&quot; class=&quot;headerlink&quot; title=&quot;线性筛的理解和应用&quot;&gt;&lt;/a&gt;线性筛的理解和应用&lt;/h1&gt;&lt;p&gt;最近在准备相关算法竞赛，正好班里有写博客的活动，就在此记录下自己菜不成声学习的过程。</summary>
      
    
    
    
    <category term="算法" scheme="http://sn1987a-1.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="practice" scheme="http://sn1987a-1.github.io/categories/%E7%AE%97%E6%B3%95/practice/"/>
    
    
    <category term="线性筛" scheme="http://sn1987a-1.github.io/tags/%E7%BA%BF%E6%80%A7%E7%AD%9B/"/>
    
    <category term="算法" scheme="http://sn1987a-1.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
