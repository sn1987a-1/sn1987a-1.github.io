<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SN1987A</title>
  
  <subtitle>LAYのBLOG</subtitle>
  <link href="http://sn1987a-1.github.io/atom.xml" rel="self"/>
  
  <link href="http://sn1987a-1.github.io/"/>
  <updated>2023-09-23T13:05:25.832Z</updated>
  <id>http://sn1987a-1.github.io/</id>
  
  <author>
    <name>SN1987A</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Gin框架</title>
    <link href="http://sn1987a-1.github.io/posts/6d104c29.html"/>
    <id>http://sn1987a-1.github.io/posts/6d104c29.html</id>
    <published>2023-09-23T12:48:34.000Z</published>
    <updated>2023-09-23T13:05:25.832Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GoWeb"><a href="#GoWeb" class="headerlink" title="GoWeb"></a>GoWeb</h2><p>官方包<code>net/http</code>提供了基础的路由函数组合和功能函数，无需API</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">echo</span><span class="token punctuation">(</span>wr http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    msg<span class="token punctuation">,</span> err <span class="token operator">:=</span> ioutil<span class="token punctuation">.</span><span class="token function">ReadAll</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>Body<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        wr<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"echo error"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    writeLen<span class="token punctuation">,</span> err <span class="token operator">:=</span> wr<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">||</span> writeLen <span class="token operator">!=</span> <span class="token function">len</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> <span class="token string">"write len:"</span><span class="token punctuation">,</span> writeLen<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> echo<span class="token punctuation">)</span>    err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">":8080"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>框架类型</p><ul><li>Router</li><li>MVC</li></ul><h2 id="Gin"><a href="#Gin" class="headerlink" title="Gin"></a>Gin</h2><p><a href="https://github.com/gin-gonic/gin">Gin</a></p><h3 id="Gin路由"><a href="#Gin路由" class="headerlink" title="Gin路由"></a>Gin路由</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 创建一个 Gin 路由</span>    r <span class="token operator">:=</span> gin<span class="token punctuation">.</span><span class="token function">Default</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// 设置一个路由处理器，处理根路径 "/"</span>    r<span class="token punctuation">.</span><span class="token function">GET</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 发送 "Hello, World!" 作为响应</span>        c<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusOK<span class="token punctuation">,</span> <span class="token string">"Hello, World!"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token comment">// 在端口 8000 上启动 Web 服务器</span>    r<span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token string">":8000"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类似地</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">r<span class="token punctuation">.</span><span class="token function">POST</span><span class="token punctuation">(</span><span class="token string">"/xxxpost"</span><span class="token punctuation">,</span>getting<span class="token punctuation">)</span>r<span class="token punctuation">.</span><span class="token function">PUT</span><span class="token punctuation">(</span><span class="token string">"/xxxput"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>支持Restful风格API，（表现层状态转化），是一种互联网应用程序的API设计理念：URL定位资源，用HTTP描述操作</p><pre class="line-numbers language-none"><code class="language-none">1.获取文章 /blog/getXxx Get blog/Xxx2.添加 /blog/addXxx POST blog/Xxx3.修改 /blog/updateXxx PUT blog/Xxx4.删除 /blog/delXxxx DELETE blog/Xxx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>API参数</strong>：可以通过context地Param方法获取API参数</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">r<span class="token punctuation">.</span><span class="token function">GET</span><span class="token punctuation">(</span><span class="token string">"/user/:name/*action"</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">{</span>       name <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">Param</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span>       action <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">Param</span><span class="token punctuation">(</span><span class="token string">"action"</span><span class="token punctuation">)</span>       action <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">Trim</span><span class="token punctuation">(</span>action<span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">)</span>       c<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusOK<span class="token punctuation">,</span> name<span class="token operator">+</span><span class="token string">" is "</span><span class="token operator">+</span>action<span class="token punctuation">)</span>   <span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>URL参数</strong>：可以通过DefaultQuery()（参数不存在，返回<em>默认值</em>）或Query()（参数不存在，返回空串）方法获取</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">name <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">DefaultQuery</span><span class="token punctuation">(</span><span class="token string">"xx"</span><span class="token punctuation">,</span><span class="token string">"默认值"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>表单参数</strong>表单参数是post请求，通过PostForm获取</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">types <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">DefaultPostForm</span><span class="token punctuation">(</span><span class="token string">"type"</span><span class="token punctuation">,</span> <span class="token string">"post"</span><span class="token punctuation">)</span>username <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">PostForm</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span>password <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">PostForm</span><span class="token punctuation">(</span><span class="token string">"userpassword"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://localhost:8080/form<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>application/x-www-form-urlencoded<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>用户名：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>请输入你的用户名<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span> 密<span class="token entity named-entity" title="&nbsp;">&amp;nbsp;</span><span class="token entity named-entity" title="&nbsp;">&amp;nbsp;</span><span class="token entity named-entity" title="&nbsp;">&amp;nbsp;</span>码：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userpassword<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>请输入你的密码<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>提交<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>上传文件</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">file<span class="token punctuation">,</span> err <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">FormFile</span><span class="token punctuation">(</span><span class="token string">"file"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        c<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token string">"上传图片出错"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>c<span class="token punctuation">.</span><span class="token function">SaveUploadedFile</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> file<span class="token punctuation">.</span>Filename<span class="token punctuation">)</span>c<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusOK<span class="token punctuation">,</span> file<span class="token punctuation">.</span>Filename<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于上传的文件，可以限制文件类型，文件大小</p><p>也可以上传多个文件，获取所有的文件，再遍历文件，逐个处理（html的multiple）</p><p><strong>routes group</strong> 管理相同的URL</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">v1 <span class="token operator">:=</span> r<span class="token punctuation">.</span><span class="token function">Group</span><span class="token punctuation">(</span><span class="token string">"/v1"</span><span class="token punctuation">)</span>   <span class="token comment">// {} 是书写规范</span>   <span class="token punctuation">{</span>      v1<span class="token punctuation">.</span><span class="token function">GET</span><span class="token punctuation">(</span><span class="token string">"/login"</span><span class="token punctuation">,</span> login<span class="token punctuation">)</span>      v1<span class="token punctuation">.</span><span class="token function">GET</span><span class="token punctuation">(</span><span class="token string">"/submit"</span><span class="token punctuation">,</span> submit<span class="token punctuation">)</span>   <span class="token punctuation">}</span>v2<span class="token operator">...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>路由原理：httprouter会将所有路由规则构造成前缀树</p><p>URI包含URL和URN</p><ul><li>url用来标识资源的位置</li><li>urn用来标识资源的名称，不含位置信息</li><li>uri数据指的是URI的字符串表示形式</li></ul><h3 id="gin数据解析和绑定"><a href="#gin数据解析和绑定" class="headerlink" title="gin数据解析和绑定"></a>gin数据解析和绑定</h3><p><strong>json数据</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Login <span class="token keyword">struct</span> <span class="token punctuation">{</span>   <span class="token comment">// binding:"required"修饰的字段，若接收为空值，则报错，是必须字段</span>   User    <span class="token builtin">string</span> <span class="token string">`form:"username" json:"user" uri:"user" xml:"user" binding:"required"`</span>   Pssword <span class="token builtin">string</span> <span class="token string">`form:"password" json:"password" uri:"password" xml:"password" binding:"required"`</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> json Login<span class="token comment">// 将request的body中的数据，自动按照json格式解析到结构体</span><span class="token keyword">if</span> err <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">ShouldBindJSON</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>    <span class="token comment">// 返回错误信息</span>    <span class="token comment">// gin.H封装了生成json数据的工具</span>    c<span class="token punctuation">.</span><span class="token function">JSON</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusBadRequest<span class="token punctuation">,</span> gin<span class="token punctuation">.</span>H<span class="token punctuation">{</span><span class="token string">"error"</span><span class="token punctuation">:</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">return</span><span class="token punctuation">}</span><span class="token comment">// 判断用户名密码是否正确</span><span class="token keyword">if</span> json<span class="token punctuation">.</span>User <span class="token operator">!=</span> <span class="token string">"root"</span> <span class="token operator">||</span> json<span class="token punctuation">.</span>Pssword <span class="token operator">!=</span> <span class="token string">"admin"</span> <span class="token punctuation">{</span>    c<span class="token punctuation">.</span><span class="token function">JSON</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusBadRequest<span class="token punctuation">,</span> gin<span class="token punctuation">.</span>H<span class="token punctuation">{</span><span class="token string">"status"</span><span class="token punctuation">:</span> <span class="token string">"304"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">return</span><span class="token punctuation">}</span>c<span class="token punctuation">.</span><span class="token function">JSON</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusOK<span class="token punctuation">,</span> gin<span class="token punctuation">.</span>H<span class="token punctuation">{</span><span class="token string">"status"</span><span class="token punctuation">:</span> <span class="token string">"200"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>表单数据</strong>，类似于json数据，只需修改解析的函数，使用bind()默认解析到form的格式</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> form Login<span class="token comment">// Bind()默认解析并绑定form格式</span><span class="token comment">// 根据请求头中content-type自动推断</span><span class="token keyword">if</span> err <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">Bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>form<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>URI数据</strong></p><p>URI数据的get函数参数<code>"/:user/:password"</code>以便标识</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> err <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">ShouldBindUri</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>login<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token operator">...</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="gin渲染"><a href="#gin渲染" class="headerlink" title="gin渲染"></a>gin渲染</h3><p>JSON，XML，YAML，结构体</p><p><code>r.get("/someXML")</code>(替换成someStruct/someYAML/someJSON)，用<code>c.XML...</code>接收（struct格式需要处理msg格式，用c.JSON接收）</p><p><strong>HTML模板渲染</strong></p><p>在r.GET之前调用<code>r.LoadHTMLGlob("tem/**/*")</code>(具体根据目录来定)</p><p>HTML首尾分离</p><p>首：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">{{define "public/header"}}<span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ie=edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>{{.title}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>{{end}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>尾：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">{{define "public/footer"}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>{{ end }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>index文件：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">{{ define "user/index.html" }}{{template "public/header" .}}        fgkjdskjdsh{{.address}}{{template "public/footer" .}}{{ end }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>重定向</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">c<span class="token punctuation">.</span><span class="token function">Redirect</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusMovedPermanently<span class="token punctuation">,</span> <span class="token string">"http..."</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>同步和异步处理</strong></p><p>goroutine可以进行异步处理</p><p><em>启动新的goroutine时，不应该使用原始上下文，而是使用只读副本</em></p><pre class="line-numbers language-go" data-language="go"><code class="language-go"> <span class="token comment">// 1.异步</span>r<span class="token punctuation">.</span><span class="token function">GET</span><span class="token punctuation">(</span><span class="token string">"/long_async"</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 需要搞一个副本</span>    copyContext <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">Copy</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// 异步处理</span>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>        log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"异步执行："</span> <span class="token operator">+</span> copyContext<span class="token punctuation">.</span>Request<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Path<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment">// 2.同步</span>r<span class="token punctuation">.</span><span class="token function">GET</span><span class="token punctuation">(</span><span class="token string">"/long_sync"</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>    log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"同步执行："</span> <span class="token operator">+</span> c<span class="token punctuation">.</span>Request<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Path<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="gin中间件"><a href="#gin中间件" class="headerlink" title="gin中间件"></a>gin中间件</h3><p>“默认使用两个中间件：Logger，Recovery”<code>r:=gin.Default()</code></p><p><strong>全局中间件</strong>：所有请求都经过该中间件</p><p>定义中间件：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">MiddleWare</span><span class="token punctuation">(</span><span class="token punctuation">)</span> gin<span class="token punctuation">.</span>HandlerFunc<span class="token punctuation">{</span>    <span class="token comment">//设置变量到Context的key中，可以通过’Get‘获取</span>    c<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"request"</span><span class="token punctuation">,</span><span class="token string">"..."</span><span class="token punctuation">)</span>    <span class="token comment">//获取相关变量</span>    status <span class="token operator">:=</span> c<span class="token punctuation">.</span>Writer<span class="token punctuation">.</span><span class="token function">Status</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注册中间件：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">r<span class="token punctuation">.</span><span class="token function">Use</span><span class="token punctuation">(</span><span class="token function">MiddleWare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span><span class="token function">GET</span><span class="token punctuation">(</span><span class="token string">"/ce"</span><span class="token punctuation">,</span><span class="token keyword">func</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>Next()方法</strong>：中间件执行完后续的一些事情，在定义中间件部分写入</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">MiddleWare</span><span class="token punctuation">(</span><span class="token punctuation">)</span> gin<span class="token punctuation">.</span>HandlerFunc <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">{</span>        t <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        c<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"request"</span><span class="token punctuation">,</span> <span class="token string">"中间件"</span><span class="token punctuation">)</span>        c<span class="token punctuation">.</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        status <span class="token operator">:=</span> c<span class="token punctuation">.</span>Writer<span class="token punctuation">.</span><span class="token function">Status</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        t2 <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Since</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"time:"</span><span class="token punctuation">,</span> t2<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对比：</p><p>去掉c.Next()函数：输出的time（时间间隔）为0</p><p>加上c.Next()函数，输出的time不为0，为中间件开始执行到运行结束的时间</p><p><strong>局部中间件</strong></p><p>局部中间件注册的方法：（也可以类似于全局的声明）</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">r<span class="token punctuation">.</span><span class="token function">GET</span><span class="token punctuation">(</span><span class="token string">"/ce"</span><span class="token punctuation">,</span><span class="token function">MiddleWare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">func</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>局部和全局的区别：局部可以针对忒党的路由或路由组生效，在注册前创建路由组：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">authgroup<span class="token operator">:=</span>r<span class="token punctuation">.</span><span class="token function">Group</span><span class="token punctuation">(</span><span class="token string">"/xxx"</span><span class="token punctuation">)</span>authgroup<span class="token punctuation">.</span><span class="token function">USE</span><span class="token punctuation">(</span>MiddleWare<span class="token punctuation">)</span>authgroup<span class="token punctuation">.</span><span class="token function">GET</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="会话控制"><a href="#会话控制" class="headerlink" title="会话控制"></a>会话控制</h3><p>HTTP：无状态协议，HTTP1.1引入cookie解决无状态的方案，Cookie由服务器创建，浏览器保存，每次发送请求给服务器时，发送Cookie</p><p><strong>cookie设置</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">r<span class="token punctuation">.</span><span class="token function">GET</span><span class="token punctuation">(</span><span class="token string">"cookie"</span><span class="token punctuation">,</span><span class="token keyword">func</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span><span class="token punctuation">{</span>    cookie<span class="token punctuation">,</span>err<span class="token operator">=</span>c<span class="token punctuation">.</span><span class="token function">Cookie</span><span class="token punctuation">(</span><span class="token string">"key_cookie"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span><span class="token boolean">nil</span><span class="token punctuation">{</span>        <span class="token comment">//说明cookie未设置</span>        c<span class="token punctuation">.</span><span class="token function">SetCookie</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>借助中间件校验cookie，如果校验失败：返回错误信息并退出</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">c<span class="token punctuation">.</span><span class="token function">JSON</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusUnauthorized<span class="token punctuation">,</span>gin<span class="token punctuation">.</span>H<span class="token punctuation">{</span><span class="token string">"error"</span><span class="token punctuation">:</span><span class="token string">"err"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span><span class="token function">Abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上述cookie的缺点</p><ul><li>不安全，通过明文传输（只有https传输才可以保证安全性）</li><li>可以被禁用</li><li>增加宽带损耗</li><li>cookie有上限</li><li>只在同一域名下的页面之间共享</li></ul><p><strong>Sessions</strong> 主要功能：</p><ul><li>简单的API，可以作为设置签名cookie的简便方法</li><li>内置的后端可以将session存储在cookie的或者文件系统中</li><li>Flash消息：持续读取session</li><li>切换Session的持久性和便捷方法</li><li>旋转身份验证，加密密钥</li><li>每个请求有多个session</li><li>自定义session后端的接口和基础结构，可以通过API减少并批量保存</li></ul><p>sessions的特点</p><ul><li>在服务器存储，存储在服务器的内存或者数据库中</li><li>没有明确的容量限制</li><li>可以持久存在</li><li>客户端无法直接访问你或修改，更安全</li><li>可以解决cookie的跨域问题，更灵活</li><li>通常用来存储敏感数据，如用户的身份验证信息</li></ul><p>sessions相关函数用法：</p><p>保存session（更改）</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">SaveSession</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    session<span class="token punctuation">,</span> err <span class="token operator">:=</span> store<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> <span class="token string">"session-name"</span><span class="token punctuation">)</span>    <span class="token comment">//Get永远会返回一个session，即便是空的session</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        http<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> http<span class="token punctuation">.</span>StatusInternalServerError<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    session<span class="token punctuation">.</span>Values<span class="token punctuation">[</span><span class="token string">"foo"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"bar"</span>    <span class="token operator">...</span>    <span class="token comment">// 保存更改</span>    session<span class="token punctuation">.</span><span class="token function">Save</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>获取session</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">GetSession</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    session<span class="token punctuation">,</span> err <span class="token operator">:=</span> store<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> <span class="token string">"session-name"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        http<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> http<span class="token punctuation">.</span>StatusInternalServerError<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    foo <span class="token operator">:=</span> session<span class="token punctuation">.</span>Values<span class="token punctuation">[</span><span class="token string">"foo"</span><span class="token punctuation">]</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>删除session: 将session的最大存储时间设置为小于零的数即为删除</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">session<span class="token punctuation">.</span>Options<span class="token punctuation">.</span>MaxAge <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>session<span class="token punctuation">.</span><span class="token function">Save</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="参数验证"><a href="#参数验证" class="headerlink" title="参数验证"></a>参数验证</h3><p><strong>结构体验证</strong>：GIN框架进行数据验证，无需解析数据，更简洁</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> person Person<span class="token keyword">if</span> err <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">ShouldBind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>    c<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span> fmt<span class="token punctuation">.</span><span class="token function">Sprint</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span><span class="token punctuation">}</span>c<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%#v"</span><span class="token punctuation">,</span> person<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果需要添加自定义验证：</p><ul><li><p>首先，要在struct中限制：form，binding等（用``）</p></li><li><p>自定义校验方法（如限制字段不为空，不等于admin）</p></li><li><p>注册校验方法</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">v<span class="token operator">:=</span>binding<span class="token punctuation">.</span>Validator<span class="token punctuation">.</span><span class="token function">Engine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>validator<span class="token punctuation">.</span>Validate<span class="token punctuation">)</span>v<span class="token punctuation">.</span><span class="token function">RegisterValidation</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span>func_name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>再用ShouldBind进行校验</p></li></ul><p><strong>多语言翻译验证</strong></p><p>当业务系统对验证信息有特殊需求时，例如：返回信息需要自定义，手机端返回的信息需要是中文而pc端返回的信息需要时英文，如何做到请求一个接口满足上述三种情况。</p><p>借助中间件实现。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">startPage</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//这部分应放到中间件中</span>    locale <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">DefaultQuery</span><span class="token punctuation">(</span><span class="token string">"locale"</span><span class="token punctuation">,</span> <span class="token string">"zh"</span><span class="token punctuation">)</span>    trans<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> Uni<span class="token punctuation">.</span><span class="token function">GetTranslator</span><span class="token punctuation">(</span>locale<span class="token punctuation">)</span>    <span class="token keyword">switch</span> locale <span class="token punctuation">{</span>  <span class="token operator">...</span>        <span class="token keyword">break</span>    <span class="token punctuation">}</span>    <span class="token comment">//自定义错误内容</span>    Validate<span class="token punctuation">.</span><span class="token function">RegisterTranslation</span><span class="token punctuation">(</span><span class="token string">"required"</span><span class="token punctuation">,</span> trans<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span>ut ut<span class="token punctuation">.</span>Translator<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> ut<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token string">"required"</span><span class="token punctuation">,</span> <span class="token string">"{0} must have a value!"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment">// see universal-translator for details</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span>ut ut<span class="token punctuation">.</span>Translator<span class="token punctuation">,</span> fe validator<span class="token punctuation">.</span>FieldError<span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>        t<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> ut<span class="token punctuation">.</span><span class="token function">T</span><span class="token punctuation">(</span><span class="token string">"required"</span><span class="token punctuation">,</span> fe<span class="token punctuation">.</span><span class="token function">Field</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> t    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token comment">//这块应该放到公共验证方法中</span>    user <span class="token operator">:=</span> User<span class="token punctuation">{</span><span class="token punctuation">}</span>    c<span class="token punctuation">.</span><span class="token function">ShouldBind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>user<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span>    err <span class="token operator">:=</span> Validate<span class="token punctuation">.</span><span class="token function">Struct</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        errs <span class="token operator">:=</span> err<span class="token punctuation">.</span><span class="token punctuation">(</span>validator<span class="token punctuation">.</span>ValidationErrors<span class="token punctuation">)</span>        sliceErrs <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> e <span class="token operator">:=</span> <span class="token keyword">range</span> errs <span class="token punctuation">{</span>            sliceErrs <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>sliceErrs<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">Translate</span><span class="token punctuation">(</span>trans<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        c<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%#v"</span><span class="token punctuation">,</span> sliceErrs<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    c<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%#v"</span><span class="token punctuation">,</span> <span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>验证码库：github.com/dchest/captcha</p></blockquote><p>具体实现：</p><ul><li>生成一个路由，在session里写入键值对k，v，将v加载到图片上，然后生成图片。在浏览器显示</li><li>前端将图片的内容发送给后端，后端根据session中的k取得v，比对校验</li></ul><p>示例代码</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"bytes"</span>    <span class="token string">"github.com/dchest/captcha"</span>    <span class="token string">"github.com/gin-contrib/sessions"</span>    <span class="token string">"github.com/gin-contrib/sessions/cookie"</span>    <span class="token string">"github.com/gin-gonic/gin"</span>    <span class="token string">"net/http"</span>    <span class="token string">"time"</span><span class="token punctuation">)</span><span class="token comment">// 中间件，处理session</span><span class="token keyword">func</span> <span class="token function">Session</span><span class="token punctuation">(</span>keyPairs <span class="token builtin">string</span><span class="token punctuation">)</span> gin<span class="token punctuation">.</span>HandlerFunc <span class="token punctuation">{</span>    store <span class="token operator">:=</span> <span class="token function">SessionConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> sessions<span class="token punctuation">.</span><span class="token function">Sessions</span><span class="token punctuation">(</span>keyPairs<span class="token punctuation">,</span> store<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">SessionConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span> sessions<span class="token punctuation">.</span>Store <span class="token punctuation">{</span>    sessionMaxAge <span class="token operator">:=</span> <span class="token number">3600</span>    sessionSecret <span class="token operator">:=</span> <span class="token string">"topgoer"</span>    <span class="token keyword">var</span> store sessions<span class="token punctuation">.</span>Store    store <span class="token operator">=</span> cookie<span class="token punctuation">.</span><span class="token function">NewStore</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>sessionSecret<span class="token punctuation">)</span><span class="token punctuation">)</span>    store<span class="token punctuation">.</span><span class="token function">Options</span><span class="token punctuation">(</span>sessions<span class="token punctuation">.</span>Options<span class="token punctuation">{</span>        MaxAge<span class="token punctuation">:</span> sessionMaxAge<span class="token punctuation">,</span> <span class="token comment">//seconds</span>        Path<span class="token punctuation">:</span>   <span class="token string">"/"</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> store<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">Captcha</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> length <span class="token operator">...</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    l <span class="token operator">:=</span> captcha<span class="token punctuation">.</span>DefaultLen    w<span class="token punctuation">,</span> h <span class="token operator">:=</span> <span class="token number">107</span><span class="token punctuation">,</span> <span class="token number">36</span>    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">{</span>        l <span class="token operator">=</span> length<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span> <span class="token punctuation">{</span>        w <span class="token operator">=</span> length<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">3</span> <span class="token punctuation">{</span>        h <span class="token operator">=</span> length<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span>    captchaId <span class="token operator">:=</span> captcha<span class="token punctuation">.</span><span class="token function">NewLen</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span>    session <span class="token operator">:=</span> sessions<span class="token punctuation">.</span><span class="token function">Default</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>    session<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"captcha"</span><span class="token punctuation">,</span> captchaId<span class="token punctuation">)</span>    <span class="token boolean">_</span> <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">Save</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token boolean">_</span> <span class="token operator">=</span> <span class="token function">Serve</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>Writer<span class="token punctuation">,</span> c<span class="token punctuation">.</span>Request<span class="token punctuation">,</span> captchaId<span class="token punctuation">,</span> <span class="token string">".png"</span><span class="token punctuation">,</span> <span class="token string">"zh"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> w<span class="token punctuation">,</span> h<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">CaptchaVerify</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> code <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>    session <span class="token operator">:=</span> sessions<span class="token punctuation">.</span><span class="token function">Default</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>    <span class="token keyword">if</span> captchaId <span class="token operator">:=</span> session<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token string">"captcha"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> captchaId <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        session<span class="token punctuation">.</span><span class="token function">Delete</span><span class="token punctuation">(</span><span class="token string">"captcha"</span><span class="token punctuation">)</span>        <span class="token boolean">_</span> <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">Save</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> captcha<span class="token punctuation">.</span><span class="token function">VerifyString</span><span class="token punctuation">(</span>captchaId<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">,</span> code<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">Serve</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">,</span> id<span class="token punctuation">,</span> ext<span class="token punctuation">,</span> lang <span class="token builtin">string</span><span class="token punctuation">,</span> download <span class="token builtin">bool</span><span class="token punctuation">,</span> width<span class="token punctuation">,</span> height <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>    w<span class="token punctuation">.</span><span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"Cache-Control"</span><span class="token punctuation">,</span> <span class="token string">"no-cache, no-store, must-revalidate"</span><span class="token punctuation">)</span>    w<span class="token punctuation">.</span><span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"Pragma"</span><span class="token punctuation">,</span> <span class="token string">"no-cache"</span><span class="token punctuation">)</span>    w<span class="token punctuation">.</span><span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"Expires"</span><span class="token punctuation">,</span> <span class="token string">"0"</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> content bytes<span class="token punctuation">.</span>Buffer    <span class="token keyword">switch</span> ext <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token string">".png"</span><span class="token punctuation">:</span>        w<span class="token punctuation">.</span><span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">,</span> <span class="token string">"image/png"</span><span class="token punctuation">)</span>        <span class="token boolean">_</span> <span class="token operator">=</span> captcha<span class="token punctuation">.</span><span class="token function">WriteImage</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>content<span class="token punctuation">,</span> id<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">)</span>    <span class="token keyword">case</span> <span class="token string">".wav"</span><span class="token punctuation">:</span>        w<span class="token punctuation">.</span><span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">,</span> <span class="token string">"audio/x-wav"</span><span class="token punctuation">)</span>        <span class="token boolean">_</span> <span class="token operator">=</span> captcha<span class="token punctuation">.</span><span class="token function">WriteAudio</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>content<span class="token punctuation">,</span> id<span class="token punctuation">,</span> lang<span class="token punctuation">)</span>    <span class="token keyword">default</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> captcha<span class="token punctuation">.</span>ErrNotFound    <span class="token punctuation">}</span>    <span class="token keyword">if</span> download <span class="token punctuation">{</span>       w<span class="token punctuation">.</span><span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">,</span> <span class="token string">"application/octet-stream"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    http<span class="token punctuation">.</span><span class="token function">ServeContent</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">,</span> id<span class="token operator">+</span>ext<span class="token punctuation">,</span> time<span class="token punctuation">.</span>Time<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> bytes<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>content<span class="token punctuation">.</span><span class="token function">Bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    router <span class="token operator">:=</span> gin<span class="token punctuation">.</span><span class="token function">Default</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    router<span class="token punctuation">.</span><span class="token function">LoadHTMLGlob</span><span class="token punctuation">(</span><span class="token string">"./*.html"</span><span class="token punctuation">)</span>    router<span class="token punctuation">.</span><span class="token function">Use</span><span class="token punctuation">(</span><span class="token function">Session</span><span class="token punctuation">(</span><span class="token string">"topgoer"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    router<span class="token punctuation">.</span><span class="token function">GET</span><span class="token punctuation">(</span><span class="token string">"/captcha"</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">Captcha</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    router<span class="token punctuation">.</span><span class="token function">GET</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">{</span>        c<span class="token punctuation">.</span><span class="token function">HTML</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusOK<span class="token punctuation">,</span> <span class="token string">"index.html"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    router<span class="token punctuation">.</span><span class="token function">GET</span><span class="token punctuation">(</span><span class="token string">"/captcha/verify/:value"</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">{</span>        value <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">Param</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token function">CaptchaVerify</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>            c<span class="token punctuation">.</span><span class="token function">JSON</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusOK<span class="token punctuation">,</span> gin<span class="token punctuation">.</span>H<span class="token punctuation">{</span><span class="token string">"status"</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"msg"</span><span class="token punctuation">:</span> <span class="token string">"success"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            c<span class="token punctuation">.</span><span class="token function">JSON</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusOK<span class="token punctuation">,</span> gin<span class="token punctuation">.</span>H<span class="token punctuation">{</span><span class="token string">"status"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"msg"</span><span class="token punctuation">:</span> <span class="token string">"failed"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    router<span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token string">":8080"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;GoWeb&quot;&gt;&lt;a href=&quot;#GoWeb&quot; class=&quot;headerlink&quot; title=&quot;GoWeb&quot;&gt;&lt;/a&gt;GoWeb&lt;/h2&gt;&lt;p&gt;官方包&lt;code&gt;net/http&lt;/code&gt;提供了基础的路由函数组合和功能函数，无需API&lt;/p&gt;
&lt;pre c</summary>
      
    
    
    
    <category term="Golang" scheme="http://sn1987a-1.github.io/categories/Golang/"/>
    
    
    <category term="Gin" scheme="http://sn1987a-1.github.io/tags/Gin/"/>
    
  </entry>
  
  <entry>
    <title>Vue基础知识</title>
    <link href="http://sn1987a-1.github.io/posts/1d1c79fd.html"/>
    <id>http://sn1987a-1.github.io/posts/1d1c79fd.html</id>
    <published>2023-09-23T12:48:34.000Z</published>
    <updated>2023-09-23T13:09:20.812Z</updated>
    
    
    
    
    <category term="前端" scheme="http://sn1987a-1.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Vue" scheme="http://sn1987a-1.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>并行数据结构-p-tree</title>
    <link href="http://sn1987a-1.github.io/posts/a4d33f77.html"/>
    <id>http://sn1987a-1.github.io/posts/a4d33f77.html</id>
    <published>2023-09-22T07:46:11.000Z</published>
    <updated>2023-09-23T13:05:25.842Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并行数据结构"><a href="#并行数据结构" class="headerlink" title="并行数据结构"></a>并行数据结构</h2><p>并行数据结构的几个概念</p><ul><li><p>non-blocking</p><p>一个线程被挂起或中断不会导致其他线程执行被block</p></li><li><p>lock-free</p><p>保证整个系统的执行进度是不断推进的</p></li><li><p>wait-free</p><p>保证每个线程的执行进度是不断推进的</p></li></ul><p>通常需要做到lock-free,不要求wait-free(较难实现，性能较差)</p><p>lock-free:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">auto expected = x.load();do {     bool ok = x.compare_exchange_strong(expected, new_value);} while(!ok)//compare_exchange_strong 解释。// if true, 则x和expected相等，使用new_value替换x的值//if false, 则x和expected不相等，并expected会被修改成x的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（否则需要spin lock）</p><p>仅仅使用串行数据结构+锁远远不能达到要求（还可能导致死锁）</p><p><strong>涉及的数据结构</strong></p><p>CSDS（并行查找数据结构）</p><ul><li>链表，跳表，哈希表</li><li>主要实现：查找，插入，删除<ul><li>查找：遍历</li><li>插入删除，先找到位置，再进行操作</li></ul></li><li>关键<ul><li>速度快，避免耗时操作（写操作），等待和重试</li><li>细粒度，修改尽量设计较小的范围，需要用锁：细粒度锁</li></ul></li></ul><p>非查找数据结构：</p><ul><li>队列，栈，竞争点都在头/尾，队尾竞争激烈</li></ul><h3 id="并行数据结构设计"><a href="#并行数据结构设计" class="headerlink" title="并行数据结构设计"></a>并行数据结构设计</h3><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p>串行数据结构的单链表的增删改查都相对容易，在并发中容易遇到的问题：</p><ul><li>删除和插入，插入和插入，删除和删除，都会引发问题</li><li>内存管理问题：对已删除的节点，需要释放内存，但如果其他线程持有在该点的操作，不能立即释放</li><li>ABA问题：插入某节点时，该节点的前驱刚被释放且空间被分配到另一个节点（内存复用），导致链表乱序</li><li>线性化问题：遍历链表得到的遍历结果不一定是历史存在过的链表版本数据（解决方案：不提供遍历操作即可，只提供插入删除和查找，这三个操作可以是线性化的）</li></ul><p>解决方案（大部分的问题都是删除操作、释放空间产生的）</p><ul><li>节点不删除，先标记再集中GC，GC加锁<ul><li>s删除导致的GC会出现短暂阻塞，出现长尾</li></ul></li><li>节点删除但不释放内存<ul><li>内存会不断增长</li></ul></li><li>节点删除并释放内存<ul><li>使用引用计数的方式管理链表内存释放，每次遍历对节点进行引用计数（对性能影响较大）</li></ul></li></ul><p>插入删除冲突的解决</p><p>关键在于：被删除节点的next不能被改变，可以将被删除节点的next添加标记符1（next&amp;1），阻止其他线程改变该节点的值。</p><p><img src="https://segmentfault.com/img/bVcXvpQ" alt="image.png" style="zoom:33%;"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool del_node(ListNode* pre_del_node) {        ListNode* del_node = pre_del_node-&gt;next.load();        //1. 标记del_node-&gt;next;        ListNode* excepted_next = del_node-&gt;next.load();        //2. next指针添加标记位        if (!del_node-&gt;next-&gt;compare_exchange_strong(excepted_next, excepted_next&amp;1)) {            return false;        }        //3. 修改前驱节点next指针        if(!pre_del_node-&gt;next.compare_exchange_strong(del_node, del_node-&gt;next)) {            return false;        }               return true;} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果修改不成功将退出，插入也类似。</p><p><code>compare_exchange_strong</code></p><p><strong>ABA问题的解决</strong></p><p>使用tagged pointer解决（在指针上带上版本号进行管理）</p><p>使用指针的最高16尾存储指针的版本信息，每次指针内容发生变化时改变版本号（指针一般64位，CPU内存远远不及）<a href="https://www.boost.org/doc/libs/1_57_0/boost/lockfree/detail/tagged_ptr.hpp">参考</a></p><p><strong>内存管理问题解决</strong></p><p>风险指针Hazard Pointers</p><p>原理：</p><ul><li>每个线程把自己访问的节点的地址放在全局可见的地方，这样的全局可见的指针被称为风险指针，访问完节点后清除自己的风险指针</li><li>每个线程维护一个freelist：<ul><li>当某个结点A被删除后，放到freelist里</li><li>检查其他线程的风险指针，看看有没有和A相同的地址，如果没有其他节点正在访问A，A可以被释放</li></ul></li></ul><p>优化：风险指针自身也要保证线程安全，需要高效实现——<code>shared_ptr</code></p><p>使用shared-ptr组织链表，每个ListNode*都是智能指针。</p><p>存在的问题：</p><ul><li>遍历链表时，每走过一个节点，该节点引用数+1，离开时引用数-1，原子操作比较慢，因此搜索速度慢，不满足CSDS的原则</li><li>采用递归方式释放整个链表，或者链表中的一段，可能会导致栈溢出</li><li>如果一个线程获得一个结点的引用计数，但被卡住了一段时间之后才会释放这个计数，该节点所有的后继节点都会被延迟释放</li></ul><h3 id="并行扩张树P-tree"><a href="#并行扩张树P-tree" class="headerlink" title="并行扩张树P-tree"></a>并行扩张树P-tree</h3><p>SunYihan  <em>Parallel Ordered Sets Using Join</em> 2016,<em>PAM: Parallel Augmented Maps</em> 2018,<em>Join-based Parallel Balanced Binary Trees</em> 2019</p><p>对于存储在磁盘上的上万个图节点，在做图算法时，对图进行虚拟化。虚拟图可以使用如下两种方式来动态构建：1. “中断”式的构建；2. 多线程的构建，即存在一个扫描线程，后台扫描满足要求的节点，加载到虚拟图中。</p><p>所谓“中断”式的构建，是指要遍历到的下一个节点不在虚拟图上，触发“中断”，开始从磁盘加载一批新的图节点进来。而多线程构建方式，则是动态卸载已经访问过的节点，同时动态加载新的节点。为了提高对虚拟图读写的并发性，就需要使用一种数据结构：Parrellel Auguemented Map.</p><p>两个基本函数：</p><p><code>join(l,k,R)</code>，表示以k为根节点连接的左右两棵子树LR</p><p><code>expose(T)</code>表示以树T的根k作为分裂节点，将树分裂为L，k，R并返回</p><p>相关函数：</p><p><strong>split ()以k为节点划分树，返回左子树，右子树和是否null</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">split(T,k)    if T = null             (null,false,null)        else (L,m,R)=expose(T)        if k = m             (L,true,R)            else if k &lt; m                (LL,b,LR)=split(L,k)                (LL,b,join(LR,m,R))            else                 (RL,b,RR)=split(R,k)                (join(L,m,RL),b,RR)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>insert（）插入一个新节点</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">insert(T,k) (TL,m,TR)=split(T,k)    join(TL,k,TR)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>splitlast() 移除T最大值的节点（即右子树的最下方的值，返回移除后的平衡树和移除的节点）</strong></p><pre class="line-numbers language-none"><code class="language-none">splitlast(T)    (L,k,R)=expose(T)    if R=null        (L,k)    else        (T',k')=splitLast(R)        (join(L,k,T'),k')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>join2() 将两棵树拼接起来，根节点为左子树的最大根</strong></p><pre class="line-numbers language-none"><code class="language-none">join2(TL,TR)    if TL = null        TR    else       (TL',k)=splitlast(TL)       join(TL',k,TR)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>delete()从T中删除一个节点k</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">delete(T,k)    (TL,m,TR)=split(T,k)    join2(TL,TR)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>以上的几个函数未涉及并发，在以上的基础上，使用并发进行实现以下函数：(用来处理节点过多的情况，提高效率)</p><p><em>其中，||表示左右两边的函数可以并发进行</em></p><p><strong>union()将两个树合并成一个新的树</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">union(T1,T2)    if T1 = null         T2    else if T2 = null        T1    else        (L2,k,R2)=expose(T2)        (L1,m,R1)=spilt(T1,k)       TL=union(L1,L2)|| TR=union(R1,R2)        join(TL,k,TR)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>difference(T1,T2) 将T1中包含T2的节点删除，可以用来批量删除节点</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">difference(T1,T2)    if T1=null        null    else if T2=null        T1    else        (L2,k,R2)=expose(T2)        (L1,m,R2)=split(T1,k)        T1=difference(L1,L2) || T2=difference(R1,R2)        join2(T1,TR)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;并行数据结构&quot;&gt;&lt;a href=&quot;#并行数据结构&quot; class=&quot;headerlink&quot; title=&quot;并行数据结构&quot;&gt;&lt;/a&gt;并行数据结构&lt;/h2&gt;&lt;p&gt;并行数据结构的几个概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;non-blocking&lt;/p&gt;
&lt;p&gt;一个线程被挂</summary>
      
    
    
    
    <category term="HPC" scheme="http://sn1987a-1.github.io/categories/HPC/"/>
    
    
    <category term="并行数据结构" scheme="http://sn1987a-1.github.io/tags/%E5%B9%B6%E8%A1%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>CGO</title>
    <link href="http://sn1987a-1.github.io/posts/d4c66f48.html"/>
    <id>http://sn1987a-1.github.io/posts/d4c66f48.html</id>
    <published>2023-09-20T12:48:34.000Z</published>
    <updated>2023-09-23T13:03:50.253Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CGO"><a href="#CGO" class="headerlink" title="CGO"></a>CGO</h2><h4 id="在Go中调用C的代码"><a href="#在Go中调用C的代码" class="headerlink" title="在Go中调用C的代码"></a>在Go中调用C的代码</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//include "xxx.h"</span><span class="token keyword">import</span> <span class="token string">"C"</span>C<span class="token punctuation">.</span><span class="token function">puts</span><span class="token punctuation">(</span>helloworld<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>.h文件中声明函数，.c/.cpp文件对应函数的定义</p><p>import “C”前面的注释即为要运行的C代码</p><p>默认C，如果需要用C++（cpp文件），要声明：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">export</span> <span class="token string">"C"</span><span class="token punctuation">{</span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;xxx.h&gt;</span></span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Go生成C函数</strong></p><p>通过使用<code>extern "C"</code>，可以确保函数在C链接下可用，从而允许从C代码中调用它，而不会受到C++名称重整的影响。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//export funct</span><span class="token keyword">func</span> funct <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token punctuation">}</span><span class="token operator">...</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    C<span class="token punctuation">.</span><span class="token function">funct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用go重新实现C语言函数。</p><p>go函数C.CSstring()将字符串转化为(const)char*</p><p>上述函数运行过程：</p><p>Go的main函数执行，到CGO自动生成的C语言版本的funct桥接函数，回到GO中的funct函数。</p><p><strong>C语言可以调用GO生成的函数</strong>，CGO省的”_cgi_export.h”包含了导出后的C语言函数声明</p><h4 id="类型转化"><a href="#类型转化" class="headerlink" title="类型转化"></a>类型转化</h4><p>数字类型转化：</p><div class="table-container"><table><thead><tr><th>C 语言类型</th><th>CGO 类型</th><th>Go 语言类型</th></tr></thead><tbody><tr><td>char</td><td>C.char</td><td>byte</td></tr><tr><td>signed char</td><td>C.schar</td><td>int8</td></tr><tr><td>unsigned char</td><td>C.uchar</td><td>uint8</td></tr><tr><td>short</td><td>C.short</td><td>int16</td></tr><tr><td>unsigned short</td><td>C.ushort</td><td>uint16</td></tr><tr><td>int</td><td>C.int</td><td>int32</td></tr><tr><td>unsigned int</td><td>C.uint</td><td>uint32</td></tr><tr><td>long</td><td>C.long</td><td>int32</td></tr><tr><td>unsigned long</td><td>C.ulong</td><td>uint32</td></tr><tr><td>long long int</td><td>C.longlong</td><td>int64</td></tr><tr><td>unsigned long long int</td><td>C.ulonglong</td><td>uint64</td></tr><tr><td>float</td><td>C.float</td><td>float32</td></tr><tr><td>double</td><td>C.double</td><td>float64</td></tr><tr><td>size_t</td><td>C.size_t</td><td>uint</td></tr></tbody></table></div><p>在CGO生成的<code>_cgo_export.h</code>头文件中，会为go的字符串，切片，字典，接口，管道等特殊数据结构生成对应的C语言类型。（只有切片和字符串有一定的调用价值，因CGO对他们的某些操作函数生成了对应的C语言版本）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">;</span> GoInt n<span class="token punctuation">;</span><span class="token punctuation">}</span> GoString<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token operator">*</span>GoMap<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token operator">*</span>GoChan<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span><span class="token keyword">void</span> <span class="token operator">*</span>t<span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token operator">*</span>v<span class="token punctuation">;</span><span class="token punctuation">}</span> GoInterface<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span><span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">;</span> GoInt len<span class="token punctuation">;</span> GoInt cap<span class="token punctuation">;</span><span class="token punctuation">}</span> GoSlice<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>结构体</strong> 通过<code>C.struct_xxx</code>访问C中定义的struct xxx的结构体类型，结构体内存布局按照C语言通用对齐规则（32/64位），若结构体的成员的名字是go的关键字，可以在成员名开头添加_来访问</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">/*struct A {    int type; // type 是 Go 语言的关键字};*/</span><span class="token keyword">import</span> <span class="token string">"C"</span><span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> a C<span class="token punctuation">.</span>struct_A    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>_type<span class="token punctuation">)</span> <span class="token comment">// _type 对应 type</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果恰好有两个成员 type,_type，则type将被屏蔽。</p><p>C语言中无法直接访问Go定义的结构体类型。</p><p><strong>切片和字符串</strong></p><p>Go中的切片和C中的指向一定长度内存的指针（slice实际上是简化版的动态数字）</p><p>go中的字符串是只读的</p><p><strong>指针</strong></p><p>C语言中的指针可以进行显示或隐式切换（隐式会在编译阶段给出warnings），go对不同类型的转换非常严格，无法自由转换。如果格式一致，指针可以通用。CGO解决了GO无法自由转换和进行指针运算的限制。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> p <span class="token operator">*</span>X<span class="token keyword">var</span> q <span class="token operator">*</span>Yq <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>Y<span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// *X =&gt; *Y</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>X<span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// *Y =&gt; *X</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用unsafe.Pointer作为中间桥接类型实现不同类型指针的转换，转换流程：*X-&gt;unsafe.pointer-&gt;*Y</p><p>同样，go也无法实现数值类型转化为指针类型，采用uintptr作为中间类型实现，转化过程：int32-&gt;uintptr-&gt;unsafe.pointer-&gt;char*</p><h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p>C不支持多返回值，但Go需要error返回报错信息(如div除数为0)，解决方案：</p><p>引入errno包</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;errno.h&gt;int div(int a, int b) {    if(b == 0) {        errno = EINVAL;        return 0;    }    return a/b;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>CGO的处理：在CGO中如果有两个返回值，那么第二个返回值为errno，可以近似地将函数看作以下类型：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> C<span class="token punctuation">.</span><span class="token function">div</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b C<span class="token punctuation">.</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>C<span class="token punctuation">.</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token builtin">error</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>void函数</strong>返回值</p><p>按照前文所述，对于没有返回值的void函数，如果出现errno，也只有一个返回值，CGO无法直接判断错误状态，CGO的处理如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">import</span> <span class="token string">"C"</span><span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">:=</span> C<span class="token punctuation">.</span><span class="token function">noreturn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CGO&quot;&gt;&lt;a href=&quot;#CGO&quot; class=&quot;headerlink&quot; title=&quot;CGO&quot;&gt;&lt;/a&gt;CGO&lt;/h2&gt;&lt;h4 id=&quot;在Go中调用C的代码&quot;&gt;&lt;a href=&quot;#在Go中调用C的代码&quot; class=&quot;headerlink&quot; title=&quot;在</summary>
      
    
    
    
    <category term="Golang" scheme="http://sn1987a-1.github.io/categories/Golang/"/>
    
    
    <category term="CGO" scheme="http://sn1987a-1.github.io/tags/CGO/"/>
    
  </entry>
  
  <entry>
    <title>Golang基础知识</title>
    <link href="http://sn1987a-1.github.io/posts/c303e9c6.html"/>
    <id>http://sn1987a-1.github.io/posts/c303e9c6.html</id>
    <published>2023-09-18T12:48:34.000Z</published>
    <updated>2023-09-23T13:03:58.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>实现：哈希查找表，通过链表法解决哈希冲突</p><ul><li>随机遍历，顺序无法预测</li><li>扩容特点：逐步进行，新，旧bucket<ul><li>遍历中出现扩容</li><li>遍历前已经开始扩容</li></ul></li></ul><h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p>底层结构：本质上是引用类型，底层结构有三个变量：len，cap，底层数组的指针</p><ul><li>空切片时，cap=len=0</li><li>一般初始化方式<code>a:=[]int{}</code>cap=len=初始化长度</li><li>使用make进行初始化：<code>a:=make([]int,4,5)</code>：cap=5，len=4，a为[0,0,0,0]</li><li><code>var a []int</code>默认cap=len=0</li></ul><p>append操作</p><ul><li>cap足够，直接修改len，追加</li><li>cap不足时…</li><li><em>cap足够时，一次追加多个和多次追加一个结果相同，cap不足时会出现不一样的结果（cap的结果不同，多次追加一个的情况可能会更大）</em></li></ul><p>切片截取操作：</p><ul><li><em>切片进行截取时，数组容量的末尾和原切片数组末尾对齐，数组地址为截取单元的首地址，且可以超过其len的范围进行截取，当其中一个数组发生扩容时，另一个数组的地址不变</em></li></ul><p>切片扩容时会改变：cap和数字指针</p><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><ul><li>引用计数，0回收，无法处理 循环引用</li><li>标记-清除： 需要STW</li><li>分代收集：按照生存周期老/新不同的算法，效率高，算法设计复杂</li><li><strong>三色标记法</strong>：白-垃圾，灰-遍历到的对象，黑，遍历灰色，标记为黑色并将引用的变量标记为灰色，直到没有灰色<ul><li><strong>每次GC循环时，不需要将所有对象移动到白色区域，只要将黑色和白色的颜色互换即可，更高效</strong></li></ul></li><li><strong>STW</strong>：影响性能&lt;1ms</li><li><strong>写屏障技术</strong>缩短STW<ul><li>引用对象丢失：黑色节点添加了指向白色结点的引用，但无法被扫描</li><li>破坏以下二者之一：<ul><li>dijistra写屏障（强三色不变性），不允许黑色节点引用白色节点，引用则将白色节点改为灰色</li><li>yuasa写屏障（弱三色不变性），白色节点被删除了一个引用时，认为会被黑色节点新增引用（悲观），设置为灰色</li></ul></li></ul></li></ul><p>go的垃圾回收器是和主程序并行的，关键在于三色标记法能让系统的gc暂停时间能够预测</p><h3 id="GPM调度和CSP模型"><a href="#GPM调度和CSP模型" class="headerlink" title="GPM调度和CSP模型"></a>GPM调度和CSP模型</h3><p><em>不要以共享内存的方式来通信，要以通信的方式来共享内存</em></p><ul><li>CSP模型：以通信的方式共享内存（channel进行通信）</li><li><p>GPM含义</p><ul><li>G：go协程Goroutine</li><li>M：工作线程，CPU数量</li><li>P：处理器，用来调度G，M的关联关系，M拥有P才能执行G的代码</li></ul></li><li><p>Goroutine的调度策略</p><ul><li>队列轮转：P周期性地调度G到M中运行，一段时间后保存上下文切换（队列）</li><li>系统调用：G0即将进入系统调用时，M0释放P，某个M1获得P运行剩下的G，G0结束后等待其他的P调度（或空闲P），此后进入缓存池睡眠</li></ul></li></ul><h3 id="Chan原理（channel）"><a href="#Chan原理（channel）" class="headerlink" title="Chan原理（channel）"></a>Chan原理（channel）</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">  <span class="token keyword">type</span> hchan <span class="token keyword">struct</span> <span class="token punctuation">{</span> qcount   <span class="token builtin">uint</span>  <span class="token comment">// 队列中的总元素个数</span> dataqsiz <span class="token builtin">uint</span>  <span class="token comment">// 环形队列大小，即可存放元素的个数</span> buf      unsafe<span class="token punctuation">.</span>Pointer <span class="token comment">// 环形队列指针</span> elemsize <span class="token builtin">uint16</span>  <span class="token comment">//每个元素的大小</span> closed   <span class="token builtin">uint32</span>  <span class="token comment">//标识关闭状态</span> elemtype <span class="token operator">*</span>_type <span class="token comment">// 元素类型</span> sendx    <span class="token builtin">uint</span>   <span class="token comment">// 发送索引，元素写入时存放到队列中的位置</span> recvx    <span class="token builtin">uint</span>   <span class="token comment">// 接收索引，元素从队列的该位置读出</span> recvq    waitq  <span class="token comment">// 等待读消息的goroutine队列</span> sendq    waitq  <span class="token comment">// 等待写消息的goroutine队列</span> lock mutex  <span class="token comment">//互斥锁，chan不允许并发读写</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>写数据<ul><li>recvq不为空，缓冲区无数据/无缓冲区，则直接从recvq取出G，写入数据，并把G唤醒</li><li>缓冲区有空余位置，写入缓冲区</li><li>缓冲区无空余位置，将数据写入G，将当前G加入sendq，进入睡眠被唤醒</li></ul></li><li>读数据<ul><li>sendq不为空，且无缓冲区，直接从sendq去除G，把G数据读走并唤醒</li><li>sendq不为空（缓冲区已满），从缓冲区首部读出数据，将G中的数据写入缓冲区尾部，唤醒G</li><li>缓冲区有数据，从缓冲区读取数据</li><li>将当前G加入recvq进入睡眠</li></ul></li><li>关闭channel<ul><li>唤醒recvq中所有的G，本该写入数据的内容为nil，sendq中的G唤醒（会出现panic）</li><li>panic出现的场景<ul><li>关闭值为nil的channel</li><li>关闭已经关闭的channel</li><li>向已关闭的channel写入数据</li></ul></li></ul></li></ul><p>无缓冲区情况：读和写同步（会阻塞）</p><h3 id="context上下文结构"><a href="#context上下文结构" class="headerlink" title="context上下文结构"></a>context上下文结构</h3><p>并发安全，树状的goroutine</p><p>只定义了接口</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"> <span class="token keyword">type</span> Context <span class="token keyword">interface</span> <span class="token punctuation">{</span>   <span class="token function">Deadline</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>deadline time<span class="token punctuation">.</span>Time<span class="token punctuation">,</span> ok <span class="token builtin">bool</span><span class="token punctuation">)</span>   <span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span>   <span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span>   <span class="token function">Value</span><span class="token punctuation">(</span>key <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>deadline：到达ddl自动发起取消请求</li><li>Done：返回只读的channel，如果可以读取说明已经发出取消信号，可以清理并释放</li><li>err：返回被取消的原因</li><li>value：获取context上绑定的值，key-value</li></ul><h3 id="竞态与内存逃逸"><a href="#竞态与内存逃逸" class="headerlink" title="竞态与内存逃逸"></a>竞态与内存逃逸</h3><ul><li><p>竞态：在程序中，同一个内存块被多个gorountine访问</p><ul><li>解决：对资源进行加锁，sync.Mutex,sync.RWMutex</li><li>检测：添加<code>-race</code></li></ul></li><li><p>逃逸分析：内存的分配位置由编译器决定，分配速度慢且会形成内存碎片</p><p>以下场景</p><ul><li>指针逃逸</li><li>栈空间不足逃逸</li><li>动态类型逃逸</li><li>闭包引用对象逃逸</li></ul></li></ul><h3 id="零碎"><a href="#零碎" class="headerlink" title="零碎"></a>零碎</h3><p><strong>安全读写共享变量方式</strong></p><ul><li>Mutex锁</li><li>goroutine通过channel</li></ul><p><strong>new和make的区别</strong></p><ul><li>make用来分配和初始化类型为slice，map，chan的数据，new任意数据并返回内存指针</li><li>make返回引用，即type，分配空间后进行初始，new分配的空间会被清零</li></ul><p><strong>对nil的slice和空silce的处理区别</strong></p><ul><li>slice:=make([]int,0)：空slice，不为0</li><li>slice:=[]int{} 值是nil，保证返回slice的函数异常时仍可保证返回nil</li></ul><p><strong>协程，进程，线程的区别</strong></p><ul><li><p>进程: 进程是具有一定独立功能的程序，进程是系统资源分配和调度的最小单位。 每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。</p></li><li><p>线程: 线程是进程的一个实体,线程是内核态,而且是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。</p></li><li><p>协程: 协程是一种用户态的轻量级线程，协程的调度完全是由用户来控制的。协程拥有自己的寄存器上下文和栈。 协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p></li></ul><p><strong>golang的内存模型中，为什么小对象多了会加大GC压力</strong></p><ul><li><p>小对象过多会导致GC三色法消耗过多CPU</p></li><li><p>解决思路：减少对象分配</p></li></ul><p><strong>channel为什么可以做到线程安全</strong></p><ul><li>先进先出，本身用来在多任务间传递数据，通过通信共享内存，有天然优势</li></ul><p><strong>GC触发条件</strong></p><ul><li>手动触发（主动）：调用runtime.GC，阻塞式</li><li>被动触发：<ul><li>系统监控，超过两分钟没有GC则触发</li><li>pacing（步调）算法，控制内存增长的比例，每次分配内存时检测是否以达到阈值，默认100%</li></ul></li></ul><p><strong>goroutine的数量查看和限制</strong></p><ul><li>查看： GOMAXPROCS控制未被阻塞的所有goroutine，通过GOMAXPROCE即可查看</li><li>限制：使用channel，每次执行goroutine前向通道写入值</li></ul><p><strong>Channel是同步还是异步的</strong></p><p>​    异步的</p><ul><li>channel的状态：<ul><li>nil，初始或手动赋值，无法关闭（panic），send/recv被永久阻塞</li><li>closed，关闭或send会panic，recv不会阻塞</li><li>active，可关闭，send/recv</li></ul></li></ul><p><strong>goroutine 和线程的区别</strong></p><ul><li>线程可以有多个goroutine</li><li>线程，进程都是同步的，协程是异步的</li><li>协程可以保留上一次调用的状态</li><li>协程需要线程来承载运行，不能代替线程</li><li><strong>线程是分割的CPU资源，协程是组织好的代码流程</strong></li></ul><p><strong>struct能不能比较</strong></p><ul><li>相同struct类型可以</li><li>不同struct不能比较，编译不通过</li></ul><p><strong>go主协程如何等待其他协程</strong></p><p>用sync.WaitGroup，内部实现计数器计数未完成的操作个数，Add()添加计数，Done()计数减一，Wait()等待所有操作结束，计数为0（立即返回）</p><p><strong>slice扩容</strong></p><p>append追加元素，空间不足则扩容，重新分配slice</p><p>扩容规则（只对容量）</p><ul><li>小于1024：扩容时翻倍，超过1024，增长因子变为1.25</li><li>容量够用则追加，len++</li><li>容量不够用，先扩容再追加</li></ul><p><strong>map顺序读取</strong></p><p>（一般是随机的）</p><p>先把map中的key用sort排序后根据key读取</p><p><strong>值接收者和指针接收者</strong></p><p>方法的接收者</p><ul><li>值类型：可以调用值接收者的方法和指针接收者的方法</li><li>指针类型：可以调用值接收者的方法和指针接收者的方法</li></ul><p>接口实现不同：</p><ul><li>值类型接口：类型本身和该类型的指针类型都实现了该接口</li><li>指针类型接口：只有对应的指针类型才被认为实现了接口</li></ul><p>通常使用指针作为方法的接收者</p><ul><li>能够修改接收者指向的值</li><li>避免每次调用方法时复制该值，更高效</li></ul><p><strong>发生内存泄漏的原因</strong></p><ul><li>goroutine需要维护用户代码的上下文信息，运行过程中需要消耗一定的内存来保存此类信息，如果一个程序不断产生goroutine，不结束已创建的goroutine并复用该部分内存，会造成内存泄漏</li></ul><p>协程泄露：（某段代码卡住，陷入死循环等）应该被释放的协程没有被正确释放</p><p><strong>如何检测内存泄漏</strong></p><p>自带的工具：pprof，或者用Gops检测当前运行的go程占用的资源</p><p><strong>两个nil可能不相等</strong></p><p>接口interface是对接口值的封装，内部包含类型T和值V，一个接口为nil当且仅当T=nil，V=unset</p><p>两个接口比较时，先比较T再比较V(接口值和非接口值进行比较会将非接口值转化为接口值)</p><p>例如<code>var p *int =nil</code>转化为接口值T=*int，显然和值为nil的接口不相等</p><p><strong>函数传参是值类型还是引用类型</strong></p><p>只存在值传递（值或指针的副本），都会开辟新的空间</p><p>不要混淆值传递，引用传递和值类型，引用类型</p><p><strong>内存对齐</strong></p><p>CPU都是以字长访问的（32位，64位），不进行内存对齐会增加CPU访问内存的次数，内存对齐对实现变量的原子性操作有好处（并发场景下）</p><p><strong>两个interface的比较</strong></p><ul><li>判断类型是否一样：<code>reflect.TypeOf(a).Kind()</code></li><li>判断接口是否相等：<code>reflect.DeepEqual(a,b,interface{})</code></li><li>将interface赋值给另一个：<code>reflect.ValueOf(a).Elem().Set(reflect.ValueOf(b))</code></li></ul><p><strong>打印<code>%v</code>,<code>%+v</code>,<code>%#v</code>的区别</strong></p><p>(输出struct中的元素)</p><ul><li>%v输出所有的值</li><li>%+v先输出字段名字，再输出该字段的值（name:value）</li><li>%#v先输出结构体名字，再输出结构体（name:value）</li></ul><p><strong>rune类型</strong></p><p>go的字符有以下两种</p><ul><li>uint8（byte），表示ASCII的字符</li><li>rune类型，表示UTF-8字符，等价于int32</li></ul><p>string底层通过byte数组实现，对string求len计算了字节长度</p><p>[]rune(str)  :string转化为rune类型，统计长度示例：</p><ul><li>“hello 你好” string length=12(汉字3个),rune length=8</li></ul><p><strong>空struct{}占用的空间</strong></p><p>使用unsafe.Sizeof(struct{})=0，不占用任何内存空间</p><p><strong>空struct的用途</strong></p><p>优点：不占内存空间，通常被当作占位符</p><ul><li>map作为集合使用（<code>type set map[string]struct{}</code>)</li><li>不发送数据的channel，只是通知子协程执行任务或控制协程并发（<code>make(chan struct{})</code>）</li><li>有可能结构体中只包含方法，不含任何字段</li></ul><p><strong>变量的分配位置在堆上还是栈上</strong></p><p>由编译器决定，如果无法判断变量作用域和大小，通常会分配到堆上（堆上的变量在函数出栈自行释放，无需gc）</p><p><strong>select执行</strong></p><p>select：多个可用操作：随机选一个</p><ul><li>select 中只要有一个 case 能 return，则立刻执行</li><li>当如果同一时间有多个 case 均能 return 则伪随机方式抽取任意一个执行</li><li>如果没有一个 case 能 return 则可以执行”default” 块</li></ul><p><strong>array和slice的区别</strong></p><ul><li>array：固定长度，<em>长度是数组类型的一部分</em>，需指定大小或根据初始化值确定</li><li>slice：可变长度，三个属性：<em>指针，长度，容量</em>，通过make初始化，可以扩容</li></ul><p><strong>defer的作用</strong></p><p>在<strong>调用</strong>普通函数或方法前加上关键词defer即可。defer被执行时，defer后面的函数被延迟执行，直到包含该defer语句的函数执行完毕（不管return结束还是panic结束），即为在函数返回之前调用，<strong>defer是在return之前完成的</strong>。</p><p>常被用于处理成对的操作，保证资源能被释放等（打开/关闭，连接/断开，加锁/释放锁）</p><p>释放资源的defer跟在请求资源的语句后</p><p>最后面的defer最先被调用（类似于栈）</p><p><em>return xxx并不是一条原子语句</em>：先给返回值赋值，再调用defer语句，例如：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>r <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     t <span class="token operator">:=</span> <span class="token number">5</span>     <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       t <span class="token operator">=</span> t <span class="token operator">+</span> <span class="token number">5</span>     <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token keyword">return</span> t<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>返回值为5</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">defer_call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"打印前"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"打印中"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"打印后"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"触发异常"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">打印后打印中打印前panic:触发异常<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>go关键字</strong></p><p><code>go func(x,y,z)</code>只有fun(x,y,z)在新的goroutine中运行，参数的计算在原goroutine中完成。</p><p><strong>var和:=定义变量的区别</strong></p><p><code>:=</code>只能在声明局部变量使用，<code>var</code>无限制</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> student <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Name <span class="token builtin">string</span>    Age  <span class="token builtin">int</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">pase_student</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    m <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">*</span>student<span class="token punctuation">)</span>    stus <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>student<span class="token punctuation">{</span>        <span class="token punctuation">{</span>Name<span class="token punctuation">:</span> <span class="token string">"zhou"</span><span class="token punctuation">,</span> Age<span class="token punctuation">:</span> <span class="token number">24</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>Name<span class="token punctuation">:</span> <span class="token string">"li"</span><span class="token punctuation">,</span> Age<span class="token punctuation">:</span> <span class="token number">23</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>Name<span class="token punctuation">:</span> <span class="token string">"wang"</span><span class="token punctuation">,</span> Age<span class="token punctuation">:</span> <span class="token number">22</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> stu <span class="token operator">:=</span> <span class="token keyword">range</span> stus <span class="token punctuation">{</span>        m<span class="token punctuation">[</span>stu<span class="token punctuation">.</span>Name<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>stu    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>错误：<code>for _, stu := range stus {m[stu.Name] = &amp;stu}</code>一句中，stu实际上是副本，所以此处返回的均为同一个地址。</p><p>修改：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> i<span class="token operator">:=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token function">len</span><span class="token punctuation">(</span>stus<span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span>  <span class="token punctuation">{</span>       m<span class="token punctuation">[</span>stus<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>Name<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>stus<span class="token punctuation">[</span>i<span class="token punctuation">]</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    runtime<span class="token punctuation">.</span><span class="token function">GOMAXPROCS</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    wg <span class="token operator">:=</span> sync<span class="token punctuation">.</span>WaitGroup<span class="token punctuation">{</span><span class="token punctuation">}</span>    wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"A: "</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>            wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"B: "</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>            wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果 <code>A:</code>均为输出 10，<code>B:</code>从 0~9 输出 (顺序不定)</p><p><strong>defer多层嵌套</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span>    <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span>       <span class="token keyword">defer</span> fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span>       fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"D"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">defer</span> fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"E"</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"F"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果输出顺序：AFEDBC</p><pre class="line-numbers language-GO" data-language="GO"><code class="language-GO">func main() {    for i:=0; i&lt;5; i++ {        defer func() {           fmt.Println(i)         }()    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：5 5 5 5 5</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> i<span class="token operator">:=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>         <span class="token punctuation">}</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：4 3 2 1 0</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">calc</span><span class="token punctuation">(</span>index <span class="token builtin">string</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>    ret <span class="token operator">:=</span> a <span class="token operator">+</span> b    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> ret<span class="token punctuation">)</span>    <span class="token keyword">return</span> ret<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    a <span class="token operator">:=</span> <span class="token number">1</span>    b <span class="token operator">:=</span> <span class="token number">2</span>    <span class="token keyword">defer</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token string">"10"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span>    a <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">defer</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token string">"20"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span>    b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">10 1 2 320 0 2 22 0 2 21 1 3 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;golang&quot;&gt;&lt;a href=&quot;#golang&quot; class=&quot;headerlink&quot; title=&quot;golang&quot;&gt;&lt;/a&gt;golang&lt;/h2&gt;&lt;h3 id=&quot;map&quot;&gt;&lt;a href=&quot;#map&quot; class=&quot;headerlink&quot; title=&quot;map</summary>
      
    
    
    
    <category term="Golang" scheme="http://sn1987a-1.github.io/categories/Golang/"/>
    
    
    <category term="Go" scheme="http://sn1987a-1.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>代数结构习题课-1</title>
    <link href="http://sn1987a-1.github.io/posts/94cbcba9.html"/>
    <id>http://sn1987a-1.github.io/posts/94cbcba9.html</id>
    <published>2023-06-02T12:48:34.000Z</published>
    <updated>2023-09-23T13:23:00.592Z</updated>
    
    <content type="html"><![CDATA[<p><strong>2023spring代数结构习题课讲义</strong></p><h3 id="第二次习题课"><a href="#第二次习题课" class="headerlink" title="第二次习题课"></a>第二次习题课</h3><h4 id="知识整理"><a href="#知识整理" class="headerlink" title="知识整理"></a>知识整理</h4><p>环的定义（验证$<r,+,\cdot>$是否是环）</r,+,\cdot></p><ul><li>$<r,+>$是交换群</r,+></li><li>$<r,\cdot>$是含幺半群（封闭性，结合律，乘法单位元）</r,\cdot></li><li>乘法对加法有左右分配律</li></ul><p>交换环：乘法具有交换律</p><ul><li>负元：加法逆元，一定存在</li><li>可逆元：乘法逆元存在时，称为可逆元</li><li>运算:$a\cdot 0=0\cdot a=0,a\cdot(-b)=(-a)\cdot b=-(a\cdot b),(-a)\cdot (-b)=a\cdot b$</li></ul><p>特殊的环：</p><ul><li><p>数环，R，C，Q</p></li><li><p>自同态环: $<g,+>$是交换群，$E=\{f|f:G\rightarrow G是同态映射\}$，在E上定义运算：</g,+></p></li></ul><script type="math/tex; mode=display">(f+g)(x)=f(x)+g(x)\\(f\cdot g)(x)=f(x)\cdot g(x)</script><p>此时$<e,+,\cdot>$为环，交换群G上的自同态环。</e,+,\cdot></p><ul><li>模n同余类环$&lt;\Z_n,+,\cdot&gt;$ <script type="math/tex; mode=display">[i]+[j]=[i+j]\\[i]\cdot[j]=[i\cdot j]</script></li></ul><p>整环和域</p><ul><li>零因子，左（右）零因子：$a\in R,\exist b,a\cdot b=0(b\cdot a=0)$</li><li>无零因子 当且仅当 乘法有左右消去律</li><li>整环：非平凡交换环，无零因子<ul><li>有左右消去律</li><li>加阶（关于加法运算的阶）：无限（特征为0）/素数（特征为p）</li></ul></li><li>域：非平凡交换环，每个非零元素a都存在乘法逆元（关于乘法构成交换群）<ul><li>域$\Rightarrow$整环（必要不充分）</li><li>有限整环$\Rightarrow$域，即为有限域，特征为p（充分不必要） <em>整数环不是域，$&lt;\Z_p,+\cdot&gt;$是域</em></li></ul></li></ul><p>子环</p><ul><li><p>判断子环</p><ul><li>关于加法构成子群</li><li>对乘法运算封闭</li><li><strong>包含乘法单位元</strong></li></ul></li><li><p>环同态映射f：</p><ul><li>$f(a+b)=f(a)+f(b)$</li><li>$f(a\cdot b)=f(a)\cdot f(b)$</li><li>$f(1_{R_1})=1_{R_2}$(如果没有该条件保证，会出现$f(1_{R_1})=0_{R_2}$的情况)</li></ul></li><li><p>同态映射相关性质</p><ul><li>$f(0_{R_1})=0_{R_2}$</li><li>$f(-a)=-f(a)$</li><li>可逆元映射到可逆元，$f(a’)=(f(a))’$</li></ul></li><li><p>同态映射不能保持整环/域等的结构（例7.14），环同构映射可以。</p></li><li><p>对于满射f:</p><script type="math/tex; mode=display">f(a+b)=f(a)+f(b)\\f(a\cdot b)=f(a)\cdot f(b)</script><p>可以判断是环。</p></li></ul><p>理想和商环</p><ul><li><p>理想：对于环R的非空子集I，满足$\forall x,y\in I,r\in R\Rightarrow x-y \in I,x\cdot r\in I,r\cdot x\in I$</p></li><li><p>理想关于加法构成子群</p></li><li><p>真理想，平凡理想</p></li><li><p>理想的运算得到的都是理想</p><script type="math/tex; mode=display">I_1\cdot I_2=\{\sum _{k=1}^{n}r_{1k}\cdot r_{2k}|r_{1k}\in R_1,r_{2k}\in R_2,1\leq k_1\leq n,n=1,2... \}\\I_1+I_2=\{r_1+r_2|r_1\in I_1,r_2\in I_2 \}</script></li><li><p>商环：$R/I=\{x+I|x\in R\}$</p></li><li>若理想I中有可逆元，$I=R$(平凡理想)$\Rightarrow$域中所有的理想都是平凡理想，没有真理想</li><li><p>主理想：交换环中元素a生成的理想：$\forall a \in R,(a)=\{a\cdot r|r\in R\}$；推广到交换环的子集：$\forall S=\{a_1,a_2,…a_k\} \subseteq R,(a_1,a_2,…a_k)=\{a_1\cdot r_1+…a_k\cdot r_k|r_1,r_2,…r_k\in R\}$</p><ul><li>主理想环：所有的理想都是主理想     (整数环)</li></ul></li></ul><p>多项式环</p><ul><li><p>环R上的多项式$p(x)=a_0+a_1x+…+a_nx^n,a_n\neq 0_R,n\geq 0$</p><ul><li>$a_i$为系数，x为未定元，n为次数$deg(p(x))=n$；R上的非零元素：常数多项式；$0_R$零多项式；</li></ul></li><li><p>全体多项式记为R[x]，定义运算：</p><script type="math/tex; mode=display">\forall f(x),g(x)\in R[x],\\f(x)+g(x)=\sum^{max\{m,n\}}_{k=0}(a_k+b_k)x^k\\f(x)\cdot g(x)=\sum^{m+n}_{k=0}c_kx^k,c_k=\sum_{i+j=k}a_i\cdot b_j,0\leq k\leq m+n</script><p>R[x]是环（零元，逆元，乘法单位元），且是整环。</p></li><li><p>域上的多项式</p><p>对于R[x]上的f(x),g(x)，若g(x)不是零多项式，存在唯一的$q(x),r(x)\in F[x]$:</p><script type="math/tex; mode=display">f(x)=q(x)\cdot g(x)+r(x)，其中r(x)的次数小于deg(g(x))，也可能是零多项式。</script><p>该式子说明域上的多项式可以做除法，商和余式唯一确定；其中$f(x)=q(x)\cdot g(x)$时，称g(x)为f(x)的因式；</p><script type="math/tex; mode=display">f(x)=q(x)\cdot(x-a)+r_0\Rightarrow f(a)=r_0</script><p>因此x-a为f(x)的因式当且仅当$f(a)=0_F$,此时a为f(x)的根。</p><ul><li>域上的多项式环是主理想环。（都可以写为$I=(g(x))$）</li></ul></li><li><p>域上的多项式商环</p><script type="math/tex; mode=display">F[x]/P=\{f(x)+P|f(x)\in F(x) \},f(x)=q(x)\cdot p(x)+r(x),f(x)-r(x)\in(p(x))\\F[x]/P=\{b_0+b_1x+...+b_{n-1}+P|b_0,b_1,...b_{n-1}\in F \}</script></li></ul><p>环同态定理</p><ul><li><p>同态核：$\phi$为从$R_1$到$R_2$的同态映射，$Ker\phi =\{r|r\in R_1,\phi(r)=0_{R_2} \}$</p></li><li><p>$Ker\phi$为$R_1$的理想</p></li><li><p>环同态基本定理：环$R_1$的任意商环都是环$R_1$的同态像。若$\phi$是从$R_1$到$R_2$的满同态映射</p><script type="math/tex; mode=display">R_1/Ker\phi \cong R_2</script></li><li><p>若f为从$R_1$到$R_2$的同态映射</p><ul><li>$S_1$是$R_1$的子环，$f(S_1)$是$R_2$的子环（$f(R_1)$是子环）</li><li>$S_1$是$R_1$的理想，$f(S_1)$是$R_2$的理想</li><li>$S_2$是$f(R_1)$的子环，$f^{-1}(S_2)$是$R_1$的子环</li><li>$S_2$是$f(R_1)$的理想，$f^{-1}(S_2)$是$R_1$的理想，且$R_1/f^{-1}(S_2)\cong f(R_1)/S_2$</li></ul></li><li><p>若$I_1,I_2$为R的理想，$I_2\subseteq I_1$，$I_1/I_2$是$R/I_2$的理想</p><script type="math/tex; mode=display">\frac{R/I_2}{I_1/I_2}\cong R/I_1</script></li></ul><h4 id="补充习题"><a href="#补充习题" class="headerlink" title="补充习题"></a>补充习题</h4><ol><li><p>找到$\mathbb{Z}[\mathrm{i}],\mathbb{Q}[\mathrm{i}]$中全部可逆元。</p><p> $\mathbb{Z}[\mathrm{i}]$中的元素可以写为$a+b\mathrm{i},a,b\in\mathbb{Z}$，当$a,b$不全为0时，若$(a+b\mathrm{i})(c+d\mathrm{i})=1$，解出$c=\frac{a}{a^2+b^2},d=\frac{-b}{a^2+b^2}$。若可逆，意味着$c,d\in\mathbb{Z}$。当$a\ne0,b\ne0$时，$a&lt;a^2+b^2$，$c$不可能为整数，因此不可能可逆，分$a=0$或$b=0$讨论可知$\mathbb{Z}[\mathrm{i}]$可逆元为$1,-1,\mathrm{i},-\mathrm{i}$。</p><p> $\mathbb{Q}[\mathrm{i}]$中的元素可以写为$a+b\mathrm{i},a,b\in\mathbb{Q}$，当$a,b$不全为0时，若$(a+b\mathrm{i})(c+d\mathrm{i})=1$，解出$c=\frac{a}{a^2+b^2},d=\frac{-b}{a^2+b^2}$。若可逆，意味着$c,d\in\mathbb{Q}$。非零有理数加减乘除一定还为有理数，因此$c,d\in\mathbb{Q}$一定成立，这意味着$\mathbb{Q}[\mathrm{i}]$中非零元素均可逆，它是域。</p></li><li><p>证明$\mathbb{Z}[x]$不为主理想环。</p><p> 考虑$(2,x)$，若$(2,x)$为主理想，意味着存在$f(x)\in\mathbb{Z}[x]$使得$2=g(x)f(x),x=h(x)f(x),g(x),h(x)\in\mathbb{Z}[x]$。由这两式可以推出$f(x)|\gcd(2,x)=1$，因此$f(x)=\pm1$。</p><p> 但是，$f(x)=\pm1$时，$f(x)$生成的理想为$\mathbb{Z}[x]$，而$2$与$x$生成的理想不包含1（注意$\frac{1}{2}\notin\mathbb{Z}[x]$），矛盾，由此即证明了$(2,x)$不为主理想，$\mathbb{Z}[x]$不为主理想环。</p></li></ol><ul><li>这也展现了为什么最大公因数与生成理想常都记作$(a,b)$，在主理想环中，可以证明理想$(a,b)$即为最大公因数$(a,b)$生成的理想。</li></ul><ol><li><p>（改编自去年期末考试）证明$\mathbb{R}[x]/(x^2+1)\simeq\mathbb{C}$，这里$\simeq$表示环同构。</p><p> 构造映射$\phi:\mathbb{R}[x]\to\mathbb{C},\phi(f(x))=f(\mathrm{i})$，由于$\phi(f(x)+g(x))=f(\mathrm{i})+g(\mathrm{i})=\phi(f(x))+\phi(g(x))$，$\phi(f(x)g(x))=f(\mathrm{i})g(\mathrm{i})=\phi(f(x))\phi(g(x))$，其为环同态。</p><p> 对其应用环同态第一定理，$\mathrm{ker}\phi=\{f\mid f(\mathrm{i})=0\}$，下证$\mathbb{R}[x]$中这等价于$x^2+1\mid f(x)$：</p><p> 若$f(\mathrm{i})=0$，等式两边取共轭，由于系数均为实数，可知$f(-\mathrm{i})=0$。利用因式定理，这意味着$(x-\mathrm{i})(x+\mathrm{i})\mid f(x)$，也即$x^2+1\mid f(x)$，另一方面，当$f(x)$有因式$x^2+1$时，代入可知$f(\mathrm{i})=0$。</p><p> 于是，$\mathrm{ker}\phi=\{f\mid x^2+1\mid f(x)\}=(x^2+1)$。</p><p> 而对任何$a+b\mathrm{i}\in\mathbb{C}$，取$f(x)=bx+a$即有$\phi(f)=a+bi$，因此$\phi$是满射，从而利用环同态第一定理得证。</p></li></ol><ul><li>环同态第一定理的最大作用是证明商环与某个环同态，但构造映射的过程可能有一定的技巧性。本题是由于注意到$\mathbb{i}$是$x^2+1$的根，而$\mathbb{C}=\mathbb{R}[\mathrm{i}]$，因此想到如此构造。</li></ul><ol><li>证明$\mathbb{Z}[x]/(x+1,x^2+4)\simeq\mathbb{Z}_5$。</li></ol><ul><li><p>本题基本不可能直接看出映射，因此需要构造：出于$\ker\phi=(x+1,x^2+4)$希望$\phi(x^2+4)=\phi(x+1)=0$。注意到$x^2+4=(x-1)(x+1)+5$，利用环同态可知$\phi(x^2+4)=\phi(x+1)\phi(x-1)+\phi(5)=0$，于是$\phi(5)=\phi(x+1)=0$。因此可以构造：</p><p>  构造$\phi:\mathbb{Z}[x]\to\mathbb{Z}_5$，$\phi(f(x))=[f(-1)]$，类似上题可说明其为环同态，下面计算$\ker\phi$。</p><p>  $f\in\ker\phi\Leftrightarrow 5\mid f(-1)$，利用因式定理得也即存在$t\in\mathbb{Z}$使得$f(x)-5t=(x+1)g(x),g\in\mathbb{Z}[x]$。因此，$f(x)=5t+(x+1)g(x)$，这意味着$f(x)\in(5,x+1)$。另一方面，$f(x)\in(5,x+1)$时，一定可以写为$5g(x)+(x+1)h(x),g,h\in\mathbb{Z}[x]$，于是$\phi(f)=[5g(-1)]=[0]$，即证明$\ker\phi=(5,x+1)$。</p><p>  由于$x^2+4=(x-1)(x+1)+5$，在有$x+1$时$x^2+4$与5可以互相生成，于是$(x^2+4,x+1)=(5,x+1)$。此外，令$f(x)=0,1,2,3,4$可知$\phi$是满射，从而利用环同态第一定理得证。</p></li><li><p>这里也可以发现，生成理想与最大公因数有类似的允许辗转相除性质。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;2023spring代数结构习题课讲义&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;第二次习题课&quot;&gt;&lt;a href=&quot;#第二次习题课&quot; class=&quot;headerlink&quot; title=&quot;第二次习题课&quot;&gt;&lt;/a&gt;第二次习题课&lt;/h3&gt;&lt;h4 id=&quot;知识整理&quot;</summary>
      
    
    
    
    <category term="代数结构" scheme="http://sn1987a-1.github.io/categories/%E4%BB%A3%E6%95%B0%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="专业课" scheme="http://sn1987a-1.github.io/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>代数结构习题课-1</title>
    <link href="http://sn1987a-1.github.io/posts/94cbcba9.html"/>
    <id>http://sn1987a-1.github.io/posts/94cbcba9.html</id>
    <published>2023-05-02T12:48:34.000Z</published>
    <updated>2023-09-23T13:28:15.511Z</updated>
    
    <content type="html"><![CDATA[<p><strong>2023spring代数结构习题课讲义</strong></p><h2 id="代数结构-第一次习题课"><a href="#代数结构-第一次习题课" class="headerlink" title="代数结构 第一次习题课"></a>代数结构 第一次习题课</h2><p>2023.5.3</p><h3 id="第三章-映射"><a href="#第三章-映射" class="headerlink" title="第三章 映射"></a>第三章 映射</h3><h4 id="内容回顾"><a href="#内容回顾" class="headerlink" title="内容回顾"></a>内容回顾</h4><ul><li>映射的基本定义<ul><li>概念：映射，原像，像，值域，映射相等</li><li>给定集合A，B，从A到B的映射有$|B|^{|A|}$个</li></ul></li><li>特殊映射：对于$f:A\rightarrow B$:<ul><li>$B=A,\forall a,f(a)=a$：恒等映射</li><li>$R_f=B$：满射</li><li>任给$a_1,a_2\in A,a_1\neq a_2\Rightarrow f(a_1)\neq f(a_2)$：单射</li><li>单射+满射：一一映射（双射） 相关性质：$f^{-1}$，$n!$个双射</li></ul></li><li>映射的复合：$g\circ f(a)=g(f(a))$ <em>从右往左计算</em><ul><li>结合律：$(h\circ g)\circ f=h\circ (g\circ f)$</li><li>$f^{-1}\circ f=f\circ f^{-1}=I_A$</li><li>复合运算保持单射/满射/双射</li></ul></li><li>置换：映射到自身的<strong>双射</strong><ul><li>恒等映射也可以称为恒等置换</li><li>求逆置换：交换两行并按照第一行排序</li><li>奇置换与偶置换：由逆序的个数奇偶决定</li></ul></li><li>轮换：特殊的置换，$\sigma=(a_1a_2…a_r)$<ul><li><em>不相交</em>的轮换的乘积可以交换</li><li>任何置换都可以表示成若干不相交的轮换之乘积</li><li>置换的阶：将置换表示为不相交的轮换，阶为各轮换的因子长度的最小公倍数</li></ul></li><li>对换：两个元素的轮换<ul><li>任何轮换都可以表示成对换之积</li><li>对换是奇置换，n元置换中，奇置换和偶置换各占一半</li></ul></li><li>开关函数：$F_2={0,1},f(x_1,…x_n)$为$F_2^n$到$F_2$的映射即为n元开关函数，共有$2^{2^n}$个<ul><li>求补运算$\overline f$，逻辑加 $ +$，逻辑乘  $ \cdot$     （注意和算术运算的区别）</li><li>结合律，交换律，分配律，$f+0=f;f\cdot 1=f;f+\overline f=1;f\cdot \overline f=0$</li><li>小项表达式：唯一的表达$f(x_1,..x_n)=\sum_{a_i=0/1,1\leq i\leq n} f(a_1,..a_n)x_1^{a_1}…x_n^{a_n}$</li></ul></li></ul><h4 id="作业题目"><a href="#作业题目" class="headerlink" title="作业题目"></a>作业题目</h4><p><img src="file:///C:\Users\SN1987A\Documents\Tencent Files\945093063\Image\C2C\46D000D57075B73B5A3DF00E1FBC3BF1.png" alt="img" style="zoom:50%;"></p><p><img src="file:///C:\Users\SN1987A\Documents\Tencent Files\945093063\Image\C2C\9DE5D0814A324D580516AA5C871458E6.png" alt="img" style="zoom:50%;"></p><p><strong>3.16 证明：任何n元置换都可以表示成(1 2),(2 3),…,(n-1,n)的乘积</strong></p><p>方法1：用归纳法证明：</p><p>n=2时，2元置换即为(1 2);</p><p>n&gt;2时，假设对于任何k，$k\le n$,满足任何k元置换都可以表示成(1 2),(2 3),…,(k-1,k)的乘积，考虑任何一个n元置换$\sigma$,设该置换对应的位置i的元素为n，令$\tau=(n-1\ n)…(i+1\ i+2)(i\ i+1)\sigma$，依次计算，即为将$\sigma$的第i个元素和第i+1个元素对换，第i+1个元素和第i+2个元素对换…最终可以将元素n换到第n个位置，即$\tau$为（n-1）元置换；将上式进行整理，原n元置换可以写为$\sigma=(i+1\ i+2)(i\ i+1)…(n-1\ n)\tau$，根据归纳假设，$\tau$可以写为(1 2),(2 3),…,(k-1,k)的乘积，因此$\sigma$可以写为(1 2),(2 3),…,(n-1,n)的乘积。</p><p>综上所述，任何n元置换都可以表示成(1 2),(2 3),…,(n-1,n)的乘积。</p><p>方法2：</p><p>任何置换都可以表示为成不相交的轮换之积，任何轮换都可以表示成对换之积，因此只需讨论将对换表示为(1 2),(2 3),…,(n-1,n)的乘积。对换$(a_i\ a_j),i&gt;j$可表示为$(a_{i+1}\ a_{i+2})…(a_{j-2}\ a_{j-1})(a_{j-1}\ a_{j})…(a_{i+1}\ a_{i+2})(a_i\ a_{i+1})$从而得证。</p><p><strong>3.17 求证下列恒等式</strong></p><p><strong>（1）$x_1=x_1x_2x_3+x_1\overline x_2x_3+x_1x_2\overline x_3+x_1\overline x_2\overline x_3$</strong></p><p><strong>$x_1=x_1(x_2+\overline x_2)(x_3+\overline x_3)=x_1x_2x_3+x_1\overline x_2x_3+x_1x_2\overline x_3+x_1\overline x_2\overline x_3$</strong></p><p><strong>（2）$x_1x_2+x_2x_3+x_3\overline x_1=x_1x_2+\overline x_1x_3$</strong></p><p><strong>$x_1x_2+x_2x_3+x_3\overline x_1=x_1x_2+x_2x_3(x_1+\overline x_1)+x_3\overline x_1 = x_1x_2(1+x_3)+\overline x_1x_3(x_2+1)=x_1x_2+\overline x_1x_3$</strong></p><p><strong>注意：开关函数的运算中$a+c=b+c$无法推出$a=b$</strong></p><h4 id="补充习题"><a href="#补充习题" class="headerlink" title="补充习题"></a>补充习题</h4><p>注意，在置换/对换/轮换的计算中，乘积要从右往左计算，轮换的计算方式是将每个元素映射到右边的位置。</p><h4 id="第四章-二元关系"><a href="#第四章-二元关系" class="headerlink" title="第四章 二元关系"></a>第四章 二元关系</h4><h4 id="内容回顾-1"><a href="#内容回顾-1" class="headerlink" title="内容回顾"></a>内容回顾</h4><p>关系</p><ul><li>关系的定义：<ul><li>相关概念：空关系（平凡关系），全关系</li></ul></li><li>关系的性质：判断是否具有某种性质<ul><li>自反性，反自反性，对称性，反对称性，传递性</li></ul></li><li>关系的表示：<ul><li>有序二元组：$xRy$</li><li>关系矩阵：$mij=\begin{cases}0,a_iR\mkern-10.5mu/ a_j\\1,a_iRa_j\end{cases} $</li><li>关系图：如果有$a_iRa_j$，则画一条由$a_i$指向$a_j$的有向弧（环）</li></ul></li><li>关系的运算：<ul><li>相等，$&lt;,\leq,&gt;,\geq$</li><li>并交补运算（交换律，结合律）</li><li>复合关系 ：结合律，幂运算$R^n=R^m\circ R1^{n-m}$</li><li>自反闭包：包含R且满足自反性质的最小关系</li><li>对称闭包，传递闭包</li></ul></li></ul><p>等价关系</p><ul><li>满足自反，对称，传递</li><li>等价类$[a]_R$，代表元</li><li>集合的划分与集合上的等价关系一一对应（划分相同——等价关系本质相同） </li><li>A/R：关于等价关系R的商集</li></ul><p>序关系</p><ul><li>$\preceq$：自反，反对称，传递；偏序集$<a,\preceq>$<ul><li>可比较/不可比较</li></ul></a,\preceq></li><li>线序关系：任意两个元素都是可比较的（完全序关系）</li><li>序关系中的控制关系：y控制x，即$x\hat \preceq_\neq y$，且不存在$z,x\hat \preceq_\neq z ,z\hat\preceq_\neq y$</li><li>极大元，极小元</li><li>哈希图：<em>最上方是极大元，最下方是极小元</em></li><li>最大元，最小元<ul><li>最大元一定是极大元，最大元至多一个</li></ul></li><li>（子集的）上界/下界：不一定有，不一定唯一<ul><li>最小上界/上确界；最大下界/下确界</li></ul></li></ul><p>集合的势</p><ul><li>等势：$A \sim B$：存在双射<ul><li>$\mathscr P(E)$上的等价关系</li></ul></li><li>有限集合</li><li>可数集合 ；可数无限集合：与自然数集合等势的集合</li><li>势的大小；支配：A和B的一个子集等势，则称B支配A，$A\preceq B$：偏序关系</li><li>$A\prec \mathscr P(A) $</li><li>无限集合<ul><li>每个无限集合都有一个可数无限子集</li><li>每个无限集合都和它的某个真子集集合等势</li></ul></li></ul><h4 id="作业题目-1"><a href="#作业题目-1" class="headerlink" title="作业题目"></a>作业题目</h4><p><strong>4.7.设$A=\{1,2,3,4\},$在$\mathscr{P} (A)$上定义关系“$\sim$”。任给$S,T\in \mathscr{P}(A)$,</strong></p><script type="math/tex; mode=display">S\sim T,当且仅当\quad |S|=|T|</script><p><strong>证明：“$\sim$”是$\mathscr{P}(A)$上的等价关系，并写出它的商集$\mathscr{P}(A)/\sim$。</strong></p><ul><li>自反性：$\forall S\in \mathscr P(A),|S|=|S|\Rightarrow S\sim S$</li><li>对称性：$\forall S,T\in \mathscr P(A),S\sim T\Rightarrow |S|=|T|\Rightarrow |T|=|S|\Rightarrow T\sim S$</li><li>传递性：$\forall S,T,V\in \mathscr P(A),S\sim T,T\sim V$</li></ul><p>商集：$\{\{\empty\},\\\{\{1\},\{2\},\{3\},\{4\}\},\\\{\{1,2\},\{1,3\},\{1,4\},\{2,3\},\{2,4\},\{3,4\}\},\\\{\{1,2,3\},\{1,2,4\},\{1,3,4\},\{2,3,4\}\},\\\{\{1,2,3,4\}\}\}$</p><p><strong>4.16.$A=\{a_1,a_2,…,a_n,…\}$是任意集合。在偏序集$&lt;\mathscr{P}(A),\subseteq&gt;$中取子集序列$\{a_1\},\{a_1,a_2\},\{a_1,a_2,a_3\},…,\{a_1,a_2,…,a_n,\},…$,它们的并集是否是$\mathscr{P}(A)$的一个极大元？为什么？</strong></p><ul><li>若A为有限集合，显然子集序列的并集为极大元（反证法）</li><li>若A是可数无限集合，则并集P可能是极大元，也可能不是极大元。举例：设A为自然数集合<ul><li>是极大元： $a_i=i-1,\{a_1,a_2,…a_n,…\}=\{0,1,….n,..\}=A$</li><li>不是极大元：$a_i=i,\{a_1,a_2,…a_n,…\}=\{1,2,…n,…\}\subset A$</li></ul></li><li>若A是不可数集合，则一定不是极大元，否则并集$P=A,{a_1,a_2,…a_n,…}$列举出了A的所有元素，与A是不可数集合矛盾。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;2023spring代数结构习题课讲义&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;代数结构-第一次习题课&quot;&gt;&lt;a href=&quot;#代数结构-第一次习题课&quot; class=&quot;headerlink&quot; title=&quot;代数结构 第一次习题课&quot;&gt;&lt;/a&gt;代数结构 第一次习</summary>
      
    
    
    
    <category term="代数结构" scheme="http://sn1987a-1.github.io/categories/%E4%BB%A3%E6%95%B0%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="专业课" scheme="http://sn1987a-1.github.io/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>基于GPT-2的chatbot</title>
    <link href="http://sn1987a-1.github.io/posts/156324.html"/>
    <id>http://sn1987a-1.github.io/posts/156324.html</id>
    <published>2022-05-17T15:12:20.000Z</published>
    <updated>2023-09-23T13:14:31.422Z</updated>
    
    <content type="html"><![CDATA[<h1 id="chatbot设计"><a href="#chatbot设计" class="headerlink" title="chatbot设计"></a>chatbot设计</h1><p><strong>该项目的仓库链接：<a href="https://github.com/Wonderful-Me/GPT-Chinese">https://github.com/Wonderful-Me/GPT-Chinese</a></strong></p><h2 id="信息爬取"><a href="#信息爬取" class="headerlink" title="信息爬取"></a>信息爬取</h2><p>本部分通过网络爬虫实现了实时信息的获取，比如查询每日各个省份疫情的情况以及天气情况，微博热点新闻。在输入端输入对应的查询请求后，聊天机器人便可以伪装成浏览器访问对应的网站爬取数据并挑选出需要的数据并返回。</p><h3 id="新冠疫情"><a href="#新冠疫情" class="headerlink" title="新冠疫情"></a>新冠疫情</h3><p>聊天人可以识别与“新冠疫情”相关的问题，自动爬取各个省份今日新冠疫情的新增情况，具体实现功能如下：</p><ul><li>查询省份：可以对某个省份的疫情状况（新增确诊和新增无症状）</li><li>点击右下方链接即可跳转到相关网站查询详情</li><li>通过echarts柱状图显示各个省份的确诊情况，支持拖动和缩放</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#alist 存储城市名，新增确诊和新增无症状</span><span class="token keyword">for</span> i <span class="token keyword">in</span> citylist<span class="token punctuation">:</span><span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token punctuation">[</span><span class="token string">'today'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'wzz_add'</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>          clist<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>i<span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>i<span class="token punctuation">[</span><span class="token string">'today'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'confirm'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>     <span class="token keyword">else</span><span class="token punctuation">:</span>        clist<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>i<span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">[</span><span class="token string">'today'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'confirm'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">[</span><span class="token string">'today'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'wzz_add'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="今日热搜"><a href="#今日热搜" class="headerlink" title="今日热搜"></a>今日热搜</h3><p>聊天机器人可以识别与“今日热搜”相关的问题，自动爬取当前的微博热搜，具体功能如下：</p><ul><li>返回当前热搜中热度最高的新闻资讯</li><li>点击热搜内容的文本即可跳转至热搜的链接了解详情</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">response <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"https://weibo.com/ajax/side/hotSearch"</span><span class="token punctuation">)</span>data_json <span class="token operator">=</span> response<span class="token punctuation">.</span>json<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'data'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'realtime'</span><span class="token punctuation">]</span><span class="token keyword">for</span> data_item <span class="token keyword">in</span> data_json<span class="token punctuation">:</span>    dic <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token comment">#微博词条的网址为'https://s.weibo.com/weibo?q=%23' + 词条名称 + '%23'</span>        <span class="token string">'title'</span><span class="token punctuation">:</span> data_item<span class="token punctuation">[</span><span class="token string">'note'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token string">'url'</span><span class="token punctuation">:</span> <span class="token string">'https://s.weibo.com/weibo?q=%23'</span> <span class="token operator">+</span> data_item<span class="token punctuation">[</span><span class="token string">'word'</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">'%23'</span><span class="token punctuation">,</span>        <span class="token string">'num'</span><span class="token punctuation">:</span> data_item<span class="token punctuation">[</span><span class="token string">'num'</span><span class="token punctuation">]</span>         <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="天气查询"><a href="#天气查询" class="headerlink" title="天气查询"></a>天气查询</h3><p>聊天机器人可以识别与“今日天气”相关的问题，并且根据输入的城市爬取该城市的当日天气的详细情况。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#将输入的汉字用Pinyin转化为拼音字符串</span>city_pinyin<span class="token operator">=</span>p<span class="token punctuation">.</span>get_pinyin<span class="token punctuation">(</span>sentence<span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token comment">#通过'https://www.tianqi.com/'+城市的拼音名即可访问目的城市天气</span><span class="token keyword">try</span><span class="token punctuation">:</span>    url <span class="token operator">=</span> <span class="token string">'https://www.tianqi.com/'</span><span class="token operator">+</span>city_pinyin    r <span class="token operator">=</span> urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>Request<span class="token punctuation">(</span>url<span class="token operator">=</span>url<span class="token punctuation">,</span> headers<span class="token operator">=</span>headers<span class="token punctuation">)</span><span class="token keyword">except</span> urllib<span class="token punctuation">.</span>error<span class="token punctuation">.</span>URLError <span class="token keyword">as</span> e<span class="token punctuation">:</span><span class="token comment">#查找失败</span>     <span class="token keyword">return</span> <span class="token string">"抱歉哈，找不到你所输入的城市"</span><span class="token comment">#查找成功，利用beautifulsoup依次查找要找出的信息</span>weather<span class="token punctuation">.</span>append<span class="token punctuation">(</span>soup<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>text<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="web前端"><a href="#web前端" class="headerlink" title="web前端"></a>web前端</h2><p>聊天机器人的前端效果如下所示：</p><p><img src="E:/2022spring/CSii/chatbot/bot_mywork/report_img/s1.png" alt="s1"></p><h3 id="输入框"><a href="#输入框" class="headerlink" title="输入框"></a>输入框</h3><p>每次按下按钮’发送’，且输入框不为空时，即可向机器人发送一条数据。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>b-footer<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>f-left<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>输入你想说的话...<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>btn<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>发送<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h3><ul><li><p>发送完信息后，在对话框弹出该条文本，在机器人正在生成回答时显示加载动画</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">".b-body"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"&lt;div class='mWord'&gt;&lt;span&gt;&lt;img  src=\"p1.png\" /&gt;&lt;/span&gt;&lt;p&gt;"</span> <span class="token operator">+</span> text<span class="token punctuation">.</span><span class="token function">val</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"&lt;/p&gt;&lt;/div&gt;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//在对话框'b-body'中将输入信息以mWord的格式添加新的Div标签，内容包含输入的文本信息和头像图片</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">".b-body"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"&lt;div class='wait'&gt;&lt;span&gt;&lt;img  src=\"p2.png\" /&gt;&lt;/span&gt; &lt;p&gt;&lt;/p&gt;&lt;div class='Ball'&gt;&lt;/div&gt;&lt;/div&gt;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//显示加载动画</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">".b-body"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">scrollTop</span><span class="token punctuation">(</span><span class="token number">10000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将对话界面拉到页面最下方显示最新对话</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>机器人将回复信息返回前端</p></li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.wait'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除加载动画标签</span><span class="token keyword">if</span><span class="token punctuation">(</span>result<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'&lt;'</span><span class="token punctuation">)</span><span class="token comment">//返回的内容为可以点击跳转的链接格式</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">".b-body"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"&lt;div class='rotWord'&gt;&lt;span&gt;&lt;img src=\"p.png\"/&gt;&lt;/span&gt; "</span> <span class="token operator">+</span> result <span class="token operator">+</span> <span class="token string">"&lt;/div&gt;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token comment">//返回的内容为普通文本</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">".b-body"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"&lt;div class='rotWord'&gt;&lt;span&gt;&lt;img src=\p.png\" /&gt;&lt;/span&gt; &lt;a id='member'&gt;"</span> <span class="token operator">+</span> result <span class="token operator">+</span> <span class="token string">"&lt;/a&gt;&lt;/div&gt;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">".b-body"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">scrollTop</span><span class="token punctuation">(</span><span class="token number">10000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间信息</li></ul><p>每隔一分钟显示一次当前时间信息，如图所示：</p><p><img src="E:/2022spring/CSii/chatbot/bot_mywork/report_img/s3.png" alt="s3" style="zoom:47%;"></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">setDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">!=</span> d<span class="token punctuation">.</span><span class="token function">getMinutes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span><span class="token comment">//m为已记录的时间信息，在对话时每分钟更新m，在对话框中显示当前时间</span>  m <span class="token operator">=</span> d<span class="token punctuation">.</span><span class="token function">getMinutes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">".b-body"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'&lt;div class="timestamp"&gt;'</span> <span class="token operator">+</span><span class="token string">'-------'</span><span class="token operator">+</span> d<span class="token punctuation">.</span><span class="token function">getHours</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">':'</span> <span class="token operator">+</span> m <span class="token operator">+</span><span class="token string">'-------'</span><span class="token operator">+</span> <span class="token string">'&lt;/div&gt;'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CSS渲染"><a href="#CSS渲染" class="headerlink" title="CSS渲染"></a>CSS渲染</h3><ul><li>静态渲染：<ul><li>背景和文本框的渐变色</li><li>边框圆角效果</li><li>a对话框半透明效果</li><li>阴影效果</li></ul></li></ul><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">-webkit-linear-gradient</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span> #xxx 0<span class="token punctuation">,</span> ...<span class="token punctuation">,</span> #xxx 100%<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*渐变效果*/</span><span class="token property">color</span><span class="token punctuation">:</span> <span class="token function">rgba</span><span class="token punctuation">(</span>55<span class="token punctuation">,</span> 55<span class="token punctuation">,</span> 55<span class="token punctuation">,</span> 0.3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*0.3为透明度*/</span><span class="token property">border-radius</span><span class="token punctuation">:</span> 15px<span class="token punctuation">;</span><span class="token comment">/*圆角效果*/</span><span class="token property">box-shadow</span><span class="token punctuation">:</span> 10px -5px 20px 10px #xxx<span class="token punctuation">;</span><span class="token comment">/*阴影效果*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>动态渲染</p><ul><li>加载动画,循环播放三个跳动的点</li></ul><p><img src="E:/2022spring/CSii/chatbot/bot_mywork/report_img/s2.png" alt="s3" style="zoom:47%;"></p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.dot</span> <span class="token punctuation">{</span><span class="token comment">/*基本属性*/</span><span class="token property">animation</span><span class="token punctuation">:</span> pulse-outer 7.5s infinite ease-in-out<span class="token punctuation">;</span><span class="token comment">/*动画形式*/</span>  <span class="token punctuation">}</span><span class="token selector">.dot:nth-child(2)</span> <span class="token punctuation">{</span><span class="token comment">/*第二个点*/</span><span class="token property">left</span><span class="token punctuation">:</span> 65px<span class="token punctuation">;</span><span class="token comment">/*偏移*/</span><span class="token property">animation</span><span class="token punctuation">:</span> pulse-inner 7.5s infinite ease-in-out<span class="token punctuation">;</span><span class="token property">animation-delay</span><span class="token punctuation">:</span> 0.2s<span class="token punctuation">;</span><span class="token comment">/*动画延迟*/</span> <span class="token punctuation">}</span><span class="token comment">/*第三个点...*/</span><span class="token atrule"><span class="token rule">@keyframes</span> pulse-outer</span> <span class="token punctuation">{</span><span class="token selector">0%</span> <span class="token punctuation">{</span> <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">scale</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token selector">...100%</span> <span class="token punctuation">{</span> <span class="token property">height</span><span class="token punctuation">:</span> 17.5px<span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>新消息弹出动画：在产生新对话时，对新弹出的文本框进行一次缩放，实现弹出的效果</li></ul><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.Word</span><span class="token punctuation">{</span><span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">scale</span><span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token property">transform-origin</span><span class="token punctuation">:</span> 0 0<span class="token punctuation">;</span><span class="token property">animation</span><span class="token punctuation">:</span> bounce 350ms linear both<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token atrule"><span class="token rule">@keyframes</span> bounce</span> <span class="token punctuation">{</span> <span class="token selector">0%</span><span class="token punctuation">{</span><span class="token property">transform</span><span class="token punctuation">:</span><span class="token function">matrix3d</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 1<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token selector">...100%</span><span class="token punctuation">{</span><span class="token property">transform</span><span class="token punctuation">:</span><span class="token function">matrix3d</span><span class="token punctuation">(</span>1<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 1<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 1<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>动态LOGO：参考了<a href="https://dribbble.com/shots/10133153-Chatbot">Dribbble</a>的模型</li></ul><p><img src="E:/2022spring/CSii/chatbot/bot_mywork/report_img/s4.png" alt="s3" style="zoom:47%;"></p></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><p>echarts柱状图</p><ul><li>利用了echarts模型，当询问新冠疫情的信息时，可以弹出如图所示柱状图，更直观地观察数据</li></ul><p><img src="E:/2022spring/CSii/chatbot/bot_mywork/report_img/s5.png" alt="s3" style="zoom:50%;"></p></li><li><p>动态跳转按钮</p><ul><li>对于一些实时信息的查询，为了方便进一步了解详情，添加可以跳转的按钮</li></ul><p><img src="E:/2022spring/CSii/chatbot/bot_mywork/report_img/s6.png" alt="s3" style="zoom:50%;"></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#btn2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>is_ask<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//正在查询信息</span>window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>href<span class="token operator">=</span><span class="token string">"https://xxx"</span><span class="token punctuation">;</span><span class="token comment">//在新标签页打开链接</span><span class="token keyword">else</span>location<span class="token punctuation">.</span><span class="token function">reload</span><span class="token punctuation">(</span><span class="token punctuation">[</span>bForceGet<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//停留在原页面</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="前后端交互"><a href="#前后端交互" class="headerlink" title="前后端交互"></a>前后端交互</h2><p>聊天机器人前后端的信息交互和同步部分是通过Flask框架和Ajax（异步JavaScript和XML）实现的。数据交互的基本模式如下：</p><p>Javascript部分:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#btn"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>  <span class="token function">chatbot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//每次检测到"发送"按钮按下且输入不为空时触发</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> args<span class="token operator">=</span> <span class="token punctuation">{</span>url<span class="token operator">:</span> <span class="token string">"url"</span><span class="token punctuation">,</span><span class="token comment">//与python函数对应的"URL"相同</span>type<span class="token operator">:</span> <span class="token string">"GET"</span><span class="token punctuation">,</span><span class="token comment">//"GET"或"POST"</span>              <span class="token comment">//"GET"用于后端向前端发送信息,"POST"用于将输入的文字传到后端</span><span class="token function-variable function">success</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">options</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>$<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>python部分：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>route</span><span class="token punctuation">(</span><span class="token string">'/url'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">get_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    data<span class="token operator">=</span>func<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> data<span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>route</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>route</span><span class="token punctuation">(</span><span class="token string">'/index'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> render_template<span class="token punctuation">(</span><span class="token string">'index.html'</span><span class="token punctuation">)</span>    <span class="token operator">//</span>默认显示的主页<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当用户在前端输入想要对机器人说的话，便可利用JS中的Ajax工具向后端传输数据，并获取后端发的数据返回到聊天框中，这样就完成了一组对话；另外，对于新冠疫情确诊柱状图的更新，也是通过Ajax将爬取到的数据传入JS的函数中完成的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;chatbot设计&quot;&gt;&lt;a href=&quot;#chatbot设计&quot; class=&quot;headerlink&quot; title=&quot;chatbot设计&quot;&gt;&lt;/a&gt;chatbot设计&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;该项目的仓库链接：&lt;a href=&quot;https://github.c</summary>
      
    
    
    
    <category term="CSII" scheme="http://sn1987a-1.github.io/categories/CSII/"/>
    
    
    <category term="chatbot" scheme="http://sn1987a-1.github.io/tags/chatbot/"/>
    
  </entry>
  
  <entry>
    <title>ChatBot</title>
    <link href="http://sn1987a-1.github.io/posts/26753.html"/>
    <id>http://sn1987a-1.github.io/posts/26753.html</id>
    <published>2022-04-26T07:35:11.000Z</published>
    <updated>2023-09-23T13:14:52.332Z</updated>
    
    <content type="html"><![CDATA[<h2 id="the-design-of-CHatBot"><a href="#the-design-of-CHatBot" class="headerlink" title="the design of CHatBot"></a>the design of CHatBot</h2><h2 id="some-resources"><a href="#some-resources" class="headerlink" title="some resources"></a>some resources</h2><p><strong>GPT-2 中文文本生成</strong></p><p><strong>Re-Subject：</strong></p><ol><li><p><strong>采用此组合为主要的参考内容，其他的为辅</strong></p><p><a href="https://github.com/yangjianxin1/GPT2-chitchat">https://github.com/yangjianxin1/GPT2-chitchat</a></p><p>（近期也在开始琢磨这个项目）</p><blockquote><p><strong>使用指南见：</strong><a href="https://blog.csdn.net/g534441921/article/details/104312983">GPT-2生成式多轮对话入门——-深入理解“用于中文闲聊的GPT2模型”项目_三重极简的博客-CSDN博客_gpt2</a></p></blockquote></li><li><p><a href="https://github.com/thu-coai/CDial-GPT【[论文](GPT.pdf)】">https://github.com/thu-coai/CDial-GPT【[论文](GPT.pdf)】</a></p></li><li><p><a href="https://github.com/Morizeyao/GPT2-Chinese【信度高、体量大">https://github.com/Morizeyao/GPT2-Chinese【信度高、体量大</a> / 相关面广，下辖可选项多】</p></li><li><p><a href="https://github.com/hughqiu/GPT2-Chinese">hughqiu/GPT2-Chinese: Chinese version of GPT2 training code, using BERT or BPE tokenizer. (github.com)</a> 【中意】</p><blockquote><p><strong>使用指南见：</strong><a href="https://blog.csdn.net/qq_44543774/article/details/116379722">GPT-2中文文本训练及生成_是木子啦~的博客-CSDN博客_gpt2中文生成</a></p></blockquote></li></ol><p><strong>数据集来源：</strong></p><ol><li><a href="https://github.com/brightmart/nlp_chinese_corpus">大规模中文自然语言处理语料 Large Scale Chinese Corpus for NLP (github.com)</a></li><li><a href="http://thuctc.thunlp.org/#中文文本分类数据集THUCNews">THUCTC: 一个高效的中文文本分类工具 (thunlp.org)</a></li></ol><h2 id="the-part-I’m-responsible-for"><a href="#the-part-I’m-responsible-for" class="headerlink" title="the part I’m responsible for"></a>the part I’m responsible for</h2><h3 id="Front-end-development"><a href="#Front-end-development" class="headerlink" title="Front-end development"></a>Front-end development</h3><p>use HTML,css,js…</p><p>there are several ideas I come up with.</p><ul><li>the basic chat frame</li><li>the easy animination</li><li>the loading animination(write a javascript function to generate a “div” when clicked and remove it after calculating)</li><li>show time once a minute</li><li>so on…</li></ul><p>it seems this part has been finished</p><p>still need to combine it with others code</p><p>the animination in the left is inspired by <a href="https://copepen.io">https://copepen.io</a></p><h3 id="patterned-answers"><a href="#patterned-answers" class="headerlink" title="patterned answers"></a>patterned answers</h3><p>use regular expressions or <code>import jieba</code> to deal with the input(jieba can deal the input in a loop)</p><p>write a crawler to get the current information like the weather …</p><p><strong>import some database like wikipedia </strong></p><p>reference: <a href="https://github.com/brightmart/nlp_chinese_corpus#readme">https://github.com/brightmart/nlp_chinese_corpus#readme</a></p><p>keep on learning…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;the-design-of-CHatBot&quot;&gt;&lt;a href=&quot;#the-design-of-CHatBot&quot; class=&quot;headerlink&quot; title=&quot;the design of CHatBot&quot;&gt;&lt;/a&gt;the design of CHatBot&lt;/</summary>
      
    
    
    
    <category term="CSII" scheme="http://sn1987a-1.github.io/categories/CSII/"/>
    
    
    <category term="专业课" scheme="http://sn1987a-1.github.io/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>Knowledge Framework of OS PART II CH3</title>
    <link href="http://sn1987a-1.github.io/posts/22413.html"/>
    <id>http://sn1987a-1.github.io/posts/22413.html</id>
    <published>2022-03-07T07:35:11.000Z</published>
    <updated>2023-09-23T13:15:15.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Part-II"><a href="#Part-II" class="headerlink" title="Part II"></a>Part II</h1><h1 id="Process-Concept-amp-Operations"><a href="#Process-Concept-amp-Operations" class="headerlink" title="Process Concept &amp; Operations"></a>Process Concept &amp; Operations</h1><h2 id="Concepts-of-Process"><a href="#Concepts-of-Process" class="headerlink" title="Concepts of Process"></a>Concepts of Process</h2><p><strong> the building of processing </strong></p><ul><li>Pre-processor:like #define,#include —-try “gcc -E hello.c”</li><li>Compiler and Optimizer<ul><li>compiler:Syntax checking and analyzing</li><li>if no syntax:construct the intermediate codes</li><li>i.e,assembly</li><li>Optimizer :optimize the codes</li><li>check the parameter of gcc</li></ul></li><li>Assembler and Linker<ul><li>assembler assembles hello.s and generate hello.o</li><li>the linker puts together the objects files as well as library files</li></ul></li></ul><p>compile multiple files?</p><p>makefile</p><h2 id="What-is-a-process"><a href="#What-is-a-process" class="headerlink" title="What is a process"></a>What is a process</h2><h3 id="process-in-memory"><a href="#process-in-memory" class="headerlink" title="process in memory"></a>process in memory</h3><p>a program is a program in execution</p><ul><li>a executable file load into mermory</li><li>is Active</li><li><p>process in memory :</p><ul><li>text section:program code</li><li>stack</li><li>heap</li><li>data section</li><li>program counter </li><li>content of register</li></ul></li><li><p>process state</p><ul><li>a process executes changes states:</li><li>new</li><li>runnig</li><li>waiting :for I/O</li><li>ready—need CPU resources</li><li>terminated</li></ul></li></ul><p>the state diagram and the switch between</p><pre class="mermaid">graph LRA[new]--admitted--&gt;B[ready]C[wait]--I/O or event completion--&gt;BD[running]--interrupt--&gt;BD--I/O or event wait --&gt;CB--scheduler dispatch--&gt;DD--exit--&gt;E[terminated]</pre><h3 id="PCB—process-structure"><a href="#PCB—process-structure" class="headerlink" title="PCB—process structure"></a>PCB—process structure</h3><p><strong>How to locate /represent a process</strong></p><ul><li>PCB:process control block or task control block<ul><li>program state</li><li>program counter</li><li>CPU registers</li><li>CPU scheduling information</li><li>memory-management information</li><li>I/O status information</li><li>Accouting information<br>process data structure in Linux</li><li>represents by struct <em>task_struct</em> in C</li><li><linux sched.h=""></linux></li></ul></li></ul><p>the relationship between program data&amp; PCB</p><p>Conclusion on “what is a process”</p><ol><li>a program in execution</li><li>only one process can be running on any processor at any instant</li><li>two processes maybe associated with one program</li><li>a process can be an execution environment for other codes.</li></ol><h2 id="Process-Operations"><a href="#Process-Operations" class="headerlink" title="Process Operations"></a>Process Operations</h2><p>process:all the files,memory,accouting information</p><p>a system must provide the mechanism for:process identification,process creation,process execution,process termination</p><p>some basic system calls:</p><p>getpid(),fork(),exec*(),wait(),exit()</p><h3 id="Process-identification"><a href="#Process-identification" class="headerlink" title="Process identification"></a>Process identification</h3><ul><li>each process was given a unique id:process ID,<strong>PID</strong></li><li>use <code>getpid()</code></li><li>#include <unistd.h></unistd.h></li><li>‘.’:当前目录</li><li>use getpid()to check a program several times:get different PID<h3 id="Process-creation"><a href="#Process-creation" class="headerlink" title="Process creation"></a>Process creation</h3></li><li>a process may create several new processes<ul><li>parent process and chidren process </li></ul></li><li>the first process(the kernel runs when booting up)—-<code>init</code><ul><li>PID=1,is running the program code “/sbin/init”</li><li>the first task is to create more processes</li></ul></li><li>tree hierarchy<ul><li>all the process form a tree hierarchy</li><li>program blossoming:command to view tree:</li><li>“pstree” or “pstree -A”—-for ascii-character-only on display</li><li>the termination can be happen at any time:the parent terminate before the children:turn a tree hierarchy to a forest(a process become a orphan)</li><li><strong>orphan process</strong> may make a difference…become a tree ,and when it terminate nobody will know?</li><li>solve orphan process:re-parent operation</li><li>the relationship between parent and children<ul><li>resource sharing options:all/subset/no</li><li>execution options:execute concurrently/parent wait for children</li><li>address space options:a duplicate of parent/a new program loaded into it</li></ul></li></ul></li><li>to create :system call <code>fork()</code><ul><li><code>printf(...getpid()..);fork;print(...getpid());</code>:you will get three result(like 1234,1234,1235,not always cPID=pPID+1)</li><li>the last print executed twice</li><li>the fork():the parent and children executes the same codes,but not the same start:<strong>the children starts where the fork()is returned</strong>,the result of fork()will not loaded into children.</li><li>the parent process will run first,using the same files like program  counter and I/O devices<h3 id="program-execution"><a href="#program-execution" class="headerlink" title="program execution"></a>program execution</h3></li></ul></li><li>fork( ) can only duplicate and run the same program——-use <strong>exec( )</strong></li><li>execl( ) : a member of the exec() system call family(the family has 6 members),as an example<ul><li>example: …. execl(“/bin/ls”,”/bin/ls”,NULL);…. it means “ls”/or … execl(“/bin/ls”,”bin/ls”,”-l”,NULL)</li><li>$1^{st}$ argument:the program name</li><li>$2^{st}$ argument:the first argument to the program </li><li>$3^{rd}$ argument:the second argument to the program</li><li>$4^{th}$ argument:indicate the end of list of arguments</li></ul></li></ul><ul><li><strong>the word after this function will not be executed anyway——-no new process will be created and the PCB will not change ,but the code will be replaced,it will run till meeting “exit()”,and will not return the former program ,losing many data as well</strong></li><li>note:  fork() vs exec()</li><li><strong>fork()+exec()=?—</strong>(duplicate and then replace,the children will use exit(-1)to terminate)— write a system( ) library call——it will cause problem:the parents will first termination(actually cannot predict which will execute) </li><li>fork()+exec() is not enough ,use system call <strong>fork()+exec()+wait()</strong>: “<strong>suspend</strong> the executions of parent process挂起父进程””<strong>wake</strong> the parent up after the childern is terminated唤醒”</li></ul><p><strong>about wait()</strong></p><ul><li>when to wake up: when <strong>one of the child</strong> processes changes from running to terminated</li><li>does not suspend the calling process</li><li>wait():usage: wait(NULL),has many cases while using <ul><li>case 1:the wait()system  can suspend the calling parent process</li><li>case 2: the parent will not suspend if there is no child  process or there no running child process(still need time)</li></ul></li><li>more powerful wait?needs to <strong>wait for a particular  child or detect child status changing(wait()can only waits for ant of the child and detect the status termination only)</strong><ul><li>waitpid()—-read the man pages.</li><li>program termination</li></ul></li></ul><h3 id="make-a-summary"><a href="#make-a-summary" class="headerlink" title="make a summary"></a>make a summary</h3><p>a process is created by <strong>cloning</strong></p><ul><li>fork() :cloning is copying</li><li>exec()</li><li>wait()&amp;waitpid()</li></ul><p>the program exection is fundamental ,but not trivial:process is the place that hots a program and run it,and the exec*()changed the program the process is running,a process can run more than a program</p><h2 id="From-Kernel-Perspcetive"><a href="#From-Kernel-Perspcetive" class="headerlink" title="From Kernel Perspcetive"></a>From Kernel Perspcetive</h2><h3 id="dual-mode"><a href="#dual-mode" class="headerlink" title="dual mode"></a>dual mode</h3><p><strong>kernel-space &amp; user-space</strong>:</p><div class="table-container"><table><thead><tr><th></th><th style="text-align:center">kernel-space</th><th>user-space</th></tr></thead><tbody><tr><td>stored what</td><td style="text-align:center">kernel data structure,kernel program,driven devices</td><td>process memory,program code of the porcess</td></tr><tr><td>accessed by whom</td><td style="text-align:center">kernel code</td><td>user  program &amp; kernel code</td></tr></tbody></table></div><p>a program will switch its execution from user mode and kernel mode</p><p>(example : getpid() need to execute system call)</p><p><strong>user time &amp; system time</strong></p><p>user time : time spend on codes in user-space memory</p><p>system time : time spend on codes in kernel-space memory</p><p>total tunning time:user time + kernel time</p><p>use tool: time(<code>time ./filename</code>): total/user/sys time</p><p><img src="C:\Users\李\AppData\Roaming\Typora\typora-user-images\image-20220314142402862.png" alt="image-20220314142402862" style="zoom:67%;"></p><h3 id="the-system-call"><a href="#the-system-call" class="headerlink" title="the system call"></a>the system call</h3><h4 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h4><p>fork behaved like cell division </p><p>it create the child process by “cloning” form the parent process,including:</p><ul><li>program counter :CPU register ，that is why they both execute from the same line of code after fork() returns</li><li>Program code</li><li>memeory</li><li>opened files(kernel’s internal)</li></ul><p>does not clone:</p><ul><li>PID</li><li>return value of fork()</li><li>parent process</li><li>running time:just created ,is 0</li></ul><p>action: the start—kernel-space update—user-mode update —-finish</p><p>kernel-space updates: </p><ul><li>the running time will reset to 0</li><li>update pid</li><li>the paretnt will have a new child and the child will have a pointer to its parent.</li></ul><p>user -space update: copying…</p><blockquote><p>array of opened files :</p><p>array index:</p><p>0— standard of input stream :file *stdin</p><p>1— standard of output stream :file *stdout</p><p>2— standard error stream:file *stderr</p><p>3/beyond— storing the file you opened,e.g,fopen(),open,etc</p></blockquote><p>that’s why the parents process shares the same terminal output system with the child process</p><h4 id="exec"><a href="#exec" class="headerlink" title="exec*()"></a>exec*()</h4><p>action:start,end</p><p>process itself does not change</p><p>user-space memory: local veriable,dynamically-allocated memory will be cleared,and the global variable will reset based on new code,code + constant will changed to new program code</p><h4 id="wait-amp-exit"><a href="#wait-amp-exit" class="headerlink" title="(**)wait() \&amp;exit()"></a>(**)wait() \&amp;exit()</h4><p>exit()——child side : not really remove the child process ,remain the entry of the child in the process table(template state)</p><p>The child is now called zombie. Its storage in the kernel-space memory is kept to a minimum The PID (1235 in this example) and process structure are owned by the child.</p><p>wake up the parent: The kernel notifies the parent of the child process about the termination of its child. The notification is a signal called <strong>SIGCHLD</strong>.</p><p>signal:</p><p>• What is signal? – A software interrupt – It takes steps as in the hardware interrupt</p><p> • Two kinds of signals – Generated from user space </p><p>• Ctrl+C, kill() system call, etc. – Generated from kernel and CPU </p><p>• Segmentation fault (SIGSEGV), Floating point exception (SIGFPE), child process termination (SIGCHLD), etc. </p><p>• Signal is very hard to master, will be skipped in this course – Reference: Advanced Programming Environment in UNIX – Linux manpage</p><p>summary <strong>exit()</strong></p><p>Step (1) Clean up most of the allocated kernel-space memory. </p><p>Step (2) Clean up all user-space memory. </p><p>Step (3) Notify the parent with SIGCHLD</p><p>Although the child is still in the system, it is no longer running. There is no program code!!! It turns into a mindless zombie…</p><p>wait()——parent side: see the SIGCHLD signal and handle it.</p><p>The kernel sets a signal handling routine (and it is a function pointer) to the process. That signal handling routine will be executed when SIGCHLD comes.</p><p>By default, every process does not respond to the SIGCHLD signal (the signal handlers are set only when wait() is called). </p><p>When SIGCHLD comes, the signal handling routine is invoked! </p><p>Note: since the parent is still inside the system call, instead of the original program code, the parent process is still blocked in some sense…</p><p><strong>Default Handling of SIGCHLD</strong> </p><ol><li>Accept and remove the SIGCHLD; </li><li>Destroy the child process that sends her the signal.</li></ol><p><strong>case 2-</strong>—the wait() is called after the child already termintated,which is safe</p><p>in case 2,the SIGCHlD is also sent to parent before,and when the wait() is called ,it can return and kill the child process completely.</p><p>short summary of <strong>exit() &amp;wait()</strong></p><ul><li><p>A process is turned into a zombie when… </p><ul><li>The process calls exit(). </li><li>The process returns from main(). </li><li>The process terminates abnormally. <ul><li>You know, the kernel knows that the process is terminated abnormally. Hence, the kernel invokes exit() by itself.</li></ul></li></ul></li><li><p>Remember why exec*() does not return to its calling process in previous example…</p></li><li>wait() is to reap zombie child processes <ul><li>You should never leave any zombies in the system. </li></ul></li><li>Linux will label zombie processes as <code>&lt;defunct&gt;</code>. <ul><li>To look for them:<code>ps aux | grep defunct</code> </li></ul></li><li>Learn waitpid() by yourself…?</li></ul><p>If a orphan does not have a parent wait() when terminate—may init a new parent .</p><p>the role of wait() in the OS:</p><p>Why calling wait() is important – It is not about process execution/suspension… – It is about system resource management. </p><p>Think about it: – A zombie takes up a PID; – The total number of PIDs are limited; • Read the limit: “cat /proc/sys/kernel/pid_max” – What will happen if we don’t clean up the zombies?</p><h2 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h2><p>concepts:</p><ul><li>process data &amp; memoty</li><li>PCB+ user-space mermory</li></ul><p>operations</p><ul><li>fork()</li><li>exec*()</li><li>wait()+exit()——come together , calling wait() is imporrtant</li><li>so..what is the kernel  doing?…</li></ul><h1 id="Threads"><a href="#Threads" class="headerlink" title="Threads"></a>Threads</h1><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><h3 id="Motivation-of-Multi-Threading-and-Concepts"><a href="#Motivation-of-Multi-Threading-and-Concepts" class="headerlink" title="Motivation of Multi-Threading and Concepts"></a>Motivation of Multi-Threading and Concepts</h3><p>Thread concepts:why use , structure in memory, benefits and challenge, thread models</p><p>Progreamming :Basic programming;implicit threading</p><p>motivation: </p><ul><li>application side:most software applications are multithreaded,each application is implemented as a process with several threads of control.(web browser or wiord processor)<ul><li>still remember what kind of data are include in a process:</li><li>text data,statck,heap inuser-space memory</li><li>PCB in kernel-space memory</li></ul></li><li>system side:modern computers usually contain multicores,but each processor can run only one process ata time,so to improve the efficiency:<ul><li>assign one task to each core</li><li>real parallelism</li><li>the process cannot visit another process’s data and memory</li></ul></li></ul><p><strong>concurrency vs. parallelism</strong></p><h3 id="internals"><a href="#internals" class="headerlink" title="internals"></a>internals</h3><p>Code: </p><ul><li>all the threads use the same code.</li><li>a thread starts with onr specfic function——named it the thread function</li><li>a thread function can invoke other functions or system calls</li><li>a thread could never return to the caller of the thread function</li></ul><p>Global variables:</p><ul><li>all thread share the same global variable zone and the same dynamically allocated memory</li><li>all thread can read from and write to</li></ul><p>Local variables:</p><ul><li>each therad has its own memory range for local variable</li><li>so the stack is a private zone</li></ul><h3 id="Benefits"><a href="#Benefits" class="headerlink" title="Benefits"></a>Benefits</h3><ul><li>allow an application to do parallel tasks simulaneously</li><li>ease in data sharing</li><li>peocess share resources via shared memory or message passing</li><li>Economy<ul><li>allocation memory and resources for process creations is costly ,dozens of time tha creation threads…</li><li>context-switch between processes is also costly,several times of slower</li></ul></li><li>Scalablilty: thread may be running in parallel on different cores</li></ul><h3 id="programming-challenges"><a href="#programming-challenges" class="headerlink" title="programming challenges"></a>programming challenges</h3><ul><li>indentifying tasks: divide seperate and concurrent tasks</li><li>balance: tasks should perform equal work of equal value</li><li>data splitting: data must be divided to run on seperate cores</li><li>tdata dependency:synchronization is needed</li><li>testing and debugging </li></ul><h2 id="Thread-models"><a href="#Thread-models" class="headerlink" title="Thread models"></a>Thread models</h2><p>thread should include :</p><ul><li>data/resources in user-space memory</li><li>structure in kernel</li></ul><p>provide thread support:</p><ul><li>user thread: implement in user space</li><li>kernel thread: supported and managed by kernel</li></ul><p>1.<strong>many-to-one models</strong> :(many in user space and one in kernel)</p><ul><li>all the threads are mapped to one process structure in the kernel</li><li>easy for the kernel to implement </li><li>drawback:when a blocking system call is called ,all the thread will be <strong>blocked</strong></li><li>old UNIX &amp; green thread </li></ul><p>2.<strong>one-to-one</strong></p><ul><li>each thread is mapped to one process structure in the kernel</li><li>a high degree of <strong>concurrency</strong></li><li>drawback: cannot create too many threads as it is restricted by the size of the kernel memory</li><li>most Linux and Windows</li></ul><p>a process ,without multi-threading,is actually one thread for the scheduler.(when the schduler interets in process / thread)</p><p>3.<strong>many-to-many model</strong></p><ul><li>avoid drawbacks in many-to-one and one-to-one——cannot be blocked , have a high degree of concurrency</li><li>but most OS does not use man-to-many model(the drawback of one-to-one is not fatal)</li></ul><h2 id="Basic-Programming"><a href="#Basic-Programming" class="headerlink" title="Basic Programming"></a>Basic Programming</h2><p>Thread library——-provide the programmer with an API for creating and managing threads.</p><p>three main library threadings:</p><ul><li>POSIX Pthreads(user level or kernel level)</li><li>Windows (kernel level)</li><li>Java(implements using Windows API or Pthreads)</li></ul><h3 id="creating-multipule-threads"><a href="#creating-multipule-threads" class="headerlink" title="creating multipule threads"></a>creating multipule threads</h3><p>asynchronous threading </p><ul><li>parent resumes execution after creating a child </li><li>parent and child executes concurrency</li><li>each thread run independently</li></ul><p>synchronous threading</p><ul><li>fork-join strategy : parents wait for children to terminate<ul><li>significant data sharing</li></ul></li></ul><h3 id="Pthreads-process-is-similar-to-thread"><a href="#Pthreads-process-is-similar-to-thread" class="headerlink" title="Pthreads:  process is similar to thread"></a>Pthreads:  process is similar to thread</h3><div class="table-container"><table><thead><tr><th></th><th>process</th><th>thread</th></tr></thead><tbody><tr><td>creation</td><td>fork()</td><td>pthread_create()</td></tr><tr><td>I.D. type</td><td>PID,an integer</td><td>“pthread_t”,a structure</td></tr><tr><td>who am i?</td><td>getpid()</td><td>pthread_self()</td></tr><tr><td>wait for the child termination</td><td>wait() or waitpid()</td><td>pthread_join()</td></tr><tr><td>terminaion</td><td>exit()</td><td>pthread_exit()</td></tr><tr><td>kill?</td><td>kill()</td><td>pthread_kill()</td></tr></tbody></table></div><p>issue 1:create thread</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>   pthread_t tid<span class="token punctuation">;</span><span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tid<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>hello<span class="token punctuation">,</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//函数名和函数需要的参数</span><span class="token function">pthread_join</span><span class="token punctuation">(</span>tid<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">hello</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span> input<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>issue 2: passing parameter: local variable can be changed —-the stack of the new thread is on the same piece of the user-space memory as the main thread,not a new process,the pthread_create only create an address to the new thread ,the address is a pointer pointing to a variable stack of the main thread.</p><p>issue 3:multiple threads: </p><pre class="line-numbers language-c" data-language="c"><code class="language-c">pthread_t tid<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token function">pthread_create</span><span class="token punctuation">(</span>tid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>xxx<span class="token punctuation">,</span>xxx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token function">pthread_join</span><span class="token punctuation">(</span>tid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>issue 4: return value—-thread termination ,<strong>passing return value.</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void do_your_job(void *input){   ...   *output=.....;pthread_exit(output);}...pthread_join(tid,(void**)output);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>other threading — windows thread or java threads.</p><h2 id="Implicit-Threading"><a href="#Implicit-Threading" class="headerlink" title="Implicit Threading"></a>Implicit Threading</h2><ul><li><p>applications are containing hundreds or even thousands of threads</p><ul><li>program correctness is more difficult with explicit threads</li></ul></li><li><p>how to address the programming difficulties?</p><ul><li>transfer the creation and managements of the threadings from programmers  to compliers and run-time libraries</li><li>implicit threading</li></ul><p>two methods</p><p>1.thread pools</p><p>2.OpenMP</p></li></ul><h3 id="thread-pools"><a href="#thread-pools" class="headerlink" title="!!!thread pools"></a>!!!thread pools</h3><p>problem with multithreaded servers</p><ul><li>time required to create threads,which will be discarded once completed their work</li><li>unlimited threads could exhaust the system resources</li></ul><p>solve:</p><ul><li>thread pool</li><li>idea:create a number of threads in a pool where they wait for a work</li><li>procedure:<ul><li>awaken a thread if necessary</li><li>returns to the pool after completion</li><li>wait until one becomes free if the pools cpntains no available thread</li></ul></li><li>advantages<ul><li>usually sightly faster to service a request with an existing thread than create a new thread</li><li>allow the number of threads in the applications to be bound to the size of the pool</li></ul></li></ul><h3 id="OpenMP"><a href="#OpenMP" class="headerlink" title="OpenMP"></a>OpenMP</h3><p>provides supports for parallel programming in shared-memory environments</p><p>set of compliers directives and an API for C,C++,FORTRAN</p><h2 id="Threading-Issues"><a href="#Threading-Issues" class="headerlink" title="Threading Issues"></a>Threading Issues</h2><h3 id="semantics-of-fork-and-exec"><a href="#semantics-of-fork-and-exec" class="headerlink" title="semantics of fork() and exec()"></a>semantics of fork() and exec()</h3><p>1.<strong>fork():some UNIX has two versions:</strong></p><ul><li>the new process duplicates all threads </li><li>duplicates only the thread that invokes fork()</li></ul><p>exec(): usually work as normal:</p><ul><li>replace the running process ,includind all threads</li></ul><p>2.<strong>signal handling</strong></p><p>signals are used in UNIX systems to notify a process that a particular event has occurred</p><ul><li>asnychronous signal and synchronous signal</li><li>default handler or user-defined handler</li></ul><p>where should a signal be delivered in multi-thread program?</p><ul><li>to the thread signal applies</li><li>all the threads</li><li>a certain thread</li><li>assign  a specific thread to receive all the signals of all the threads</li></ul><p>deliver a signal to specific thread to receive all the signals for the process</p><p>3.<strong>thread cancellation</strong></p><p>terminating a thread before it has finished</p><p>two genernal approaches:</p><ul><li>asynchronous cancellation terminates the target thread immediately<ul><li>problem:troublesome then updating data</li></ul></li><li>defferred cancellation:allow the target thread to periodically check if it should be cancelled(can be cancelled safely)</li><li>three models: asynchronous,defferred,off(disabled cancellation)</li><li>default : defferred</li></ul><p>4.<strong>thread-local storage</strong></p><p>some applications ,each threads may needs its own copy of certain data.</p><p>thread-local stroage:TLS</p><ul><li>TLS is visible across function invocations</li><li>similar to static data</li><li>TLS data are untique to each thread</li></ul><h2 id="summary-of-thread"><a href="#summary-of-thread" class="headerlink" title="summary of thread"></a>summary of thread</h2><ul><li>virtually all morden OSes support multi-threading<ul><li>a thread is a basic unit of the CPU utilization</li><li>each comprises a thread ID,a program counter,a,register set,a stack</li><li>all the threads within a process share code section ,data,section,other resources like openfiles and signals</li></ul></li><li>take great care when writing multi-threaded programs,and also—<ul><li>mutual exclusion</li><li>synchronization</li></ul></li></ul><h1 id="Process-communication-amp-Synchronization"><a href="#Process-communication-amp-Synchronization" class="headerlink" title="Process communication &amp; Synchronization"></a>Process communication &amp; Synchronization</h1><p>the processes within a system may be</p><ul><li>independent</li><li>cooperating</li></ul><p>any process that  shares the data is a cooperating process</p><h2 id="interprocess-communication-—-IPC"><a href="#interprocess-communication-—-IPC" class="headerlink" title="interprocess communication —-IPC"></a>interprocess communication —-IPC</h2><p>two models:</p><ul><li>shared memory</li><li>message passing</li></ul><p>IPC is used for exchanging data between processes</p><p>cooperating processes need IPC for exchanging data</p><p>two nodels：</p><h3 id="shared-memory"><a href="#shared-memory" class="headerlink" title="shared memory"></a>shared memory</h3><ul><li>establish a shared memory region,read/write to share region</li><li>accesses are treated as routine memory accesses</li><li>faster</li></ul><p><strong>producer-consumer problem</strong></p><p>a buffer os needed to allow processes to run concurrently</p><p>the requirement: </p><p><strong>a buffer</strong> </p><p>is a shared object,and is a queue </p><p>problem: when producer wants to put  anew item but the buffer is already full</p><p>solution: the producer need to suepended ,and the consumer should wake the producer up after it has dequeue an item</p><p>problem: when comsumer wants to dequeue an item but it is empty</p><p>solution:  the consumer is suspended and the producer should wake the cinsumer up…</p><p><strong>a producer process</strong>  </p><p>produces a unit of data ,and writes that a piece of data to the tail of the buffer</p><p><strong>a consumer process</strong></p><p>removes a unit of data from the head of the bounded buffer at one time</p><h3 id="message-passing"><a href="#message-passing" class="headerlink" title="message passing"></a>message passing</h3><p>need a message queue to exchange</p><p>communictating processes may reside on different computer conntected by a network</p><p>IPC provide : <strong>send</strong>+<strong>receive </strong></p><ul><li>exchange message </li><li>require kernel intervention</li><li>easier to implement in a distributed system</li></ul><p>if two process wish to communicate,they need:</p><ul><li>establish a communication link between</li><li>exchange messages via send/receive</li></ul><p>issues:</p><ul><li>naming: direct/indirect<ul><li>direct:<ul><li>opreations: send and receive</li><li>properties of </li></ul></li><li>indirect communication<ul><li>allow a link to be associated with at most two processes</li><li>allow one process at  a time to execute a receive opreation</li><li>allow the system to select arbitrarily the receiver ,and sender is notified who the receiver is</li><li>the mailbox is owned by the process (ownership may be passed)and the OS(neede a method to create ,send/receive.delete)</li></ul></li></ul></li><li><p>synchronization : synchronous— blocking/asynchronous— non- blocking</p><ul><li>dofferent combinations :1.when the send and the receive are blocking , we have a rendezvous between the processes; 2. other conbinations need buffering</li></ul></li><li><p>buffering</p><ul><li>messages reside in a temporary queue , whic can be implemented in three ways:<ul><li>zero capacity—no message qre queued, sender must wait for the receiver(no buffering)</li><li>bounded capacity — finite length of n mesages,sender must wait if link is full</li><li>undounded capacity - infinite length,sender never waits</li></ul></li></ul></li></ul><h3 id="POSIX-shared-memory"><a href="#POSIX-shared-memory" class="headerlink" title="POSIX shared memory"></a>POSIX shared memory</h3><p>POSIX shared memory is orgranized using memory-mapped file,associate the region of shared memory with a file.</p><p>illustrate wth the producer-consumer problem:</p><p><strong>producer</strong></p><ul><li>create a shared memory object<ul><li>shm_fd=shm_open (name,O_CREAT |O_RDWR,0666);(perminssions )</li></ul></li><li>configure object size<ul><li>ftruncate(shm_fd,SIZE);</li></ul></li><li>establish a memory-mapped file containing the object<ul><li>prtr mmap(0,SIZE,PORT_WRITE),MAP_SHARED,shm_fd,0);(changes to the shared-memory object)</li></ul></li></ul><p><strong>consumer</strong></p><ul><li>open the shared-memory obect<ul><li>shm_fd=shm_open(name,O_RDONLY,0666);</li></ul></li><li>memory map the object<ul><li>ptr=mmap(0,SIZE,PORT_READ,MAP_SHARED,shm_fd,0);</li></ul></li><li>remove the shared memory object<ul><li>shp_unlink(name);</li></ul></li></ul><h3 id="Sockets"><a href="#Sockets" class="headerlink" title="Sockets"></a>Sockets</h3><p>a sockets is defined as an endpointer for communication(over a network)</p><ul><li>a pair of processes employ a pair of sockets</li><li>a socker is indentified by an IP address and a port number</li><li>all ports below 1024 are used for standard services<ul><li>telnet server listens to port 23</li><li>FTP server:port 21</li><li>HTTP server :port 80</li></ul></li></ul><p>Socket uses a client-server architecture</p><ul><li>server waits for incoming client request by listening to a specific port</li><li>accepts a connection from the client socket to complete the connection</li></ul><p>all connection must be unique(establishing a new connection on the same host needs another port&gt;1024)</p><p>special IP address 127.0.0.1(loopback)refers to itself</p><h3 id="Pipes"><a href="#Pipes" class="headerlink" title="Pipes"></a>Pipes</h3><p>Pipe ia <strong>a shared memory</strong></p><ul><li>using pipes is a way to realize IPC</li><li>acts as a conduit two processes to communicate</li></ul><p>issues :</p><ul><li>communication: unidirectional/bidirectional</li><li>half/full duplex</li><li>must the relationship exists between the communicating processes</li><li>pipes used over a network</li></ul><p>two common pipes: ordinary pipes and named pipes</p><p><strong>ordinary pipes</strong></p><ul><li>no name  in file system</li><li>only used for related process(parent-child relationship)</li><li>unidirectional </li><li>ceases to exit after communication has finished</li><li>allow communication in standard producer-consumer style<ul><li>producer write to one end and the consumer reads from the other end</li></ul></li></ul><p>UNIX pipe</p><ul><li>UNIX treats a pipe as a special file (child inherits it from parent)<ul><li>create : pipe(int fd[]);fd[0]-read end,fd[1]-write end</li><li>create accesses the ordinary read(),write()system calls</li><li>fork() duplicates parent’s file descriptors,and parents and child use each end of the pipe</li></ul></li><li>pipes are anonymous </li></ul><p><strong>named pipes</strong></p><ul><li>UNIX treats as typical file:mkfifo(), open(), read (), write(),close()</li><li>no parent-child relaitionship is necessary(or processes must reside one the same machine)</li><li>several processes can use the named pipes for communication</li><li>continue to exist</li><li>communication is bidiectional(still half-duplex)</li></ul><p><a href="staff.ustc.edu.cn/~ykli/os2022">课程主页</a></p><p>主观题规范：逻辑/语言规范           </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Part-II&quot;&gt;&lt;a href=&quot;#Part-II&quot; class=&quot;headerlink&quot; title=&quot;Part II&quot;&gt;&lt;/a&gt;Part II&lt;/h1&gt;&lt;h1 id=&quot;Process-Concept-amp-Operations&quot;&gt;&lt;a href=&quot;#Pro</summary>
      
    
    
    
    <category term="OS" scheme="http://sn1987a-1.github.io/categories/OS/"/>
    
    
    <category term="专业课" scheme="http://sn1987a-1.github.io/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>Knowledge Framework of OS PART I CH1&amp;CH2</title>
    <link href="http://sn1987a-1.github.io/posts/28913.html"/>
    <id>http://sn1987a-1.github.io/posts/28913.html</id>
    <published>2022-02-28T14:52:11.000Z</published>
    <updated>2023-09-23T13:15:19.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Knowledge-Framework-of-OS-PART-I-CH1-amp-CH2"><a href="#Knowledge-Framework-of-OS-PART-I-CH1-amp-CH2" class="headerlink" title="Knowledge Framework of OS :PART I CH1&amp;CH2"></a>Knowledge Framework of OS :PART I CH1&amp;CH2</h1><p>textbook: Operating System Concepts 10th Edition <a href="https://www.os-book.com/OS10/index.html">check</a></p><p>course home : <a href="http://staff.ustc.edu.cn/~ykli/os2022">http://staff.ustc.edu.cn/~ykli/os2022</a></p><h2 id="ch1-Overview-of-an-Operating-System"><a href="#ch1-Overview-of-an-Operating-System" class="headerlink" title="ch1 Overview of an Operating System"></a>ch1 Overview of an Operating System</h2><h3 id="system-organization"><a href="#system-organization" class="headerlink" title="system organization"></a>system organization</h3><p>computer-system organization</p><ul><li>One or more CPUs, device controllers connect through common bus providing access to shared memory </li><li>Concurrent execution of CPUs and devices competing for memory cycles</li><li><strong>I/O devices and the CPU</strong> can execute <strong>concurrently</strong></li><li>Each device controller is in charge of a particular device type</li><li>Each device controller has a local buffer </li><li>CPU moves data from/to main memory to/from local buffers </li><li>Device controller informs CPU that it has finished its operation by causing an <strong>interrupt</strong></li></ul><p>computer start-up</p><ol><li><strong>bootstrap program</strong> (启动程序)is loaded at power-up or reboot (firmware)</li><li>System processes or system daemons</li><li>After fully booted, waits for events to occur – Signaled by interrupt</li></ol><p><strong>interrupt handling</strong>  :can be triggered by hardware and software:</p><ol><li>Hardware sends signal to CPU </li><li>Software executes a special operation:<strong>system call</strong></li><li>procedure :CPU stop-&gt;executes the service routine-&gt;CPU resumes</li><li>operating system is interrupt driven</li><li>interrupt architecture must save the address of the interrupted instruction</li><li>interrupt timeline:</li></ol><p><img src="https://user-images.githubusercontent.com/74918703/155979009-4974c76f-6119-408f-a6e8-86ceb7b4b9d5.png" alt="image" style="zoom:80%;"></p><p>Interrupt transfers control to the interrupt service routine . A table of pointers to interrupt routines, the <strong>interrupt vector</strong>,can be used to provide necessary speed .The table of pointers is stored in low memory.</p><h3 id="Storage-Structure"><a href="#Storage-Structure" class="headerlink" title="Storage Structure"></a>Storage Structure</h3><p><img src="https://user-images.githubusercontent.com/74918703/155979598-8e6b2eb2-38a1-4280-b98c-bfbb41561456.png" alt="image" style="zoom: 80%;"></p><ul><li>Main memory :random access,typically small size and volatile(易失性)</li><li>Instruction-execution cycle 1.Fetch an instruction from memory and store in register – Decode instruction (fetch operands if necessary) 2. Store result back to memory</li><li>Secondary storage – extension of main memory that provides large nonvolatile storage capacity (like heard disks ,solid-state disks—faster and nonvolatile)</li><li>caching—small ,important principle,in hardware ,opearting system,software.</li><li>I/O structure:interrupt driven</li><li>Direct Memory Access Structure:Device controller transfers blocks of data from buffer storage directly to main memory without CPU intervention,one interrupt per block</li></ul><h3 id="System-Architecture-处理器"><a href="#System-Architecture-处理器" class="headerlink" title="System Architecture(处理器)"></a>System Architecture(处理器)</h3><p>CPU—most use a single general-purpose processor</p><p><strong>Multiprocessors system</strong>:parallel systems,multicore systems,</p><p>advances:Increased throughput;Economy of scale;Increased reliability</p><p>two types:</p><p><strong>SMP</strong>:symmetric multiprocessing,all processors are peers</p><p><img src="https://user-images.githubusercontent.com/74918703/155982308-fe37e15e-cef6-4597-9f3d-8591f500f1b8.png" alt="image" style="zoom:67%;"></p><p><strong>AM</strong>:asymmetric multiprocessing,boss-worker relationship</p><p>Multicore:: include multiple cores on a single chip .More efficient and less power</p><p><img src="https://user-images.githubusercontent.com/74918703/155982347-15bd8cd7-500d-483f-95c5-3d0ef6cfc6d1.png" alt="image" style="zoom:67%;"></p><p>distinguish:multicore &amp;SMP,multicore is more efficient but costs more.</p><p><strong>Clustered Systems</strong>:multiple systems working together</p><p>​        -<strong>SAN</strong>:storage-area network</p><p>​        -some are <strong>HPC</strong>:high-performance computing</p><p>​        -<strong>DLM</strong>:distributed lock manager,to avoid conflicting</p><p>So…</p><p>Where is the OS?</p><blockquote><p>Four components of a computer system </p><p>– Hardware – provides basic computing resources (CPU, memory, I/O devices) </p><p>– Users: People, machines, other computers</p><p> – App. programs – define the ways in which the sys. resources are used to solve the computing problems</p><p>​             • Word processors, compilers, web browsers, database systems, video games, etc.</p><p> – Operating system </p><p>​            • Controls and coordinates use of hardware among various applications and users</p></blockquote><p>What is the OS?</p><blockquote><p>•It stands between the hardware and the user. </p><p>– A program that acts as an intermediary between a user of a computer and the computer hardware </p><p>• Operating system goals: </p><p>– Execute user programs &amp; make solving user problems easier </p><p>– Make the computer system convenient to use</p><p> – Use the computer hardware in an efficient manner </p><p>– Design tradeoff between convenient and efficiency</p><p>• How good is this design? </p><p>– The user does not have to program the hardware directly</p><p>• Processes as the starting point! </p><p>– Whatever programs you run, you create processes. </p><p>​        • i.e., you need processes to open files, utilize system memory, listen to music, etc.</p><p> – So, process lifecycle, process management, and other related issues are essential topics of this course</p></blockquote><p>What Operating Systems Do?</p><ul><li>system view<ul><li>control program</li><li>resource alocator</li></ul></li><li>User view<ul><li>wanr convenience in use and performance</li><li>usability ,battery life, resource utilization,tradeoff…</li></ul></li></ul><p>well..OS has no universalyy accepted defination</p><h3 id="Operating-Systems-Operations"><a href="#Operating-Systems-Operations" class="headerlink" title="Operating Systems Operations"></a>Operating Systems Operations</h3><h4 id="OS-Operations"><a href="#OS-Operations" class="headerlink" title="OS Operations"></a>OS Operations</h4><p>control programs/resource allocator</p><ol><li><strong>Mutliprogramming</strong>:needed for efficiency,job run via job scheduling<ol><li>Time sharing,分时操作系统,logical extension in which CPU switches jobs so frequently that users can interact with each job while it is running, creating interactive computing</li><li>allow many user to share the computer</li><li>issues:– If several jobs ready to run at the same time:<strong>CPU scheduling</strong> . If processes don’t fit in memory, <strong>swapping</strong> moves them in and out to run . <strong>Virtual memory</strong> allows execution of processes not completely in memory</li></ol></li><li><strong>Interrupt Driven Mechanism</strong><ol><li>(in  Multiprogramming)software and hardware</li><li>Hardware interrupt by one of the devices</li><li>software :(exception or trap),needed to request for opaerating system service</li></ol></li><li><strong>Dual-mode Operation</strong>多模式操作<ol><li>user mode or kernel mode,and transistion between them</li></ol></li></ol><h4 id="system-call"><a href="#system-call" class="headerlink" title="system call"></a>system call</h4><p>system call is similar to a function call ,but it is inside the OS,named OS kernel</p><ul><li><p>System calls are the <strong>programming interface</strong> between processes and the OS kernel </p><ul><li>System calls provide the means for a user program to ask the operating system to perform tasks </li></ul></li><li><p>A system call usually takes the form of a trap to a specific location in the interrupt vector, <strong>treated by the hardware as a software interrupt</strong></p></li><li><p>The system call service routine is a part of the OS</p></li><li><p>usually primitive,important,fundamental(like time()system call)</p></li><li><p>Roughly speaking, we can categorize system calls as follows:</p><p>| Process  | FileSystem | Memory |<br>| ———— | ————— | ——— |<br>| Security | Device     |        |</p></li></ul><ul><li>distinguish between system call and library function call(library file:in windows :DLL dynameically linked library ,in Linux SO,shared objects)</li></ul><p>OS standards:</p><p><img src="https://user-images.githubusercontent.com/74918703/155991891-c2f45cd5-3191-424d-bd2a-f45d71deec7d.png" alt="image" style="zoom:67%;"></p><h3 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h3><h4 id="Process-vs-Program"><a href="#Process-vs-Program" class="headerlink" title="Process vs Program"></a>Process vs Program</h4><p>A process is an execution instance of a program,a process is not bounded to execute just one program.A process is active and has its own local states</p><p>command about processes like ps—report a vast amount of information about every process in system(try ps -ef)</p><p>shell—-a process launching pad</p><p><img src="https://user-images.githubusercontent.com/74918703/155994339-75d5f4d4-7244-40c0-93a4-a7238a658cee.png" alt="image" style="zoom:67%;"></p><p>System has many processes, some user, some operating system running concurrently</p><h4 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h4><p><img src="https://user-images.githubusercontent.com/74918703/155995958-b6202a2b-d093-4966-b04f-ec3f022fe50e.png" style="zoom:67%;"></p><p>Java don’t have the above layout,and C is too low</p><h4 id="Storage-Management"><a href="#Storage-Management" class="headerlink" title="Storage Management"></a>Storage Management</h4><p><strong>File System,FS</strong></p><p>like FAT16, FAT32, NTFS, Ext3, Ext4, BtrFS</p><p>a FS must record :directories,files,allocated,space,free space</p><p>Two face of a file system:1.storage design of the file system.(how it stored)2.the opreations of the file systems</p><p>operations:creating can be replaced by opening;copying can be replaced by read and write;moving can be replaced by rename(in one disks),so the necessary operations are open,read,write,close,rename,delete,..</p><p>A FS is independent of an OS,an OS can use many FS</p><h4 id="Kernal-Data-Structures"><a href="#Kernal-Data-Structures" class="headerlink" title="Kernal Data Structures"></a>Kernal Data Structures</h4><p>Lists,Trees,Hash Map and Bitmaps</p><h3 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h3><p><strong>Protection and Security</strong></p><p>this course will discuss the security of File System</p><p><strong>Computing Environments </strong></p><ul><li><p>trandition to mobile:IOS ,Android</p></li><li><p>Distributed computing ,like networkTCP/IP</p></li><li><p>Client-Server(C-S computing)</p></li><li><p>Peer-to-Peer computing—去中心化</p></li><li><p>Virtualization</p></li><li><p>Cloud Computing (较成熟)</p></li><li><p>Real-Time Embedded Systems</p></li></ul><p><strong>Open-sourced OS</strong></p><p>Open-Source Operating Systems—-GNU LINUX,BSD UNIX(including mac OS)</p><h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><ul><li>OS Overview <ul><li>OS Concept </li><li>Multiprogramming &amp; Multitasking </li><li>Dual Mode &amp; System Call </li></ul></li><li>OS Components <ul><li>Process Management </li><li>Memory Management </li><li>Storage Management </li></ul></li><li>Computer System Organization &amp; Architecture <ul><li>Interrupt</li></ul></li></ul><h2 id="ch2-Operating-System-Structures"><a href="#ch2-Operating-System-Structures" class="headerlink" title="ch2 Operating System Structures"></a>ch2 Operating System Structures</h2><h3 id="Operating-System-Services"><a href="#Operating-System-Services" class="headerlink" title="Operating System Services"></a>Operating System Services</h3><p><img src="https://user-images.githubusercontent.com/74918703/156001574-10982645-91ca-4540-9d1f-de15ab2b1a22.png" alt="image" style="zoom:67%;"></p><p>common classes :Convenience of the user and Efficiency of the system</p><p><strong>Operating systems provide an environment for execution of programs and services to programs and users</strong></p><h4 id="User-Operating-System-Interface"><a href="#User-Operating-System-Interface" class="headerlink" title="User Operating System Interface"></a>User Operating System Interface</h4><p>execution:1.Load a program into memory 2.run the program3.end execution(normally or abnormally)</p><p>for Helping Users</p><ul><li>I/O operations</li><li>File-system manipulation</li><li>communications</li><li>implementations:(<strong>shared memory and Message passing</strong>)</li><li>error detection,error types error handling<br>for Ensuring Efficiency</li></ul><p>for ensuring efficiency</p><ul><li>resource allocation</li><li>accounting—to keep track of</li><li>usage (usage statistics)</li><li>the protection and security </li></ul><p>for Helping Users</p><ul><li>user interface(UI)<ul><li>form: CLI(command line),Batch,GUI(Graphics User Interface)</li><li>CLI:shells,two ways of implementing commands:</li><li>1.The command interpreter itself contains the code • Jump to a section of its code &amp; make appropriate system call • Number of commands determines the size of CLI </li><li>2.Implements commands through system program (UNIX) • CLI does not understand the command • Use the command to identify a file to be loaded into memory and executed • Exp: rm file.txt (search for file rm, load into memory and exe w/ file.txt) • Add new commands easily</li></ul></li></ul><p>touchsreen interface…virtual keyboard?voice command</p><h4 id="System-Calls"><a href="#System-Calls" class="headerlink" title="System Calls"></a>System Calls</h4><p><strong>Programming interface</strong> to the service provided by the OS</p><p>Each OS ha its own Program Call</p><p>System Call &amp;&amp; function</p><p>Why us API?</p><p>for System Call,a simple program like copy may make heavy use of OS,and not user friendly</p><p>Mostly accessed by programs via a high-level API rather than direct system call use,and is easy of use(Simple programs may make heavy use of the OS)Program portability(Compile and run on any system that supports the same API )</p><p>remember the logic relationship between API and Program calls</p><p>API:application programming interface</p><p>common APIs:Win32 API for Windows,POSIX API,JAVA API(JAM,java virtual machine) </p><p>How to use API?</p><p>1.via a library of code provided by OS<br>2.Libc:UNIX/Linux with a C language</p><p>API-System Call-OS relationship</p><p><strong>Type of System Call</strong></p><ul><li>Process COntrol<ul><li>example: MS_DOS </li></ul></li><li>File Manipulation</li><li>Device Manipulation</li><li>Information Maintenance</li><li>Communications</li><li>Protection</li></ul><h3 id="Operating-System-Structure"><a href="#Operating-System-Structure" class="headerlink" title="Operating System Structure"></a>Operating System Structure</h3><p>掌握优势和问题，不需要记住例子</p><ul><li>simple structure :MS_DOS</li><li>Monolothic Structure :UNIX</li></ul><p>limited structing beyond simple but not fully layered</p><ul><li>Layered Approach</li></ul><p>not efficient</p><ul><li>Microkernel System Structure</li><li>Modules</li><li>Hybrid System:combine different systems structure</li></ul><p>Examples:Linux,Windows,Mac OS X structure,IOS,Android…</p><h3 id="Operating-System-Design-and-Implementation"><a href="#Operating-System-Design-and-Implementation" class="headerlink" title="Operating System Design and Implementation"></a>Operating System Design and Implementation</h3><p>… is not solvable</p><ol><li>first problem :design goals and specifications</li><li><p>improtant principle to separate(<strong>Mechanism</strong> for how to do  and <strong>policy</strong> for what will be done）<br>Examples (<strong>Timer Mechanism</strong> for CPU protection and <strong>Priority Mechanism</strong> in job scheduling)</p><p>benefits:maximum flexbility</p></li></ol><p>OS implementation</p><ul><li>much variation,earily in ass,now in C/C++</li><li>Acutually use a mix of language(body in C,lower levels in ass,system programs in C/C++,scripting language)</li><li>pros and cons </li></ul><h3 id="MISC-Debugging-Generation-amp-System-Boot"><a href="#MISC-Debugging-Generation-amp-System-Boot" class="headerlink" title="MISC:Debugging,Generation &amp;System Boot"></a>MISC:Debugging,Generation &amp;System Boot</h3><p><strong>debugging</strong> like GDB</p><ul><li>failure analysis:log files,core dump,crash dump</li><li>performance tuning: trace list of the system behavior &amp; interactive tools(top displays the resources of usage processes)</li><li>Kernighan’s LAW:”Debug is twice as hard as writing the code in the first place.Therefore,if you write the code as cleverly as possible,you are ,by defination,not smart to debug it.”</li></ul><p><strong>Operation system Generation</strong>—-OS is designed to run on any of a class of machines</p><p>the system must be configured or generate for each specific computer site</p><p>  <strong>SYSGEN</strong> program:it obtains the information concerning the specfic configuration of the hardware system</p><p><strong>system boot</strong></p><ul><li>system booting on most computer systems</li><li>common bootstrap loader allows selection of kernel from multipule disks,versions,kernel options</li></ul><p>Summary of part I :ch1&amp;ch2</p><ul><li><p>operating system overview ——<strong>multiprogramming &amp; multitasking</strong></p></li><li><p>OS operations:<strong>system call &amp; dual mode</strong></p></li><li>OS components</li><li>computing environment</li><li>OS structure</li><li>process managements</li><li>memory managements</li><li>storage managements</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Knowledge-Framework-of-OS-PART-I-CH1-amp-CH2&quot;&gt;&lt;a href=&quot;#Knowledge-Framework-of-OS-PART-I-CH1-amp-CH2&quot; class=&quot;headerlink&quot; title=&quot;Know</summary>
      
    
    
    
    <category term="OS" scheme="http://sn1987a-1.github.io/categories/OS/"/>
    
    
    <category term="专业课" scheme="http://sn1987a-1.github.io/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>以git-ftp为主的学习记录</title>
    <link href="http://sn1987a-1.github.io/posts/15203.html"/>
    <id>http://sn1987a-1.github.io/posts/15203.html</id>
    <published>2022-02-27T07:46:11.000Z</published>
    <updated>2023-09-23T13:15:41.582Z</updated>
    
    <content type="html"><![CDATA[<h1 id="以git-ftp为主的学习记录"><a href="#以git-ftp为主的学习记录" class="headerlink" title="以git-ftp为主的学习记录"></a>以git-ftp为主的学习记录</h1><blockquote><p>原本的目的是美化个人FTP主页（之前都是用FileZilla进行课程pdf文件等的传输，看到同学的个人主页后突然意识到也可以利用hexo完成相关功能，虽说没什么用，但也记录一下学习的过程。</p><p>……遇到了好多问题&gt; _ &lt;尚未完成</p><p>操作环境：win11 wsl2+Ubuntu 20.04 LTS,USTC ftp（默认首页为public_html下的index.html文件</p></blockquote><h2 id="git-ftp关联"><a href="#git-ftp关联" class="headerlink" title="git-ftp关联"></a>git-ftp关联</h2><p>优点：便于管理ftp</p><p>在github中创建名为<code>git-ftp</code>的repo后，使用<code>git clone</code>操作克隆到本地（或者可以在本地进行<code>git init</code>操作，创建.git文件，使用<code>git remote</code>操作与远程链接；</p><p>因为2021年8月13起github不允许在git操作时进行登录确认，因此要提前配置好：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git config --global user.name YOURNAMEgit config --global user.email YOUREMAIL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>要使用git-ftp的功能，需要先安装git-ftp：（确保git已经安装）<code>sudo apt-get install git-ftp</code></p><p>此外，要进行ftp的config操作：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git config git-ftp.url ftp-urlgit config git-ftp.user ftp-usergit config git-ftp.password pswd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>若想对以上内容进行查看，可以在本仓库<code>.git</code>目录进行查看和修改</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">[</span>core<span class="token punctuation">]</span>        repositoryformatversion = 0        filemode = true        bare = false        logallrefupdates = true<span class="token punctuation">[</span>git<span class="token punctuation">-</span>ftp<span class="token punctuation">]</span>        password = pswd        user = name        url = ftp<span class="token punctuation">-</span>url<span class="token punctuation">[</span>remote "origin"<span class="token punctuation">]</span>       <span class="token comment">#后序添加完可以查看url和fetch内容</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于git-ftp的相关操作，可以阅读 <a href="https://github.com/git-ftp/git-ftp/blob/master/man/git-ftp.1.md">官方文档</a> 。</p><p>之后可以对该目录进行初始化:<code>git ftp init</code>,或者对已存在的文件进行<code>git catchup</code>操作。</p><p>之后常用的操作就是<code>git ftp push</code>.顺便提一句，可能会遇到“Dirty repository :Having uncommited changes.Exiting…”的问题，就要先进行<code>git add .</code>,<code>git commit ..</code>,<code>git push</code>的操作。</p><p>此时仍无法进行<code>git ftp push</code>的操作，因为这一操作需要安装lftp：<code>sudo apt-get install lftp</code>,安装后即可使用。</p><h2 id="hexo搭建"><a href="#hexo搭建" class="headerlink" title="hexo搭建"></a>hexo搭建</h2><p>为了防止hexo操作将其他文件一并删除，此处可以新建一个文件夹存储hexo框架：<code>hexo init page</code>,打开目录底下的_config.yml进行修改，并且将deploy进行修改：(对生成的public_dir文件的位置大概也需要改)</p><p>PS:对于_config.yml的内容修改，可以不需要重新进行<code>hexo g</code></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span> <span class="token key atrule">type</span><span class="token punctuation">:</span> ftpsync <span class="token key atrule">host</span><span class="token punctuation">:</span> <span class="token comment"># ftp服务器地址</span> <span class="token key atrule">user</span><span class="token punctuation">:</span> <span class="token comment"># ftp用户名</span> <span class="token key atrule">pass</span><span class="token punctuation">:</span>  <span class="token comment"># 你的ftp用户密码</span> <span class="token key atrule">remote</span><span class="token punctuation">:</span>  <span class="token comment"># 你要上传到的地址，例如/wwwroot</span> <span class="token key atrule">port</span><span class="token punctuation">:</span>  <span class="token comment"># ftp端口，不同的ftp可能会不一样</span> <span class="token key atrule">delete</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment"># 上传本地文件是否删除ftp中的所有文件</span> <span class="token key atrule">verbose</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment"># 是否打印调试信息</span> <span class="token key atrule">ignore_errors</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 是否忽略错误</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大部分的操作为hexo的常规操作，但与利用域名搭建的hexo博客不同，这里需要安装插件：</p><p><code>npm install hexo-deployer-ftpsync –save</code></p><p>这里还有一个问题，<code>hexo d</code>后，我的原本存在public_html底下的文件被删除？</p><p>如果使用git clone安装了新主题，如此次安装了”Archer”主题，若hexo版本在4.0.0以上，需要将/themes/Archer目录下的_config.yml重命名为 _config.archer.yml，并移动到根目录，同时，因为使用的是<code>git clone</code>操作， 会将原repo的.git文件clone到本地，默认为与原repo关联，这个repo我们是没有权限进行修改的，相对于两个git项目进行了嵌套，外层无法update内部的repo，这时在根目录下进行<code>git add .</code>或者<code>git add all</code>操作均是无法将Archer文件的内容进行push的，也就无法进行<code>git ftp push</code>操作，解决方法就是利用<code>git remote remove</code>操作取消内部的git关联。 </p><h2 id="遇到的琐事"><a href="#遇到的琐事" class="headerlink" title="遇到的琐事"></a>遇到的琐事</h2><p>使用hexo操作时 ，发生对于Yaml的报错提示，从StackOverflow得知需要更新npm版本，遂进行更新，使用<code>npm install -g npm</code>时，又发生报错，大致意思为可以检测到新版本但是当前的node.js不兼容新版本，无法完成更新，而且此项更新未完成时，可能会对于npm安装其他的插件有影响。</p><p>google了半天，终于搞清楚了：</p><p>我在一开始安装npm时未安装nvm，二者的关系是：npm时node.js的包管理工具，nvm是node.js的版本管理工具，二者均是node.js应用程序开发的工具，因此要更新Node.js到最近版本，需要先安装nvm，<code>$ wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | sh</code>,其中sh可以替换成shell的具体名称，如我的就是zsh，默认为bash，安装完之后可以在~/.nvm看到该文件夹，不知道为什么，我的执行上述操作后无反应，重新启动了wsl才正常进行，完成后，在对应的配置文件( ~ /.bashrc或者~/.zshrc)中添加：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">export NVM_DIR="$([ -z "${XDG_CONFIG_HOME-}" ] &amp;&amp; printf %s "${HOME}/.nvm" || printf %s "${XDG_CONFIG_HOME}/nvm")"[ -s "$NVM_DIR/nvm.sh" ] &amp;&amp; \. "$NVM_DIR/nvm.sh" # This loads nvm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>完成后保存退出，<code>source ~/.zshrc</code>，即可使用nvm命令</p><p><code>nvm install</code>可以指定安装Node.js 的版本 ，可以选比较近的稳定版本17.0.0，安装完后<code>nvm ls</code>查看已安装版本：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">❯ nvm ls-&gt;      v17.0.0         systemdefault -&gt; v17.0.0iojs -&gt; N/A (default)unstable -&gt; N/A (default)node -&gt; stable (-&gt; v17.0.0) (default)stable -&gt; 17.0 (-&gt; v17.0.0) (default)lts/* -&gt; lts/gallium (-&gt; N/A)lts/argon -&gt; v4.9.1 (-&gt; N/A)lts/boron -&gt; v6.17.1 (-&gt; N/A)lts/carbon -&gt; v8.17.0 (-&gt; N/A)lts/dubnium -&gt; v10.24.1 (-&gt; N/A)lts/erbium -&gt; v12.22.10 (-&gt; N/A)lts/fermium -&gt; v14.19.0 (-&gt; N/A)lts/gallium -&gt; v16.14.0 (-&gt; N/A)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后就可以对npm进行更新了。<code>npm -v</code>可以查看现有的版本，问题解决了</p><p>这里还有一个问题，就是nvm安装的版本居然也不是全局版本，在另外一个目录下进行<code>npm -v</code>或者<code>node -v</code>竟然也是原版本…</p><p>emmmm 后面暴躁到不想记录了呜呜呜 </p><h2 id="利用CSS对界面优化"><a href="#利用CSS对界面优化" class="headerlink" title="利用CSS对界面优化"></a>利用CSS对界面优化</h2><p>2022.3.1update:learn how CSS works</p><p>CSS相关资源：</p><p><a href="https://chokcoco.github.io/CSS-Inspiration/#/">https://chokcoco.github.io/CSS-Inspiration/#/</a></p><p><a href="https://cssreference.io/">https://cssreference.io/</a></p><p>这个网站整合了很多CSS工具：</p><p><a href="https://juejin.cn/post/6982363593241002014">https://juejin.cn/post/6982363593241002014</a></p><p>HTML CSS工具网站,可以copy已有模板（nice！）和实时观察到html,CSS,JS的呈现结果  <a href="https://codepen.io">https://codepen.io</a> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;以git-ftp为主的学习记录&quot;&gt;&lt;a href=&quot;#以git-ftp为主的学习记录&quot; class=&quot;headerlink&quot; title=&quot;以git-ftp为主的学习记录&quot;&gt;&lt;/a&gt;以git-ftp为主的学习记录&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;原本的目的</summary>
      
    
    
    
    <category term="git" scheme="http://sn1987a-1.github.io/categories/git/"/>
    
    
    <category term="WSL2" scheme="http://sn1987a-1.github.io/tags/WSL2/"/>
    
  </entry>
  
  <entry>
    <title>WSL2美化</title>
    <link href="http://sn1987a-1.github.io/posts/15684.html"/>
    <id>http://sn1987a-1.github.io/posts/15684.html</id>
    <published>2022-01-21T14:12:20.000Z</published>
    <updated>2023-09-23T13:15:07.152Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><h1 id="WSL2美化"><a href="#WSL2美化" class="headerlink" title="WSL2美化"></a>WSL2美化</h1><p>本文简要记录基于Windows11对WSL的终端进行美化的主要步骤。</p><p>环境：Ubuntu 20.04，Windows Terminal(WT)</p><p>主要工具和插件：zsh，oh my zsh, povwerlevel10k(powerlevel9k也可以),autozsh-autosuggestions , zsh-syntax-highlig</p><p>下图是我的美化结果。</p><p><img src="https://user-images.githubusercontent.com/74918703/152648068-cc3de98c-40c3-401e-983b-a32860435f16.png" alt="image-20220122222259548"></p><h2 id="对Windows-terminal的外观进行美化"><a href="#对Windows-terminal的外观进行美化" class="headerlink" title="对Windows terminal的外观进行美化"></a>对Windows terminal的外观进行美化</h2><p>在微软应用商店搜索Windows terminal即可下载最新版本，如果不想用Windows Terminal，也可以下载另外一个跨平台终端——Tabby Terminal，<a href="[Tabby - a terminal for a more modern age](https://tabby.sh/">点击下载</a>)，配置方案也类似，但亲测效果不如WT。</p><h3 id="修改默认配置"><a href="#修改默认配置" class="headerlink" title="修改默认配置"></a>修改默认配置</h3><p>打开Windows Terminal，点击上方栏中“v”按钮，选择侧边栏中的“setting.json”文件并打开，后文中对WT的配置均对该文件进行修改（可以用VScode打开）。</p><p>例如，若要规定默认打开的界面是WSL2/WSL的界面，即可在actions一栏进行修改：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token string">"defaultProfile"</span><span class="token operator">:</span> <span class="token string">"{07b52e3e-de2c-5db4-bd2d-ba144ed6c273}"</span><span class="token punctuation">,</span><span class="token comment">//括号内对应的序列可在setting.json文件里查找到Ubuntu对应的GUID</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="修改配色方案"><a href="#修改配色方案" class="headerlink" title="修改配色方案"></a>修改配色方案</h3><p>在setting.json最后部分有schemes一栏，代表WT的配色方案，每个配色方案的name项即为名称，系统默认提供了一部分配色方案以及名称，但都不是很好看，将自定义配色添加到schemes底下即可新增配色方案，<a href="[Windows Terminal Themes](https://windowsterminalthemes.dev/">自定义配色网站</a>)提供了较多推荐的配色，可以直接复制。</p><p>以下为我选择的配色：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">{</span>      <span class="token string">"name"</span><span class="token operator">:</span> <span class="token string">"ChallengerDeep"</span><span class="token punctuation">,</span>      <span class="token string">"black"</span><span class="token operator">:</span> <span class="token string">"#141228"</span><span class="token punctuation">,</span>      <span class="token string">"red"</span><span class="token operator">:</span> <span class="token string">"#ff5458"</span><span class="token punctuation">,</span>      <span class="token string">"green"</span><span class="token operator">:</span> <span class="token string">"#62d196"</span><span class="token punctuation">,</span>      <span class="token string">"yellow"</span><span class="token operator">:</span> <span class="token string">"#ffb378"</span><span class="token punctuation">,</span>      <span class="token string">"blue"</span><span class="token operator">:</span> <span class="token string">"#65b2ff"</span><span class="token punctuation">,</span>      <span class="token string">"purple"</span><span class="token operator">:</span> <span class="token string">"#906cff"</span><span class="token punctuation">,</span>      <span class="token string">"cyan"</span><span class="token operator">:</span> <span class="token string">"#63f2f1"</span><span class="token punctuation">,</span>      <span class="token string">"white"</span><span class="token operator">:</span> <span class="token string">"#a6b3cc"</span><span class="token punctuation">,</span>      <span class="token string">"brightBlack"</span><span class="token operator">:</span> <span class="token string">"#565575"</span><span class="token punctuation">,</span>      <span class="token string">"brightRed"</span><span class="token operator">:</span> <span class="token string">"#ff8080"</span><span class="token punctuation">,</span>      <span class="token string">"brightGreen"</span><span class="token operator">:</span> <span class="token string">"#95ffa4"</span><span class="token punctuation">,</span>      <span class="token string">"brightYellow"</span><span class="token operator">:</span> <span class="token string">"#ffe9aa"</span><span class="token punctuation">,</span>      <span class="token string">"brightBlue"</span><span class="token operator">:</span> <span class="token string">"#91ddff"</span><span class="token punctuation">,</span>      <span class="token string">"brightPurple"</span><span class="token operator">:</span> <span class="token string">"#c991e1"</span><span class="token punctuation">,</span>      <span class="token string">"brightCyan"</span><span class="token operator">:</span> <span class="token string">"#aaffe4"</span><span class="token punctuation">,</span>      <span class="token string">"brightWhite"</span><span class="token operator">:</span> <span class="token string">"#cbe3e7"</span><span class="token punctuation">,</span>      <span class="token string">"background"</span><span class="token operator">:</span> <span class="token string">"#1e1c31"</span><span class="token punctuation">,</span>      <span class="token string">"foreground"</span><span class="token operator">:</span> <span class="token string">"#cbe1e7"</span><span class="token punctuation">,</span>      <span class="token string">"selectionBackground"</span><span class="token operator">:</span> <span class="token string">"#cbe1e7"</span><span class="token punctuation">,</span>      <span class="token string">"cursorColor"</span><span class="token operator">:</span> <span class="token string">"#fbfcfc"</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加完配色方案后，还应该对profiles部分进行修改，以便于使用最新配色方案。如果只需要对虚拟机部分添加如下文本，可以只修改name为“Ubuntu-xx.xx”的部分（当然其他部分也只是复制粘贴）。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token string">"colorScheme"</span><span class="token operator">:</span> <span class="token string">"ChallengerDeep"</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="修改字体"><a href="#修改字体" class="headerlink" title="修改字体"></a>修改字体</h3><p>Windows原装字体不支持很多符号的显示，这里推荐修改默认字体</p><p>比较简单的，可以在微软官方<a href="[Windows ターミナル Cascadia Code | Microsoft Docs](https://docs.microsoft.com/ja-jp/windows/terminal/cascadia-code">下载</a>)Cascadia Code PL字体，或者是下载文件后右键单击该字体对应的.otf/.ttf文件并选择安装。</p><p>当然有功能更加强大，应用更加广泛的字体Nerd Fond(Hack Nerd Fond)，包含了更多字符库，<a href="[ryanoasis/nerd-fonts: Iconic font aggregator, collection, &amp; patcher. 3,600+ icons, 50+ patched fonts: Hack, Source Code Pro, more. Glyph collections: Font Awesome, Material Design Icons, Octicons, &amp; more (github.com">点击下载</a>]( <a href="https://github.com/ryanoasis/nerd-fonts">https://github.com/ryanoasis/nerd-fonts</a> ))。</p><p>安装完成后，同样在profiles目录的Ubuntu-xx.xx里修改：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token string">"fontFace"</span><span class="token operator">:</span> <span class="token string">"Hack Nerd Fond"</span><span class="token string">"fontSize"</span><span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="设置背景和透明效果"><a href="#设置背景和透明效果" class="headerlink" title="设置背景和透明效果"></a>设置背景和透明效果</h3><p>均是在perfiles目录内</p><p>添加背景图：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token string">"backgroundImage"</span><span class="token operator">:</span> <span class="token string">"E:\\wallpaper\\wp3.jpg"</span><span class="token punctuation">,</span><span class="token comment">//背景的地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加透明效果（0~1，越小表示越透明）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token string">"acrylicOpacity"</span><span class="token operator">:</span> <span class="token number">0.8</span><span class="token punctuation">,</span><span class="token string">"useAcrylic"</span><span class="token operator">:</span> true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>指定启动时的默认路径：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token string">"startingDirectory"</span><span class="token operator">:</span> <span class="token string">"./"</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样Windows Terminal基本就配置好了。</p><h2 id="美化WSL2"><a href="#美化WSL2" class="headerlink" title="美化WSL2"></a>美化WSL2</h2><p>步骤：</p><ul><li>将原有的shell替换为zsh</li><li>安装oh my zsh</li><li>关键字高亮以及自动填充插件</li><li>安装powerlevel10k</li></ul><p>安装完自动填充以及高亮插件后对文件zshrc进行的主要添加为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">source <span class="token operator">/</span>usr<span class="token operator">/</span>share<span class="token operator">/</span>zsh<span class="token operator">-</span>autosuggestions<span class="token operator">/</span>zsh<span class="token operator">-</span>autosuggestions<span class="token punctuation">.</span>zshsource <span class="token operator">/</span>usr<span class="token operator">/</span>share<span class="token operator">/</span>zsh<span class="token operator">-</span>syntax<span class="token operator">-</span>highlighting<span class="token operator">/</span>zsh<span class="token operator">-</span>syntax<span class="token operator">-</span>highlighting<span class="token punctuation">.</span>zsh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里主要从安装powerlevel10k开始记录。</p><p>在命令行输入：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">sudo vim <span class="token operator">~</span><span class="token operator">/</span><span class="token punctuation">.</span>zshrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打开配置文件后，找到THEME一行，修改为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">ZSH_THEME<span class="token operator">=</span><span class="token string">"powerlevel10k/powerlevel10k"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后重启或输入命令</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">p10k configure<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后填写弹出的问卷即可自定义并保存当前配置文件。如果需要使用其他路径的文件，可以使用source命令进行导入。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot; &quot;&gt;&lt;/a&gt; &lt;/h1&gt;&lt;h1 id=&quot;WSL2美化&quot;&gt;&lt;a href=&quot;#WSL2美化&quot; class=&quot;headerlink&quot; title=&quot;WSL2美化&quot;&gt;&lt;/a&gt;WSL2美化&lt;</summary>
      
    
    
    
    <category term="WSL2" scheme="http://sn1987a-1.github.io/categories/WSL2/"/>
    
    
    <category term="WSL2" scheme="http://sn1987a-1.github.io/tags/WSL2/"/>
    
  </entry>
  
  <entry>
    <title>DataStruct基础知识</title>
    <link href="http://sn1987a-1.github.io/posts/131000.html"/>
    <id>http://sn1987a-1.github.io/posts/131000.html</id>
    <published>2022-01-11T12:12:20.000Z</published>
    <updated>2023-09-23T13:16:04.642Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2021数据结构复习"><a href="#2021数据结构复习" class="headerlink" title="2021数据结构复习"></a>2021数据结构复习</h1><hr><h2 id="考试范围"><a href="#考试范围" class="headerlink" title="考试范围"></a>考试范围</h2><p>数据结构 算法时间复杂度空间复杂度分析</p><ol><li>线性表<ol><li>顺序表示</li><li>链式表示<ol><li>线性链表</li><li>循环链表</li><li>双向链表</li></ol></li><li>一元多项式（实验内容）</li></ol></li><li>栈<ol><li>数值转换，括号匹配，行编辑程序，迷宫求解，表达式求值</li></ol></li><li>队列<ol><li>定义</li><li>链队列</li><li>循环队列</li></ol></li><li>串<ol><li>定长顺序存储</li><li>堆分配存储</li><li>串的块链存储</li></ol></li><li>数组<ol><li>顺序表示</li><li>特殊存储：特殊矩阵，稀疏矩阵</li></ol></li><li>广义表<ol><li>定义和存储结构</li><li>*广义表的递归算法<ol><li>求广义表深度</li><li>复制广义表</li><li>建立广义表的存储结构</li></ol></li></ol></li><li><strong>树和二叉树</strong><ol><li>二叉树<ol><li>定义，性质，存储结构</li><li>遍历二叉树</li><li>线索二叉树</li></ol></li><li>树和森林<ol><li>树的存储结构</li><li>树和二叉树之间的转换</li><li>树和森林的遍历</li></ol></li><li>Huffman树相关问题</li></ol></li><li><strong>图</strong><ol><li>定义和术语</li><li>存储结构<ol><li>数组表示法</li><li>邻接表</li><li>十字链表</li><li>邻接多重表</li></ol></li><li>图的遍历<ol><li>DFS</li><li>BFS</li></ol></li><li>图的连通性问题<ol><li>无向图连通分量和生成树</li><li>最小生成树</li></ol></li><li>最短路径问题<ol><li>从某一点到其他各个顶点的最短距离</li><li>每一对顶点之间的最短路径</li></ol></li></ol></li><li><p>查找</p><ol><li>静态查找表<ol><li>顺序表查找</li><li>有序表查找</li><li>索引顺序表查找</li></ol></li><li><strong>动态查找</strong><ol><li>二叉排序树和 *平衡二叉树</li><li>B-树和B+树</li></ol></li><li>哈希表<ol><li>构造方法</li><li>处理冲突</li><li>查找</li></ol></li></ol><p>`#define INFEASIBLE -1</p><p>`#define OVERFLOW -2</p></li></ol><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>逻辑上相邻，物理上相邻，随机存取</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define LIST_SIZE 100#define LISTINCREMENT 10typedef struct {   ElemType *elem;   int length;   int listsize;}SqList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>动态分配：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void *malloc();free(void *p);void *realloc(void *p,unsigned int size);//可变大/变小<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>基本操作略</p><h3 id="链表表示"><a href="#链表表示" class="headerlink" title="链表表示"></a>链表表示</h3><p>逻辑上相邻不代表物理上相邻，非随机存取</p><p>（区别不同逻辑结构的插入删除操作）</p><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct LNode {elemtype data;   struct LNode *next;}Lnode ,*LinkList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>基本操作：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Status GetElem_L(LinkList L,int i,ElemType &amp;e);Status ListInsert_L(LinkList &amp;L,int i，ElemType e);//获取结点的前驱耗时间，T(N)=O(N)Status ListDelete_L(LinkList &amp;L,int i，ElemType &amp;e);Status CreateList_L(LinkList &amp;L);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建：头插法（$T(N)=O(N)$），尾插法($T(N)=O(N^2)$)(头插法创建较好)</p><p>作业习题：<strong>就地逆置</strong>单链表</p><p>有头结点：L指向头结点，除头结点各点均有前驱；</p><p>无头结点：空表时L为NULL；</p><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><ol><li>便于从一个结点出发，访问全部的结点</li><li>在O(1)的时间内找到链表的第一个结点和最后一个结点（头指针==尾指针）</li></ol><h4 id="静态链表和动态链表"><a href="#静态链表和动态链表" class="headerlink" title="静态链表和动态链表"></a>静态链表和动态链表</h4><p>静态链表(若语言不支持指针类型的存储的情况)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define MAXSIZE 1000typedef struct{   ElemType data;   int cur;//代替指针域}component,SLinkList[MAXSIZE];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数组的第0个分量可以视为（备用链的）头结点；</p><p>静态链表的模拟动态分配与释放（未利用的点i[cur]=0;)</p><p>动态链表与静态链表的运用：例：求差集</p><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct DuLNode{   ElemType data;   struct DuLNode *prior;   struct DuLNode *next;}DuLNode ,*DuLinkList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可带头结点，可不带（多半是带的）。</p><h4 id="其他表示"><a href="#其他表示" class="headerlink" title="其他表示"></a>其他表示</h4><p>根据题目要求规定进行设计，如同时存储单链表的头和尾，特殊线性表——有序表。</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>1.双向循环链表的自身变换，如将$L=\{a_1,a_2,…..a_n\}$变换为$L’=\{a_1,a_3,….a_n,…a_4,a_2\}$</p><p>​    (顺着后向链，前向链进行插入)</p><h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><p>难点：<strong>递归与非递归实现</strong>，循环队列</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>LIFO 只能在Top端进行插入删除操作</p><p><em>Traverse操作是从栈底到栈顶进行访问</em></p><p>多为顺序栈：约定：S.top指向<strong>栈顶元素的下一个位置</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define STACK_INT_SIZE 100#define STACKINCREMENT 10typedef struct {   ElemType *base;   ElemType *top;   int stacksize;//当前分配容量}SqStack；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>栈空：S.base==S.top</p><p>栈满：S.top-S.base&gt;=S.stacksize</p><p>入栈：S.top++;    出栈: S.top - - ；</p><p>链栈：无栈满问题，可以不必引入头结点（在第一个结点处进行插入删除操作）。</p><h3 id="栈的基本应用"><a href="#栈的基本应用" class="headerlink" title="栈的基本应用"></a>栈的基本应用</h3><p>1.数制转换</p><p>2.行编辑程序（已不常用）</p><p>​            用栈保存终端输入的一行字符进行逐行处理；遇到‘#’退一格（出栈），遇到‘@’退一行（清空栈ClearStack），其他字符入栈，最后遍历，清空栈。</p><p>3.<strong>表达式求值</strong></p><p>表达式表示方法：</p><ul><li>中缀表达式，记得加括号</li><li>前缀表达式（波兰式）-<em>+abc </em>d-ea</li><li>后缀表达式（逆波兰式）ab+c<em>dea- </em> -</li></ul><p>表达式求值也可以用二叉树表示：分支保存运算符，叶子结点保存操作数，中序访问：中缀表达式；先序访问：前缀表达式；后序访问：后缀表达式</p><p><strong>要先确保中缀表达式合法：括号匹配</strong>     默认运算式结尾为’#’</p><p>可以进行的操作：中缀表达式转化为先/后缀表达式，先/后缀表达式求值，中缀表达式直接求值。注意：不涉及中缀表达式的运算不需考虑优先级。</p><p><code>[1]中缀表达式转后缀表达式：运算符入栈</code></p><p><code>[2]中缀表达式求值：运算符（包括左括号）和运算数两个栈，按照操作符优先级进行运算，'#'优先级最低。</code></p><p><code>[3]前缀表达式串求值：运算符和运算数入同一个栈，如果有两个运算数则进行运算</code></p><p><code>[4]前缀表达式与后缀表达式相互转化：思路相反，同样用栈，类似波兰式/逆波兰式求值，将字符串视作运算数。</code></p><p><code>[5]后缀表达式求值：运算数入栈</code></p><p>4.<strong>栈与递归的实现</strong></p><p>应用：构建其他数据结构：表，图，树和二叉树</p><p>​            问题求解：Hanoi塔问题，迷宫问题/N皇后问题（回溯）</p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>FIFO，允许在队尾rear插入，队头head删除（获取队头元素GetHead(L,&amp;e),遍历操作Traverse(L，visit())从head到rear）.</p><h4 id="链队列（通常）"><a href="#链队列（通常）" class="headerlink" title="链队列（通常）"></a>链队列（通常）</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct QNode{   ElemType data;   struct QNode *next;}QNode,*QueuePtr;typedef struct {   QueuePtr front;   QueuePtr rear;}LinkQueue;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（最好是引入头结点——队空：L.front ==L.rear）</p><h4 id="循环队列-处理假溢出"><a href="#循环队列-处理假溢出" class="headerlink" title="循环队列(处理假溢出)"></a>循环队列(处理假溢出)</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define MAXSIZE 100typedef struct{   ElemType *base;   int front;   int rear;//指向队尾元素的下一个位置}SqQueue；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>队空标志：Q.front==Q.rear</p><p>多申请一个空间，队满标志：Q.front==(Q.rear+1)%MAXSIZE</p><p>INCREMENT：重新分配空间，并遍历原队列进行复制</p><p>应用：离散事件模拟</p><h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><p>概念：串的长度，空串，子串，主串，子串/字符在串中的位置</p><p>是特殊的线性表：处理对象为个体（字符）或整体（子串）</p><p>操作：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">StrAssign(S,"...");//赋值StrCpoy(T,S);//复制串StrCompare(S,T);//比较ConCat(T,"...");//拼接SubString(Sub,S,i,j);//取子串Sub为Si,...SjIndex(s,"a",i);//返回S中i后第一层出现子串的首个字母的位置Replace(S,"..","..");//将子串全部替换为目标子串StrInsert(S,i,"...");//在i处插入子串StrDelete(S,i,j);//删除Si到Sj的子串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="具体存储结构"><a href="#具体存储结构" class="headerlink" title="具体存储结构"></a>具体存储结构</h3><p>顺序映像存储密度低</p><ul><li><p>定长顺序存储，下表为0的位置存储串的长度（basic)或串值最后加入无关字符，如’\0’ (C)。</p></li><li><p>堆分配存储——顺序映像</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct{   char *ch;//malloc() 动态分配   int length;}HString;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>​    <strong>块链存储——链式映像</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct Chunk{   char ch[CHUNKSIZE];   struct Chunk *next;}Chunk;typedef struct{   Chunk *head,*tail;   int curlen}LString;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>块链存储中的插入，删除，寻找子串，定位，拼接算法复杂化处理（作业题目）</p></li></ul><h3 id="串的模式匹配算法"><a href="#串的模式匹配算法" class="headerlink" title="串的模式匹配算法"></a>串的模式匹配算法</h3><p>好像不考。</p><h3 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h3><p>应用于文本编辑，页插入/删除，行插入/删除，页表，行表，起始地址，长度…</p><p>建立关键词词索引表</p><h2 id="数组和广义表"><a href="#数组和广义表" class="headerlink" title="数组和广义表"></a>数组和广义表</h2><p>数组的操作貌似也不考，补充三元表，特殊数组在后续算法课中。</p><h3 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h3><p>广义表是线性表的推广，元素类型可以是原子或子表，习惯上用大写字母表示子表，小写字母表示原子。（也可以看作特殊定义的图）</p><p>表处理语言LISP中，将广义表视作基本的数据结构。</p><p>表头：表中的第一个元素 GetHead(L)</p><p>表尾：除去第一个元素外的其余元素组成的表 GetTail(L)</p><p>基本定义</p><ul><li>空表 A=( )</li><li>长度：元素个数，如B=(a,(b,c,d))长度为2，第二个元素为表</li><li>A=(a,A) 可以递归定义的表</li><li>GetHead(((())))=(()); GetTail((()))=()</li><li>深度：括号的重数的最大值</li></ul><h3 id="广义表的存储结构"><a href="#广义表的存储结构" class="headerlink" title="广义表的存储结构"></a>广义表的存储结构</h3><p>数据元素不同，难以用顺序表存储。</p><h4 id="头尾链表存储"><a href="#头尾链表存储" class="headerlink" title="头尾链表存储"></a>头尾链表存储</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef enum{ATOM,LIST}ElemTag;typedef struct GLNode{   ElemTag tag;   union{      AtomType atom;      struct {GLNode *hp,*tp;}ptr;   };}*GList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="C:\Users\李\AppData\Roaming\Typora\typora-user-images\image-20211229111630880.png" alt="image-20211229111630880" style="zoom:20%;"></p><h4 id="拓展线性链表存储"><a href="#拓展线性链表存储" class="headerlink" title="拓展线性链表存储"></a>拓展线性链表存储</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef enum{ATOM,LIST}ElemTag;typedef struct GNode{   ElemTag tag;   union{      AtomType atom;      struct GLNode *hp;   };   struct GLNode *tp;}*GLIst;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="C:\Users\李\AppData\Roaming\Typora\typora-user-images\image-20211229111642454.png" alt="image-20211229111642454" style="zoom:25%;"></p><h3 id="广义表的相关操作"><a href="#广义表的相关操作" class="headerlink" title="广义表的相关操作"></a>广义表的相关操作</h3><p><em>此部分不考代码设计，可能有读代码分析的题目</em></p><p><strong>递归算法</strong>，归纳思维</p><h4 id="广义表的深度"><a href="#广义表的深度" class="headerlink" title="广义表的深度"></a>广义表的深度</h4><p>规定：LS为原子：DEPTH=0；</p><p>​            LS为空表：DEPTH=1；</p><p>​            归纳项：$DEPTH(LS)=1+Max\{DEPTH(a_i)\},\ n&gt;=1$</p><p>假设采用头尾链表存储：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int GListDepth(GLIst L)//递归{   if(!L)      return 1;   if(L-&gt;tag==ATOM)      return 0;   for(max=0,pp=L;pp;pp=pp-&gt;ptr.tp)   {      dep=GListDepth(pp-&gt;ptr.hp);      if(dep&gt;max) max=dep;   }   return max+1;}//可以用队列实现非递归算法，在每层开始处设置标志<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="复制广义表"><a href="#复制广义表" class="headerlink" title="复制广义表"></a>复制广义表</h4><p>归纳：复制LS—&gt;复制表头+复制表尾</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Status CpoyList(GList &amp;T,GList L){//假定头尾链表存储   if(!L)   {   T=NULL;      return OK;}   T=(GList)malloc(sizeof(GLNode));   T-&gt;tag=L-&gt;tag;   if(T-&gt;tag==ATOM)   {T-&gt;atom=L-&gt;atom;return OK:}   CopyList(T-&gt;ptr.hp,L-&gt;ptr.hp);   CopyList(Y-&gt;ptr.tp,L-&gt;ptr.tp);   return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以用栈实现非递归算法。</p><h4 id="广义表结构的建立"><a href="#广义表结构的建立" class="headerlink" title="广义表结构的建立"></a>广义表结构的建立</h4><p>由字符串建立广义表</p><p>表头+表尾递归处理</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="其他应用"><a href="#其他应用" class="headerlink" title="其他应用"></a>其他应用</h3><p>作业题目：就地逆置广义表(逆转所有子表)递归处理</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">```注：广义表的存储格式一般可以自选常见思路：1.将广义表看作表头表尾两部分进行递归处理​2.将广义表看作n个并列子表组成的表## 树和二叉树**二叉树的遍历，二叉树和森林的相互转换等相关算法设计**### 定义空树n=0;表示方法：树形表示，嵌套表示，广义表表示，凹入表示术语：高度，层次（1，2，...，h），度，祖先，子孙，有序树，无序树，终端结点，非终端结点，内部结点...操作：```c++TreeDepth(T);Parent(T,cur_e);LeftChild(T,cur_e);RightSibling(T,cur_e);InsertChild(&amp;T,p,i,c);//插入子树DeleteChild(&amp;T,p,i);TraverseTree(T,visit());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>每个结点最多有两个子树，度数一定是2，分左右。</p><p>性质：</p><ul><li>第i层最多有$2^{n-1}$个结点</li><li>深度为h的二叉树最多$2^{h}-1$个结点（上述两条可以推广到n叉树的情况）</li><li>$n_0=n_2+1;\ \ \ n=n_0+n_1+n_2;\ \ \ n-1=n_1+n_2$</li><li>若包含n个结点的树只有叶子结点和度数为k的结点，则树中包含的叶子结点为：$n_0=n-(n-1)/k$</li><li>满二叉树：深度为h且含有$2^{h}-1$个结点的二叉树</li><li>完全二叉树：前k-1层为满二叉树，第k层结点全在靠左边</li><li>具有n个结点的完全二叉树的深度：$h=[log_2n]+1$</li><li>若对一有n个结点的完全二叉树按层序编号，则对任意结点有：<ul><li>若i=1，为根结点，无双亲；若i&gt;1，双亲结点为[i/2]</li><li>若2i&gt;n,则结点i无左孩子，否则左孩子为2i。</li><li>若2i+1&gt;n，则i无右孩子，否则右孩子是2i+1.</li><li>上述结论可以大致推广到k叉树                                                                                                                     </li></ul></li></ul><p>二叉树的存储结构：</p><p>顺序存储：空间开销大</p><p>链式存储：二叉链（保存双亲结点变成三叉链）</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct{   ElemType data;   struct BiTNode *lchild,*rchild;}BiTNode,*BiTree;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二叉树的相关算法"><a href="#二叉树的相关算法" class="headerlink" title="二叉树的相关算法"></a>二叉树的相关算法</h3><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p><strong>先/中/后序遍历</strong>：每个结点均被访问三次</p><p>递归/非递归（栈）算法实现。</p><p><strong>最好使用函数调用的结果而不是返回值：为实现函数出现异常时改变Status及时终止</strong></p><p>相关运用：</p><ul><li><p>创建二叉树：类比先序访问</p><p>清空释放二叉树，或以某个结点为祖先的子树：后序访问</p></li><li><p>先序/后序拓补序列可以唯一确定一个二叉树。</p></li><li><p>非递归后序遍历要注意：设置访问标志tag</p></li><li><p>求深度</p></li></ul><p><strong>层次遍历</strong>递归/非递归（队列）实现</p><p>​        ——先访问的结点，子结点也会优先访问</p><ul><li>对二叉树进行层次遍历可以<strong>判断该二叉树是否为完全二叉树</strong>。</li><li>找到距离x最近的叶子子孙及距离：从x开始进行层次遍历，找到第一个叶子结点即可（每层末尾加一个虚结点进行计算距离</li><li>输出距离x最近的所有叶子及其数目</li><li>输出x到最近叶子子孙结点的路径：修改原队列：不释放已经遍历的结点并记录每个结点的双亲信息</li></ul><h4 id="二叉树的创建"><a href="#二叉树的创建" class="headerlink" title="二叉树的创建"></a>二叉树的创建</h4><ul><li>完全二叉树的顺序映射</li><li>先序拓扑序列</li><li>先序+中序或后序+中序也可唯一确定的一棵二叉树—-线索化二叉树</li></ul><h4 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h4><p>利用叶子结点的未使用的指针域，加两个标记</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef enum{Link,Thread}PointerTag;typedef struct BiThrNode{   ElemType data;   struct BiThrNode *lchild,*rchild;   PointerTag ltag,rtag;}BiThrNode,*BiThrTree;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先序/中序/后序线索化二叉树：对应遍历顺序的相应前驱，后继，其算法可以类比相应的遍历算法。</p><p>中序线索化中规中矩，基本是中序遍历的拓展，左孩子为前驱，右孩子为后继；</p><p>先序/后序线索化二叉树 相互对称，难点：找前驱和后继</p><p>后序找到前驱的方法：</p><ul><li>若该结点无左孩子，前驱由lchild指向</li><li>若该结点有左右孩子，前驱为右孩子</li><li>若该结点只有左孩子，前驱为左孩子</li></ul><p>后序找到结点的后继</p><ul><li>若结点为根结点，后继为空</li><li>若结点为双亲的右孩子或没有右兄弟，后继为双亲</li><li>若为有右兄弟的左孩子，且右兄弟为叶子结点，后继为右兄弟</li><li><strong>若为有右兄弟的左孩子，且右兄弟不是叶子结点，则后继为右兄弟后序遍历的第一个结点</strong></li></ul><p>后序找到结点的后继</p><ul><li>若结点为根结点，前驱为空</li><li>若结点为双亲的左孩子或没有左兄弟，前驱为双亲</li><li>若为有左兄弟的右孩子，且左兄弟为叶子结点，前驱为左兄弟</li><li><strong>若为有左兄弟的右孩子，且左兄弟不是叶子结点，则前驱为左兄弟先序遍历的最后一个结点</strong></li></ul><p>先序找到后继的方法</p><ul><li>若该结点无右孩子，后继由右孩子指向</li><li>若该节有左右孩子，其后继为左孩子</li><li>若该结点有右孩子且无左孩子，其后继为右孩子</li></ul><p>涉及求结点的双亲的问题———三叉链表</p><h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><h4 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h4><p>可以用于顺序存储</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define MAX_TREE_SIZE 100typedef struct{   ElemType data;   int parent;}PTNode;typedef struct{   PTNode nodes[MAX_TREE_SIZE];   int n;//结点数}PTree;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define MAX_TREE_SIZE 100typedef struct{  int child;   struct CTNode *next;}*ChildPtr;typedef struct{   ElemType data;   ChildPtr firstchild;}CTBox;typedef struct {   CTBox nodes[MAX_TREE_SIZE];   int n,r;//结点数和根的位置}CTree;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct CSNode{   ElemType data;   struct CSNode *firstchild,*nextsibling;}CSNode,*CSTree;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><p>先根遍历&lt;—-&gt;二叉树的先序遍历</p><p>后根遍历&lt;—-&gt;二叉树的中序遍历</p><p>应用：通常以孩子-兄弟链表示</p><ul><li>统计树的高度</li><li>统计树中叶子结点的个数（叶子结点的标志：Firstchild为空）</li><li>求树的度</li></ul><p>树和森林与二叉树之间的转换…没讲，不知道考不考</p><h3 id="Huffman树"><a href="#Huffman树" class="headerlink" title="Huffman树"></a>Huffman树</h3><p>相关概念：最优树，路径长度（带权），结点带权路径长度，$WPL=\sum_{i=1}^nw_il_i$</p><p>Huffman编码（算法应该不考，考也无所谓）</p><h3 id="开拓问题求解相关思路"><a href="#开拓问题求解相关思路" class="headerlink" title="开拓问题求解相关思路"></a>开拓问题求解相关思路</h3><p>课本没讲？。？应该不考OvO</p><p>划分等价类，回溯法求解问题，树的计数/编号</p><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>相关概念：有向图，无向图，带权/无权图路径和连通性，连通和强连通，子图，生成树，顶点/弧（相关概念复习图论再写）</p><p>一般算法中不考虑带权图的权值为负数的情况</p><p>基本操作 PS:操作包含对点vex，对边arc的操作</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Status LocateVex(G,u);Status GetVex(G,v);Status FirstAdjVex(G,v);Status NextAdjVex(G,v,w);Status InsertVex(G,v);Status InsertArc(&amp;G,v,w);Status DeleteVex(&amp;G,v);Status DeleteArc(&amp;G,v,w);Status DFSTraverse(G,v,Visit());Status BFSTraverse(G,v,Visit());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><p>用顺序表存储顶点集，不是顺序映像</p><p>最常用的还是邻接表</p><p>用以下方法存储关系集合</p><h4 id="数组表示—邻接矩阵"><a href="#数组表示—邻接矩阵" class="headerlink" title="数组表示—邻接矩阵"></a>数组表示—邻接矩阵</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define INFINITY INT_MAXtypedef enum{DG,DN,AG,AN}GraphKind;//有向/无向，带权/无权typedef struct ArcCell{   //带权图：adj代表权值，INFINITY代表不相邻   //无权图0代表不相邻，1代表相邻   int adj;   InfoType *info;//指向相关信息的指针}ArcCell,AdjMatrix[MAX_VERTEX_NUM][MAX_VEXTEX_NUM];typedef struct {   VextexType vexs[MAX_VEXTEX_NUM];   AdjMatrix arcs;   int vexnum;   int arcnum;   GraphKind kind;}MGraph;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>无向图的邻接矩阵：对阵矩阵</p><h4 id="链表表示—邻接表-逆邻接表"><a href="#链表表示—邻接表-逆邻接表" class="headerlink" title="链表表示—邻接表/逆邻接表"></a>链表表示—邻接表/逆邻接表</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct ArcNode{   int adjvex;   struct ArcNode *nextarc;   InfoType *info;}ArcNode;typedef struct {   VexType data;   ArcNode *firstarc;}VNode,AdjList[MAX_VERTEX_NUM];typedef struct{   AdjList vertices;   int vexnum,arcnum;   GraphKind kind;}ALGraph;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于有向图，比较容易计算的是顶点的出度，而入度要对所有的边进行遍历才能求出（反之为逆邻接表）。</p><p>对于稀疏图（$v&gt;log_2a$），多采用邻接表，避免空间浪费，否则可以选用邻接矩阵。</p><h4 id="十字链表—有向图"><a href="#十字链表—有向图" class="headerlink" title="十字链表—有向图"></a>十字链表—有向图</h4><p>弧结点数=弧数</p><p>方便求出顶点的入度和 出度</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct ArcBox{   int tailvex,headvex;   struct ArcBox *hlink,*tlink;   InfoType *info;}ArcBox;typedef struct VexNode{   VextexType data;   ArcBox *firstin,*firstout;}VexNode;typedef struct{   VexNode xlist[MAX_VERTEX_NUM];   int vexnum,arcnum;}OLGraph;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="邻接多重表—无向图"><a href="#邻接多重表—无向图" class="headerlink" title="邻接多重表—无向图"></a>邻接多重表—无向图</h4><p>邻接表中：边结点数==2*边数</p><p>临界多重表：边结点数==边数</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef enum{unvisited ,visited}VisitIf;//边结点typedef struct EBox{   VisitIf mark;   int ivex,jvex;   struct Ebox *ilink,jlink;   InfoType *info;}EBox;//顶点结点typedef struct VexBox{   VexType data;   EBox *firstedge;}VexBox;//临界多重表typedef struct {   VexBox adjmulist[MAX_VEXTEX_NUM];   int vexnum,edgenum;}AMLGraph;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>对顶点的遍历——引入标记数组visitd[0,…n-1]，防止<strong>顶点</strong>被多次访问。</p><p>访问结束可以得到图的生成树（连通图可以从一个顶点完成全部的遍历，非连通图要在外部加循环确保所有顶点均被访问，有向图注意强连通），后续连通性模块将讨论。</p><p>可以基于图的多种存储结构进行相似的遍历，算法可以基于ADT Graph（调用ADT的函数，如FirstAdjVex，NextAdjVex等）或某种存储结构写。</p><h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><p>深度优先遍历——树的先序遍历</p><p>生成从起点v出发的深度优先生成树，v可能存在多个子树</p><p>非递归实现：利用栈及时进行现场保护和现场维护</p><h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><p>广度优先遍历——树的层次遍历</p><ul><li>判断两个顶点是否存在路径</li><li>得到某点到任意一个顶点之间的最短路径（无权）</li><li>求距离v的最短距离最长/最短的顶点</li><li>求距离v距离为k的所有顶点</li></ul><p><strong>遍历算法的应用</strong></p><ul><li><code>求一条包含图中所有顶点的简单路径</code><ul><li><code>不一定存在，基于DFS寻找，是否能找到与具体顶点的选择有关</code></li><li><code>对DFS的修改：要回溯，添加计数器记录当前路径的结点数n，查找失败时恢复原来的状态，n--</code></li><li><code>可以修改算法，选择输出一条路径或者全部路径（最好是一条？），统计最短路径的条数</code></li></ul></li><li>求距离v的最短距离最长的顶点和最长的路径值<ul><li>对BFS进行修改，在每层结尾入队一个特殊元素</li><li>最后一个出队列的一定是路径最长的顶点</li></ul></li></ul><h3 id="图的连通性问题"><a href="#图的连通性问题" class="headerlink" title="图的连通性问题"></a>图的连通性问题</h3><p>基本概念：连通分量的顶点集，生成树，DFS生成树，BFS生成树，生成森林</p><p>同样可以基于ADTGraph或具体的存储方式写出不同的算法</p><ul><li>BFS/DFS生成树/生成森林</li><li><code>有向图的强连通分量</code><ul><li><code>从某顶点出发，以该顶点为尾做DFS，按照其所有邻接点的搜索都完成的顺序（退出DFS的顺序）存储到数组</code></li><li><code>从存储到数组的顶点出发，沿着该顶点为头的弧进行逆向DFS，能访问到的顶点则在同一个强连通分量中</code></li><li><code>复杂度近似和DFS遍历的复杂度相同</code></li></ul></li><li><code>最小生成树MST——无向连通网的最小代价生成树</code><ul><li>“若（u，v)为具有最小权值的边，则必存在包含该边的最小生成树”</li><li><code>Prim算法——最小生成树不断壮大的过程</code><ul><li><code>适用于稠密图</code>$T(N,e)=O(N^2)$</li></ul></li><li><code>Kruskal算法——连通分量不断合并的过程</code><ul><li><code>适用于稀疏图</code>$T(N,e)=O(N*log (e))$</li></ul></li></ul></li><li>关节点和重连通分量<ul><li>关节点：删除v后一个连通分量变为两个/两个以上<ul><li>若生成树的根至少有两棵或两棵以上的子树，则该结点必是关节点</li><li>若生成树的某非叶子结点v的某棵子树的结点均没有指向v的祖先的边，则v为关节点</li><li>叶子结点一定不是关节点</li></ul></li><li>重连通图：不含关节点的图，保证了任意两个顶点至少存在两条路径</li><li>连通度：若连通图G至少删去K个顶点才能变成不连通，则该图的连通度为k</li><li>改造DFS可以得到图的关节点，判断是否为重连通图<ul><li>引入数组low[v]:生成树中以v为根的子树中结点到v的祖先的边所关联的祖先的最小次序号</li><li>若对于v，v的孩子结点w有low[w]&gt;=visited[v]，则说明v为关节点</li></ul></li></ul></li></ul><h3 id="有向无环图（-DAG）的应用"><a href="#有向无环图（-DAG）的应用" class="headerlink" title="有向无环图（ DAG）的应用"></a>有向无环图（ DAG）的应用</h3><ul><li>检测有向图中是否有环：<ul><li>从顶点v出发，若DFS结束前发现出现u到v的回边，则有环</li></ul></li></ul><p>DAG是描述一项活动或系统的进行过程的工具：</p><p>​    顶点—子工程，边—子工程之间的约束</p><p>应用：</p><h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><p>问题描述：偏序-&gt;全序</p><p>偏序：集合X上的元素是自反的，反对称的，传递的</p><p>一、AOV网：Activity on vextex network</p><p>进行拓扑排序的方法：</p><ol><li>在有向图中选取一个没有前驱的顶点并输出</li><li>在图中删除该顶点和以该顶点为尾的弧</li><li>转1，除非已经输出全部顶点或不存在无前驱的顶点</li></ol><p>有向无环图保证了该图存在拓扑排序，存在拓扑排序保证了有向图中没有环</p><p><code>对于一个有向无环图，进行DFS遍历，第一个退出循环的顶点即为出度为0的顶点，（可以）是拓扑排序的最后一个顶点</code></p><p><code>若有向图的邻接矩阵为三角矩阵，则该途中存在拓扑有序序列</code></p><p>二、AOE网：Activity on edge network</p><p>问题：完成整项工程的最短时间/关键路径/事件的最早发生时间</p><p>关键活动：最早发生时间（e(i)）==最晚发生时间（l(i)）</p><p>最早发生时间：拓扑有序</p><p>最晚发生时间：逆拓扑有序</p><p><code>关键路径</code>：输出关键活动（可能不止一条）</p><h4 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h4><p>无权图的最短路径：广度优先搜索</p><p>带权有向图的最短路径——<code>dijkstra算法</code></p><p>按路径长度递增的顺序产生最短路径</p><p>求任意两个顶点的最短路径</p><p>对Dijkstra算法进行循环：$O(T,e)=O(n^3)$</p><p>具体实现应该不会考，会考画图？</p><p><code>Floyd</code>（Wallshall算法）：求vi，vj之间的最短路径，依次使得中间路径序号不大于k的最短路径，k依次递增。</p><h2 id="查找Search-Table"><a href="#查找Search-Table" class="headerlink" title="查找Search Table"></a>查找Search Table</h2><p>操作：检索/查找（静态），插入/删除（动态）</p><p>关键字：主关键字唯一，次关键字不唯一</p><h3 id="静态查找"><a href="#静态查找" class="headerlink" title="静态查找"></a>静态查找</h3><h4 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h4><p>通过顺序表/线性链表进行查找</p><p>0的位置设置“哨兵”：避免每一次查找都要判断是否查找完毕，减少比较次数</p><p>查找成功：ASL=$(n+1)/2$</p><p>查找不成功：ASL=n+1</p><h4 id="有序表的查找"><a href="#有序表的查找" class="headerlink" title="有序表的查找"></a>有序表的查找</h4><ol><li>折半查找<ol><li>基本思想：用low/high做标记，查找区间折半缩小</li><li>性能分析：查找过程可以用二叉树判定树表示，判定树的形态与n直接相关（不是完全二叉树但胜似完全二叉树），查找层次即为二叉树的层次，也代表ASL</li><li>查找成功或不成功：$ASL&lt;=[log_2n]+ 1$</li><li>n&gt;=50时，可近似得到结果：$ASL_{bs}\approx log_2(n+1)-1$</li></ol></li><li>斐波那契查找<ol><li>根据斐波那契的特征对标进行分割:开始表中的记录个数比斐波那契数小1，则将定值与F(n-1)进行比较，类似折半查找</li><li>特点：分割时只需进性加减运算</li><li>平均性能比折半查找好，但最坏的情况比折半查找糟糕</li></ol></li><li>插值查找<ol><li>$i=\frac{key-ST.elem[l].key}{ST.elem[h].key-ST.elem[l].key}(h-l+1)$</li><li>只适用于关键字均匀分布的情况，这种情况下平均性能优于折半查找</li></ol></li><li>静态树表查找<ol><li>根据各个记录的查找概率求ASL</li><li>PH值：判定树内带权路径长度$PH=\sum_{i=1}^nw_ih_i$,其中$w_i=c*p_i$为权，$h_i$为层次</li><li>PH值最小：静态最优查找树——构造需要的时间开销过高</li><li>构造较好的次优查找树</li><li>…写到这里发现查找树表不考，再见</li></ol></li><li>索引顺序表<ol><li>起因：顺序查找表效率低而折半查找等要求查找表有序</li><li>思想：分块有序——索引有序（索引包含最大项和起始指针）</li><li>过程：先折半查找记录所在的块，再顺序查找元素</li><li>$ASL_{bs}=L_b(查找块)+L_w(查找元素)$</li></ol></li></ol><h3 id="动态查找"><a href="#动态查找" class="headerlink" title="动态查找"></a>动态查找</h3><h4 id="二叉查找树BST"><a href="#二叉查找树BST" class="headerlink" title="二叉查找树BST"></a>二叉查找树BST</h4><p>Binary  Search Tree查找算法可以基于二叉树的先序遍历算法写出</p><p>中序遍历BST可以得到关键字的有序序列</p><p>BST的插入算法：查找失败的同时添加叶子结点</p><p>BST的删除算法：</p><ol><li>若P为叶子结点，直接删除并修改双亲的指针域</li><li>若P只有左子树或右子树，将P删除并使P的双亲指针域指向P的孩子</li><li>若P有左右子树，将P与P的右子树的最左边的元素进行互换（中序遍历的首个元素），换言之，将P与P在树中中序访问序列的直接前驱或直接后继进行交换即可，避免树的长高</li></ol><p>BST的建立：二叉树的形态与输入的次序直接相关，若原本有序将得到每层只有一个结点的糟糕情况</p><p>平均性能分析：$P(n)&lt;=2(1+1\frac{1}{n})ln\ n$</p><h4 id="平衡二叉树AVL树"><a href="#平衡二叉树AVL树" class="headerlink" title="平衡二叉树AVL树"></a>平衡二叉树AVL树</h4><p>深度与log(N)同量级</p><p>引入平衡因子BF：-1，0，1</p><p>AVL树的旋转部分不会单独考察算法设计，理解过程即可</p><ul><li>LL型旋转：在A结点的左孩子的左子树插入结点</li><li>RR型旋转：在A结点的右孩子的右子树插入结点</li><li>LR型旋转：在A结点的左孩子的右子树插入结点，先左转再右转</li><li>RL型旋转：在A结点的右孩子的左子树插入结点，先右转再左转</li></ul><p>在对AVL树进行插入和删除操作时及时维护平衡</p><p>性能分析：$T(N)=O(log\ N)$</p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h3><p>定义：</p><ul><li>每个结点至多有m个子树</li><li>若根结点不是叶子结点，至少有两棵子树</li><li>除根结点外的非得终端结点至少$\lceil m/2\rceil$个子树</li><li>非终端结点包含以下信息：$(n,A_0,K_1,A_1,K_2,…,K_n,A_n)$，其中n为关键字数目，$K_i$为关键字，$A_i$为指针，且$A_{i-1}$指向的所有结点的关键字小于$K_i$,大于$K_{i-1}$</li><li>所有叶子结点都出现在同一层次上,且不携带信息，可以视作查找失败，指向这些结点的指针为空，图中表示为F</li></ul><p>相关算法</p><p>查找：纵向查结点，横向查关键字</p><p>通常存储在磁盘中，是数据库的主要索引结构</p><p>查找效率的首要因素：层次</p><p>通常取m=3，此时又称为2-3树</p><p>含有N个关键字的m阶B-树的最大深度：$log_{\lceil m/e\rceil}(\frac{N+1}{2})$</p><p>较为特殊的插入删除操作：</p><p>…应该不考察算法，要会画图</p><h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h3><p>B-树的变形树，具体区别：</p><ul><li>有n棵子树的结点包含了n个关键字</li><li>所有叶子结点包含了关键字的信息，以及指向这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大排序</li><li>非终端结点为索引部分，结点仅含有最大或者最小关键字</li></ul><p>B+树不是树；支持顺序查找（横向），随机查找（纵向）</p><h3 id="键树"><a href="#键树" class="headerlink" title="键树"></a>键树</h3><p>好像不考键树</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>Hash函数：H(key)</p><p>便于一次存取确定所查记录</p><p>将一组关键字利用H(key)和处理冲突的函数映射到有限的连续地址——hash表（散列）</p><p>Hash函数的构造方法：</p><ul><li>直接定址法（x)</li><li>数字分析法/平方取中法</li><li>折叠发：移位叠加，间界叠加</li><li>除留余数法</li><li>随机数法</li><li>…</li></ul><p>处理冲突的方法：s</p><ul><li>开放定址法<ul><li>线性探测再散列+1，+2，…</li><li>平方探测再散列+1,-1,+4,-4</li><li>伪随机探测再散列</li></ul></li><li>链地址法：关键字为同义词的的各个元素存储在线性链表中</li><li>再哈希法：$H_i=RH_i(key),i=1,2,..k$不易产生聚集，但会增加计算的时间</li><li>建立公共溢出区域：发生冲突都填入溢出表</li></ul><p>​    <code>二次聚集</code>：在处理同义词冲突的过程中又添加了非同义词的冲突的现象</p><h4 id="Hash表的查找算法"><a href="#Hash表的查找算法" class="headerlink" title="Hash表的查找算法"></a>Hash表的查找算法</h4><p>根据Hash函数以及冲突处理方法确定</p><p>查找的ASL：分成功与不成功计算，时间复杂度为未知</p><p>装填因子$\alpha=$记录数/Hash表表长</p><p>通常Hash表长m和除留余数法的p的关系：</p><p>p&lt;=m,且p为素数或最小不包含小于20的质因子的合数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2021数据结构复习&quot;&gt;&lt;a href=&quot;#2021数据结构复习&quot; class=&quot;headerlink&quot; title=&quot;2021数据结构复习&quot;&gt;&lt;/a&gt;2021数据结构复习&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;考试范围&quot;&gt;&lt;a href=&quot;#考试范围&quot; class=</summary>
      
    
    
    
    <category term="数据结构" scheme="http://sn1987a-1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="专业课" scheme="http://sn1987a-1.github.io/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>图论期末复习</title>
    <link href="http://sn1987a-1.github.io/posts/12532.html"/>
    <id>http://sn1987a-1.github.io/posts/12532.html</id>
    <published>2022-01-05T15:42:30.000Z</published>
    <updated>2022-02-26T07:11:20.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图论复习"><a href="#图论复习" class="headerlink" title="图论复习"></a>图论复习</h1><p>未完成——不想写了</p><h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><ul><li><code>阶</code>：图G中顶点的个数$\nu (G)=|V(G)|$（简记为$\nu,V$）</li><li>$\epsilon (G)=|E(G)|$（简记为$\epsilon ,E$）</li><li><code>无限图</code>：$\nu(G)+\epsilon (G)=+\infty$，否则成为<code>有限图</code></li><li><code>关联/相邻/邻顶</code>：$\psi (e)=\{u,v\}$</li><li><code>重边/环</code></li><li><code>简单图</code>：无环无重边</li><li><code>完全图 二分图  完全二分图</code></li><li><code>零图  星图</code></li><li><code>度数</code>$deg(\nu)=d_1(\nu)+2\times l(\nu)$</li><li><code>最大/最小度数</code>$\delta (G)=min_{\nu \in V(G)},\Delta (G)=max_{\nu\in V(G)}$</li><li>无向图$\sum_{\nu\in V(G)}{deg(\nu)=2\epsilon(G)}$<ul><li>给定图G，G中度数为奇数的顶点个数为偶数</li></ul></li><li><code>真子图，生成子图（V(H)=V(G)），顶点导出子图，边导出子图</code></li><li><code>补图，边图</code>：边图的边对应原图的顶点，顶点对应原图的边</li><li><code>并，交</code></li><li><code>积</code>：$G\times H=(V’,E’)$,边集合分为三类：<ul><li>两个顶点在的两个分量在原图中均相邻</li><li>有一个分量在原图中相邻，另外一个分量为同一个顶点</li></ul></li><li><code>路径/行迹/轨道/回路/圈</code></li><li><code>连通/不连通</code>：连通存在距离</li><li><code>图的同构</code>：元素之间的二元关系完全相同</li><li><code>Ulam猜想</code>：G与H全等 等价于 对任何$\nu \in V(G),G-\nu=V-\nu$</li><li>有向图D：$D=(V(D),E(D),\psi _D)$</li><li>$\sum_{\nu\in V(G)}{deg^-(\nu)}(入度)=\sum_{\nu\in V(G)}{deg^+(\nu)}(出度)=\epsilon(G)$</li></ul><p><strong>定理</strong>：G为二分图当且仅当G中无奇圈</p><p><code>最长轨道 反证</code>例：若G为简单图，$\delta (G)&gt;=2$，则G中必含圈</p><p>​                          若G为简单图，$\delta (G)&gt;=3$，则G中必含有偶圈</p><p>最短路径问题$\omega (P_0(u,v))$——Dijkstra算法</p><p>​    证明略。</p><p>类似最短路径的相关思路——如取生成子图最大边数：</p><p>任给无向图G，存在H为G的生成子图，满足：</p><ul><li>H是二分图</li><li>任给$u\in V(G)=V(H),有d_H(u)&gt;=d_G(u)/2$</li></ul><p>取H为边数最大的二分图，假设不满足条件2</p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>基本概念:</p><ul><li><code>树叶/分支点（树枝）</code> <code>森林/平凡树</code></li></ul><p>以下命题等价</p><h2 id="图的连通性"><a href="#图的连通性" class="headerlink" title="图的连通性"></a>图的连通性</h2><h2 id="平面图"><a href="#平面图" class="headerlink" title="平面图"></a>平面图</h2><h2 id="匹配理论"><a href="#匹配理论" class="headerlink" title="匹配理论"></a>匹配理论</h2><h2 id="Euler图和Hamilton图"><a href="#Euler图和Hamilton图" class="headerlink" title="Euler图和Hamilton图"></a>Euler图和Hamilton图</h2><h2 id="图的着色"><a href="#图的着色" class="headerlink" title="图的着色"></a>图的着色</h2><h2 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h2><h2 id="网络流理论"><a href="#网络流理论" class="headerlink" title="网络流理论"></a>网络流理论</h2><h2 id="图矩阵和图空间"><a href="#图矩阵和图空间" class="headerlink" title="图矩阵和图空间"></a>图矩阵和图空间</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图论复习&quot;&gt;&lt;a href=&quot;#图论复习&quot; class=&quot;headerlink&quot; title=&quot;图论复习&quot;&gt;&lt;/a&gt;图论复习&lt;/h1&gt;&lt;p&gt;未完成——不想写了&lt;/p&gt;
&lt;h2 id=&quot;图的基本概念&quot;&gt;&lt;a href=&quot;#图的基本概念&quot; class=&quot;headerl</summary>
      
    
    
    
    <category term="图论" scheme="http://sn1987a-1.github.io/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    
    <category term="专业课" scheme="http://sn1987a-1.github.io/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    <category term="图论" scheme="http://sn1987a-1.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>图论补充内容</title>
    <link href="http://sn1987a-1.github.io/posts/15331.html"/>
    <id>http://sn1987a-1.github.io/posts/15331.html</id>
    <published>2021-12-11T12:12:20.000Z</published>
    <updated>2023-09-23T13:14:57.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图论补充内容"><a href="#图论补充内容" class="headerlink" title="图论补充内容"></a>图论补充内容</h1><p>图论的基本知识汇总已以PDF形式上传至科大个人主页链接，此部分补充内容主要记录图论在实际算法问题方面的知识学习，部分内容来源于网络。</p><h2 id="计算复杂性问题"><a href="#计算复杂性问题" class="headerlink" title="计算复杂性问题"></a>计算复杂性问题</h2><p><code>P问题、NP问题、不可判定问题</code><br><strong>P问题</strong>：能够在多项式时间内可用算法求解的问题。举例：找到Euler回路<br><strong>NP问题</strong>：非确定型多项式时间（nondeterministic polynomial-time）问题，指<strong>不确定是否存在多项式时间的求解算法，但可以在多项式时间内验证一个猜测解的正确性</strong>的问题。举例：找Hamilton回路（实际上是NPC问题，尚且未知有限性算法）。<br><strong>不可判定问题(undecidable problem)</strong>：”不可能“解出的问题。举例：让C编译器找出所有的语法错误和无限循环。</p><p>与NP相关的问题有P，NP，NP Hard ，NPC问题，其中NP Hard 与NPC问题的具体描述为：</p><blockquote><p>NP hard问题：Non-deterministic Polynomial hard problem(NPH)问题，如果所有NP问题可在多项式时间内转化（归约，意思是解决了后者也就相应的解决了前者）成某个问题，则该问题称为NP难问题。<br>这里规约的意思是将一个特殊问题一般化，即将原问题推广为一个最一般的、最有概括性、也更难的、计算复杂度更高的问题，这个问题具有最高的计算复杂度，如果这个最一般的问题也能有多项式时间求解算法，那么那些特殊的原问题也能有多项式时间求解算法。<br>解决了这个NP hard问题，所有NP问题都能够被解决了。</p><p> NP hard问题不一定是NP问题，有可能是不可判定问题。这时候说明原问题也是不可判定的。</p><p>NPC问题：Non-deterministic Polynomial complete problem ，如果所有NP问题可在多项式时间内归约成某个NP问题，则该NP问题称为NP完全问题。NPC包含了NP中最难的问题。<br>解决了这个NPC问题。所有NP问题都能够被解决了。</p><p> NPC问题相当广泛，包括来自操作系统（调度和安全）、数据库系统、运筹学、逻辑学、特别是图论等不同领域的问题。<br>可满足性问题、哈密顿圈问题、巡回售货员问题、最长路径问题都是NPC问题。 装箱(bin packing)问题、背包(knapsack)问题、图的着色(graph coloring)问题以及团(clique)的问题都是著名的NPC问题。NPC问题相当广泛，包括来自操作系统（调度和安全）、数据库系统、运筹学、逻辑学、特别是图论等不同领域的问题。<br> 背包问题(Knapsack problem)是一种组合优化的NP完全问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。问题的名称来源于如何选择最合适的物品放置于给定背包中。相似问题经常出现在商业、组合数学，计算复杂性理论、密码学和应用数学等领域中。也可以将背包问题描述为决定性问题，即在总重量不超过W的前提下，总价值是否能达到V？它是在1978年由Merkel和Hellman提出的。背包问题已经研究了一个多世纪，早期的作品可追溯到1897年数学家托比亚斯·丹齐格（Tobias Dantzig，1884-1956）的早期作品 ，并指的是包装你最有价值或有用的物品而不会超载你的行李的常见问题。</p></blockquote><p>NPC算法的复杂度更倾向于$O(e^n)$,NP Hard 算法的时间复杂度甚至可能达到$O(n^n)$.</p><p>在本课程里出现的NPC问题：</p><ol><li>图着色（边/顶点/面着色）</li><li>Hamilton圈算法</li><li>…?</li></ol><h2 id="随机游走Random-Walk"><a href="#随机游走Random-Walk" class="headerlink" title="随机游走Random Walk"></a>随机游走Random Walk</h2><blockquote><p><strong>随机游走</strong>（英语：Random Walk，缩写为 RW），是一种<a href="https://zh.wikipedia.org/w/index.php?title=數學統計模型&amp;action=edit&amp;redlink=1">数学统计模型</a>，它是一连串的<a href="https://zh.wikipedia.org/wiki/軌跡">轨迹</a>所组成，其中每一次都是<a href="https://zh.wikipedia.org/wiki/随机过程">随机</a>的。<a href="https://zh.wikipedia.org/wiki/隨機漫步#cite_note-Wirth-1">[1]</a><a href="https://zh.wikipedia.org/wiki/隨機漫步#cite_note-2">[2]</a>它能用来表示不规则的变动形式，如同一个人酒后乱步，所形成的<a href="https://zh.wikipedia.org/wiki/随机过程">随机过程</a>记录。1905年，由<a href="https://zh.wikipedia.org/wiki/卡尔·皮尔逊">卡尔·皮尔逊</a>首次提出。</p><p>——来自维基百科</p><p>靠随机游走解出来了tx的自定义阴间一笔画红包</p><p>——来自群友</p></blockquote><p>算法思想：</p><ul><li>该算法要实现的是搜索，从起始点s开始找到目的地t。</li><li>给定一个图，从起点开始走的每一步都让其有一定的概率$\alpha$跳转到图中的任意一个点上，还有$ 1-\alpha$的概率会行走到任意一个与该点相连的点上。不断的重复上述过程，直到找到目的地中。</li></ul><p>步骤</p><ul><li>将实际问题抽象为图的形式，并用临接表、邻接矩阵等存图方式将图存储在计算机中；</li><li>用一个变量记录当前所处的位置（图中点的标号），每次随机一个[0, 1]之间的数，若其小于等于随机跳跃概率$\alpha $则随机一个[1, n]的数字并跳转，否则随机一个$x,x\in S$，其中S为与当前点相连的点的集合；</li><li>不断重复第二步并记录路径，直到找到目的地t.</li></ul><p>该算法的思想也被应用到了PageRank算法中，作为Google等搜索引擎的网页检索算法。（PageRank中心性算法的本质就是随机游走（详见课本中心型算法部分，考试不考）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图论补充内容&quot;&gt;&lt;a href=&quot;#图论补充内容&quot; class=&quot;headerlink&quot; title=&quot;图论补充内容&quot;&gt;&lt;/a&gt;图论补充内容&lt;/h1&gt;&lt;p&gt;图论的基本知识汇总已以PDF形式上传至科大个人主页链接，此部分补充内容主要记录图论在实际算法问题方面的知识学</summary>
      
    
    
    
    <category term="图论" scheme="http://sn1987a-1.github.io/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    
    <category term="专业课" scheme="http://sn1987a-1.github.io/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>HUFFMAM Tree</title>
    <link href="http://sn1987a-1.github.io/posts/1120.html"/>
    <id>http://sn1987a-1.github.io/posts/1120.html</id>
    <published>2021-11-11T11:46:11.000Z</published>
    <updated>2023-09-23T13:16:23.062Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Huffman-编码解压缩"><a href="#Huffman-编码解压缩" class="headerlink" title="Huffman 编码解压缩"></a>Huffman 编码解压缩</h1><p>关于Huffman编码的知识,在上个学期数据结构已经学过,作为较为复杂的一次实验耗费了不少时间,可说实话,上个学期在数据结构投入的经历确实不算大,最终的成绩也相当不理想,但这个学期还得重新学数据结构(信计数据结构不能互认就离谱orz),同样类型的实验,不同的心境 ,不同的要求,只求要一个好一点点的分数啦</p><h2 id="大致实验要求"><a href="#大致实验要求" class="headerlink" title="大致实验要求"></a>大致实验要求</h2><p>基于Huffman编码来实现压缩器和编码器,使其可以对任意文件进行解压缩操作.</p><p>实现方法:命令行执行/GUI界面(还不会…)/运行程序交互界面</p><p>本实验的测试数据:文件包括:.txt    .png    .wav    .mp4    .zip</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Huffman-编码解压缩&quot;&gt;&lt;a href=&quot;#Huffman-编码解压缩&quot; class=&quot;headerlink&quot; title=&quot;Huffman 编码解压缩&quot;&gt;&lt;/a&gt;Huffman 编码解压缩&lt;/h1&gt;&lt;p&gt;关于Huffman编码的知识,在上个学期数据结构已经</summary>
      
    
    
    
    <category term="数据结构" scheme="http://sn1987a-1.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="专业课" scheme="http://sn1987a-1.github.io/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>模拟与数字电路期中复习</title>
    <link href="http://sn1987a-1.github.io/posts/15234.html"/>
    <id>http://sn1987a-1.github.io/posts/15234.html</id>
    <published>2021-11-05T15:42:30.000Z</published>
    <updated>2023-09-23T13:15:11.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模拟与数字电路"><a href="#模拟与数字电路" class="headerlink" title="模拟与数字电路"></a>模拟与数字电路</h1><p>[TOC]</p><h2 id="2022-1-15-模拟与数字电路期末考试"><a href="#2022-1-15-模拟与数字电路期末考试" class="headerlink" title="2022.1.15 模拟与数字电路期末考试"></a>2022.1.15 模拟与数字电路期末考试</h2><p>2021.11.11期中考试主要内容：</p><ol><li><p>数字逻辑概论:</p><ol><li>数值转换</li><li>二进制数的算术运算</li></ol></li><li><p>逻辑代数&amp;HDL基础</p><ol><li>反演规则</li><li>对偶规则</li><li>最大项/最小项</li><li>表达式化简<ol><li>直接化简</li><li>卡诺图</li></ol></li><li>逻辑函数表示方法之间的转换<ol><li>真值表</li><li>表达式</li><li>逻辑图</li><li>波形图</li></ol></li></ol></li><li><p>逻辑门电路</p></li><li><p>组合逻辑电路/PLD✨</p></li><li><p>锁存器和触发器✨</p></li><li><p>时序逻辑电路（仅包含同步时序电路）✨</p><p>信号——数字部分；周期性；占空比：高电平占周期的百分比</p></li></ol><h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><h3 id="进制：Binary-Octal-Hexadecimal（0x）"><a href="#进制：Binary-Octal-Hexadecimal（0x）" class="headerlink" title="进制：Binary    Octal    Hexadecimal（0x）"></a>进制：Binary    Octal    Hexadecimal（0x）</h3><p>二进制转换：“误差不大于$2^{-n}$” &lt;=&gt; “精确到小数点第n位”</p><p>第n位“四舍五入”即可</p><p>二进制的算术运算：补码=原码取反+1；补码表示范围$-2^{n-1}~2^{n-1}-1$</p><p>补码转原码：从右往左找到第一个‘1’，将这个1之前的取反，该数字和之后的保持原值即可。</p><script type="math/tex; mode=display">(X+Y)_补=(X)_补+(Y)_补</script><script type="math/tex; mode=display">(X-Y)_补=(X)_补-\overline{(Y)_补}+1</script><p>溢出：运算结果超出补码的表示范围</p><p>​        出现场合：同号相加，异号相减———&gt;判断结果是否正确（是否溢出）：判断计算过程中符号位和次高位的进位情况，当且仅当符号位有进位且次高位无进位时计算结果溢出。</p><p>溢出解决方案—-符号拓展：通过利用两个或多个符号位，初始统一置0或1，最终结果看第一位的状态。</p><h3 id="BCD码（无特殊说明BCD码均指8421码）"><a href="#BCD码（无特殊说明BCD码均指8421码）" class="headerlink" title="BCD码（无特殊说明BCD码均指8421码）"></a><strong>BCD码</strong>（无特殊说明BCD码均指8421码）</h3><p>有权码：8421码，5421码，2421码（数字代表各位的权重）</p><p>无权码：余3码，余3循环码</p><p>余3循环码：（0~9）</p><div class="table-container"><table><thead><tr><th>数值</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>余3循环码</td><td>0010</td><td>0110</td><td>0111</td><td>0101</td><td>0100</td><td>1100</td><td>1101</td><td>1111</td><td>1110</td><td>1010</td></tr></tbody></table></div><h3 id="格雷码"><a href="#格雷码" class="headerlink" title="格雷码"></a>格雷码</h3><p>编码顺序依次变化时，相邻代码有且仅有一位不同，最大和最小之间也差一位，也称循环码（余3循环码也满足该条件）（0~15）</p><p>格雷码——&gt;二进制码转化：从最高位到最低位依次相加</p><div class="table-container"><table><thead><tr><th>数值</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th></tr></thead><tbody><tr><td>格雷码</td><td>0000</td><td>0001</td><td>0011</td><td>0010</td><td>0110</td><td>0111</td><td>0101</td><td>0100</td><td>1100</td><td>1101</td><td>1111</td><td>1110</td><td>1010</td><td>1011</td><td>1001</td><td>1000</td></tr><tr><td>二进制码</td><td>0000</td><td>0001</td><td>0010</td><td>0011</td><td>0100</td><td>0101</td><td>0110</td><td>0111</td><td>1000</td><td>1001</td><td>1010</td><td>1011</td><td>1100</td><td>1101</td><td>1110</td><td>1111</td></tr></tbody></table></div><h3 id="进制转换："><a href="#进制转换：" class="headerlink" title="进制转换："></a>进制转换：</h3><ol><li>任意进制-&gt;十进制：按位权展开后相加<script type="math/tex; mode=display">(N)_R=\sum_{i=-m}^{n-1}k_i*R^i</script></li></ol><p>​        2.十进制-&gt;任意进制：</p><p>​                整数部分：辗转除基取余，先得较低有效位</p><p>​                小数部分：辗转乘积取整，先得最高有效位</p><h2 id="逻辑代数"><a href="#逻辑代数" class="headerlink" title="逻辑代数"></a>逻辑代数</h2><h3 id="基本定律："><a href="#基本定律：" class="headerlink" title="基本定律："></a>基本定律：</h3><ul><li>交换律    A<em> B=B </em>A;    A+B=B+A;</li><li>结合律    A(BC)=(AB)C;     A+(B+C)=(A+B)+C;</li><li>分配律    A(B+C)=AB+AC;     A+BC=(A+B)(A+C);</li><li>吸收律    A+A<em> B=A;     A</em>(A+B)=A;</li><li>反演律    $\overline{A+B}=\overline {A}*\overline {B}$ ;      $\overline{AB}=\overline{A}+\overline{B};$</li></ul><p>代入规则:在任一逻辑恒等式中,若以一个逻辑表达式代替恒等式两边所有出现的某一变量,则所得表达式依然成立.利用该结论可以把上述定律推广到n元的情况,即反演律可以写成:</p><script type="math/tex; mode=display">\overline{A_1*A_2*...*A_n}=\overline{A_1}+\overline{A_2}+...+\overline{A_n}</script><script type="math/tex; mode=display">\overline{A_1+A_2+...+A_n}=\overline{A_1}*\overline{A_2}*...*\overline{A_n}</script><h3 id="反演和对偶"><a href="#反演和对偶" class="headerlink" title="反演和对偶"></a>反演和对偶</h3><p>反演规则:对于任意表达式Y,将所有表达式中的’*’和’+’互换,将所有的’0’与’1’互换,把逻辑变量取反.</p><p>对偶规则:对于任意表达式Y,将所有表达式中的’*’和’+’互换,但不改变所有的’0’与’1’互换和逻辑变量.</p><p>利用对偶规则可以对上述基本定律进行拓展.</p><h3 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h3><p>对于一个逻辑函数,有多个逻辑表达式:(下以/AB+A/C为例)</p><ul><li>与或式——-$\overline {AB}+A\overline C;$</li><li>或与式———$(A+\overline B)*(\overline A+C)$</li><li>与非-与非式———$\overline {\overline{\overline AB}\ \ \overline {A\overline C}}$————-最简与或式求两次反</li><li>或非-或非式———$\overline {(\overline A+B)+(\overline A+\overline C)}$———最简或与式求两次反</li><li>与或非式———$\overline {\overline A\ \overline B+AC}$—————先求/Y的最简与或式,然后求反</li></ul><h3 id="最小项与最大项"><a href="#最小项与最大项" class="headerlink" title="最小项与最大项"></a>最小项与最大项</h3><p><strong>最小项</strong>:包含全部输入变量的乘积项,每个变量均以自身变量或反变量出现一次.对于n变量逻辑函数,共有2^n个最小项,记为mi,其中i为最小项的编号[1].</p><p>[1]编号:编号方法:原变量和反变量分别带表1和0,带入逻辑表达式得到的二进制数对应的十进制数记为编号i.</p><p>对于任意一个最小项,有且仅有一组变量使得mi=1成立,且对于不同的i,对应不同的变量;</p><p>全体最小项的并恒等于1;</p><p>任意两个最小项的交恒等于0;</p><p><strong>最大项</strong>:包含全部输入变量的或项,每个变量均以自身变量或反变量出现一次.对于n变量逻辑函数,共有2^n个最大项,记为Mi,其中i为最大项的编号[2].</p><p>[2]编号:编号方法:原变量和反变量分别带表1和0,带入逻辑表达式得到的二进制数取反对应的十进制数记为编号i.</p><p>性质可以和最小项类似</p><p>最大项和最小项的关系:</p><script type="math/tex; mode=display">\overline{M_i}=m_i;   M_i=\overline{m_i}</script><h3 id="卡诺图"><a href="#卡诺图" class="headerlink" title="卡诺图"></a>卡诺图</h3><p>卡诺图通常用在逻辑变量在5以内的情况.</p><p>卡诺图物理上相邻的逻辑变量在逻辑上相邻(上下相邻,左右相邻,,循环相邻,对角不相邻)——-循环码</p><p>无关项x:不允许或不可能出现的最小项/对应的函数值是任意值.</p><p><strong><strong><em>卡诺图化简逻辑表达式</em></strong></strong></p><p><strong>规范作图：</strong></p><ul><li><strong>00 01 11 10顺序</strong></li><li><strong>注明各个逻辑变量名称</strong></li><li><strong>画圈标记—-写对应表达式</strong> </li><li><strong>最简或与式——圈0取反</strong></li><li><strong>圈0取反后不一定是原问题的最简与或式.</strong>(?)</li></ul><h2 id="逻辑门电路"><a href="#逻辑门电路" class="headerlink" title="逻辑门电路"></a>逻辑门电路</h2><p>PMOS:高电平不导通,低电平导通.不能接地</p><p>NMOS:高电平导通,低电平不导通,不能接高电平</p><p>非门:2个CMOS;与非门/或非门:4个CMOS;与门/或门:6个COMS</p><h2 id="组合逻辑电路"><a href="#组合逻辑电路" class="headerlink" title="组合逻辑电路"></a>组合逻辑电路</h2><p>定义:对于一个逻辑电路,在任何一个时刻的输出状态只与输入状态有关,与电路自身状态无关.</p><p>电路功能分析思路:</p><ol><li>根据输入输出写出各级逻辑表达式,直到输入和输出信号的逻辑表达式;</li><li>将各个逻辑表达式化简和变换得到最简表达式;</li><li>根据表达式列出真值表;</li><li>根据真值表和最简逻辑表达式对组合逻辑电路进行分析,最后确定其功能.</li></ol><p>组合逻辑电路设计过程</p><ol><li>明确实际问题的逻辑功能,确定输入输出和表示符号;</li><li>根据对电路逻辑功能的要求写出真值表;</li><li>利用真值表得出逻辑表达式并进程化简变换;(卡诺图)</li><li>利用得到的逻辑表达式画出电路图.</li></ol><p>画波形图要点:    画出原题的波形,画出时钟信号的边缘的虚线…</p><h3 id="典型组合逻辑电路"><a href="#典型组合逻辑电路" class="headerlink" title="典型组合逻辑电路"></a>典型组合逻辑电路</h3><h4 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a><strong>编码器</strong></h4><p>优先编码器CD4532:        8信号输入3信号输出;    输入输出均以高电平有效;    EI/EO:输入/输出使能端,均高电平有效,否则输出端均为低电平,EI为低电平时GS,EO必定是低电平, EI是1且输入均为低电平时EO输出为1,可以用于连接下一编码器的使能输入端````````````    ;    GS:编码工作状态:EI是一且至少有一个高电平输入(表明正在工作)时为1;    优先级:I7&gt;I6&gt;…&gt;I0.</p><h4 id="译码器"><a href="#译码器" class="headerlink" title="译码器"></a><strong>译码器</strong></h4><p>74x138/74x139        输入输出低电平有效        E_3高电平有效</p><p><img src="https://bkimg.cdn.bcebos.com/pic/e61190ef76c6a7eff649c979fdfaaf51f3de6605?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5/format,f_auto" alt="img" style="zoom:70%;"></p><h4 id="数据分配器"><a href="#数据分配器" class="headerlink" title="数据分配器"></a><strong>数据分配器</strong></h4><h4 id="数据选择器"><a href="#数据选择器" class="headerlink" title="数据选择器"></a><strong>数据选择器</strong></h4><h4 id="数值比较器"><a href="#数值比较器" class="headerlink" title="数值比较器"></a><strong>数值比较器</strong></h4><h4 id="基本算术电路"><a href="#基本算术电路" class="headerlink" title="基本算术电路"></a><strong>基本算术电路</strong></h4><ul><li><strong>半加器</strong></li><li><strong>全加器</strong></li><li><strong>多位数加法器(串行进位加法器/超前进位加法器)</strong></li></ul><h3 id="PLD"><a href="#PLD" class="headerlink" title="PLD"></a>PLD</h3><p>分类</p><ul><li>PROM 或阵列可编程逻辑</li><li>PLA 与或阵列均可编程逻辑</li><li>PAL与阵列可编程逻辑</li></ul><h2 id="锁存器和触发器"><a href="#锁存器和触发器" class="headerlink" title="锁存器和触发器"></a>锁存器和触发器</h2><p>细节:</p><ul><li>相对于锁存器,触发器的不同在于沿时钟边沿触发</li><li>画图时时钟信号小三角;上升沿一般用CP表示;下降沿/CP;有圆圈通常表示下降沿触发.</li></ul><p>激励方程:</p><script type="math/tex; mode=display">SR ff:Q^{n+1}=S+\overline RQ^n(SR=0)</script><script type="math/tex; mode=display">Dff: Q^{n+1}=D</script><script type="math/tex; mode=display">JKff:Q^{n+1}=J\overline {Q^n}+\overline KQ^n</script><h2 id="时序逻辑电路"><a href="#时序逻辑电路" class="headerlink" title="时序逻辑电路"></a>时序逻辑电路</h2><h3 id="时序逻辑电路分析"><a href="#时序逻辑电路分析" class="headerlink" title="时序逻辑电路分析"></a>时序逻辑电路分析</h3><p>Mealy型:输出是当前状态和输入的函数</p><p>Moore型:输出是当前状态的函数</p><p>分析思路</p><ol><li>根据逻辑图写出逻辑方程<ol><li>输出方程(判断Mealy/Moore)</li><li>激励方程:每个触发器的输入驱动方程(J/K=…)</li><li>状态方程:激励方程代入触发器的特征方程得到(Q(n-1)=…)</li></ol></li><li>列出状态表_根据mealy/moore型画出对应的表——-&gt;画出状态图(图例!)/时序图</li><li>最后确定电路的逻辑功能</li></ol><h3 id="时序逻辑电路设计"><a href="#时序逻辑电路设计" class="headerlink" title="时序逻辑电路设计"></a>时序逻辑电路设计</h3><ol><li><p>给定逻辑功能的要求（文字描述或者是波形图），</p></li><li><p>求相应的逻辑电路</p></li><li><p>设计的一般步骤</p></li><li><p>建立原始状态图（状态可以用易懂或易写的方式表示）和原始状态表</p></li><li><p>状态化简（在面对同输入得到同输出和同次态NS的现</p><p>Q    态是等价的)</p></li><li><p>状态编码</p></li><li><p>求状态方程和输出方程</p></li><li><p>检查自启动</p></li><li><p>选择触发器类型，求激励方程（激励表或其他方法）</p></li><li><p>画出逻辑图</p></li><li><p>尽量要求自己设计同步时序电路，因为后面在写verilog的时候一般都用统一的时钟</p></li><li><p>另外异步时序电路输出信号质量差，工作速度低</p></li></ol><p>以上内容为期中考试主要内容，其中的逻辑电路分析和设计的重难点在期末考试中仍会涉及</p><hr><p>期末考试额外的内容：</p><ol><li>数字系统设计<ol><li>数字系统结构</li><li>算术逻辑单元</li><li>寄存器传送</li><li>具体问题求解：最大值/排序/乘法电路</li></ol></li><li>Verilog HDL</li><li>Timing Analysis &amp; Synchronization</li><li>存储器，PLD，ListProcessor</li><li>二极管</li><li>三极管</li><li>基本放大电路</li><li>集成运放</li><li>逻辑门电路</li><li>ADC和DAC</li></ol><h2 id="Verilog-HDL-FSM"><a href="#Verilog-HDL-FSM" class="headerlink" title="Verilog  HDL/FSM"></a>Verilog  HDL/FSM</h2><p>常量表示形式：</p><p>整数型&lt;+/-&gt;&lt;位宽&gt;’&lt;基数符号(D/d,B/b,O/o,H/h)&gt;&lt;数值&gt;</p><p>实数型：1·科学计数法            2·十进制计数法</p><p>符号常量定义 <code>parameter</code></p><p>数据变量类型： <code>net(wire)</code> <code>register(reg)</code></p><p>定义格式： <code>wire/reg [MSB/LSB] r1,r2,...</code></p><p>赋值语句：连续赋值语句<code>assign</code>；过程块赋值<code>inital/always</code></p><p>常用语法（过程块赋值内）<code>case/if else/begin end</code></p><p><code>模块实例化</code>1.位置映射modulename M(A,B,C)；2.名称映射modulename M(.A(a),.C(c),.B(b))——不可混用</p><p>运算符</p><ol><li>算术运算符 逐位计算</li><li>关系运算符</li><li>位运算符：~ ,&amp;,^ , | , ^~ / ~^（同或）</li><li>逻辑运算符：&amp;&amp;，！，||</li><li>位拼接符：{, , }   {n{}}</li><li>移位运算符：&gt;&gt;,&lt;&lt;,&gt;&gt;&gt;(算数右移)</li><li>缩位运算符（单目运算符）：&amp;，~&amp;，| ，~|，^, ^~, ~ ^</li><li>条件运算符：？：</li></ol><p>运算符优先级= =</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token punctuation">(</span><span class="token keyword">input</span> i<span class="token punctuation">,</span><span class="token keyword">output</span> o<span class="token punctuation">,</span><span class="token keyword">inout</span> io<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">wire</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>   <span class="token keyword">parameter</span> M<span class="token operator">=</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>   <span class="token keyword">reg</span> <span class="token punctuation">[</span>M<span class="token punctuation">:</span>m<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>   <span class="token keyword">assign</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>   modulename <span class="token function">name</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">initial</span>      <span class="token keyword">begin</span>      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>   <span class="token keyword">end</span>   <span class="token important">always @</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>      <span class="token keyword">begin</span>         <span class="token keyword">if</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>         <span class="token keyword">else</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>         <span class="token keyword">case</span> <span class="token punctuation">(</span>敏感表达式<span class="token punctuation">)</span>            <span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>            <span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token keyword">default</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>         <span class="token keyword">endcase</span>      <span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用if/case语句时应该避免出现锁存器。</p><p>组合逻辑：阻塞赋值（blocking） ：‘=’块内赋值语句顺序执行</p><p>时序逻辑：非阻塞赋值（non-locking）：‘&lt;=’块内赋值语句并发进行</p><p><code>FSM</code></p><p>一段式/两段式/三段式</p><p>CS：现态；NS：次态；OUT：输出</p><p>两段式：一个时序过程描述CS，另一个组合描述NS和OUT</p><p>三段式：两个时序描述CS和OUT，一个组合过程描述NS</p><h2 id="时序逻辑电路2"><a href="#时序逻辑电路2" class="headerlink" title="时序逻辑电路2"></a>时序逻辑电路2</h2><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>寄存器是若干具有相同外观电路结构的共享时钟和控制信号的触发器</p><p>普通寄存器/<code>移位寄存器</code></p><p>74x194:双向通用移位寄存器</p><p><img src="C:\Users\李\AppData\Roaming\Typora\typora-user-images\image-20211231173423377.png" alt="image-20211231173423377" style="zoom:50%;"></p><p>功能表：<img src="C:\Users\李\AppData\Roaming\Typora\typora-user-images\image-20211231173453305.png" alt="image-20211231173453305" style="zoom:57%;"></p><p>不添加其他逻辑门即可实现位拓展</p><p>应用：实现序列检测</p><h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>累计时钟脉冲次数，可以用来分频，定时，产生节拍脉冲</p><p><code>模</code>：循环遍历的有效状态数</p><p>异步递增计数器：电路简单，易于拓展，但工作效率低，不适用</p><p>同步递增计数器：<img src="C:\Users\李\AppData\Roaming\Typora\typora-user-images\image-20211231175954622.png" alt="image-20211231175954622" style="zoom:47%;"></p><p>74x161</p><p><img src="C:\Users\李\AppData\Roaming\Typora\typora-user-images\image-20211231180035128.png" alt="image-20211231180035128" style="zoom:50%;"></p><p>74x160:模10计数器，与74x161相似</p><p><code>任意进制计数器构成</code></p><p>•用N进制计数器构成 M 进制计数器</p><p>•若 M &lt; N ，可在计数过程中设法跳过 N-M 个多余状态</p><p>​    –反馈清零法，简称清零法</p><p>​    –反馈置数法，简称置数法</p><p>•若 M &gt; N ，用多片 N 进制计数器级连，配合清零 / 置数法构成</p><p><code>要注意同步清零和异步清零清零时的数值是不一致的，通常同步+1=异步，置数同理</code>——可以画状态图，异步的临界状态可以画虚线</p><p><code>用移位寄存器实现计数器</code>，如环形计数器：将串行输入与串行输出直接相连，计数状态等于寄存器的位数。</p><p>扭环型计数器：约翰孙计数器，计数状态是环形计数器的2倍</p><p>有效循环：每次状态转换只更改一位</p><p><img src="C:\Users\李\AppData\Roaming\Typora\typora-user-images\image-20211231182730747.png" alt="image-20211231182730747" style="zoom:57%;"></p><h3 id="数字系统"><a href="#数字系统" class="headerlink" title="数字系统"></a>数字系统</h3><p>开关去抖动</p><p>数字系统组成：Data Path+Control Unit</p><p><img src="C:\Users\李\AppData\Roaming\Typora\typora-user-images\image-20211231175222600.png" alt="image-20211231175222600" style="zoom:67%;"></p><p>实例：时序二进制乘法器，求最大值，排序</p><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;模拟与数字电路&quot;&gt;&lt;a href=&quot;#模拟与数字电路&quot; class=&quot;headerlink&quot; title=&quot;模拟与数字电路&quot;&gt;&lt;/a&gt;模拟与数字电路&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;2022-1-15-模拟与数字电路期末考试&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="数字电路" scheme="http://sn1987a-1.github.io/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
    
    <category term="专业课" scheme="http://sn1987a-1.github.io/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>线性筛</title>
    <link href="http://sn1987a-1.github.io/posts/15547.html"/>
    <id>http://sn1987a-1.github.io/posts/15547.html</id>
    <published>2021-10-24T15:43:35.000Z</published>
    <updated>2023-09-23T13:16:30.242Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性筛的理解和应用"><a href="#线性筛的理解和应用" class="headerlink" title="线性筛的理解和应用"></a>线性筛的理解和应用</h1><p>最近在准备相关算法竞赛，正好班里有写博客的活动，就在此记录下自己菜不成声学习的过程。&gt;v&lt;</p><p>为算出小于等于n的素数的个数，较自然也是最暴力的的方法便是对每个小于n的正整数进行判定，这样的方法显然达到最优的复杂度，暴力硬解的结果无疑是最终喜提“Time Limit Exceeded”。</p><p>为提高算法效率，就要引入“筛”的思想——主要思想是：我们选出一个数n时无论n是素数还是合数，2n,3n,..都是合数，我们无需对这类数进行是否为素数的判断。</p><h2 id="Eratosthenes-筛法-（埃拉托斯特尼筛法，简称埃氏筛）"><a href="#Eratosthenes-筛法-（埃拉托斯特尼筛法，简称埃氏筛）" class="headerlink" title="Eratosthenes 筛法 （埃拉托斯特尼筛法，简称埃氏筛）"></a><strong>Eratosthenes 筛法</strong> （埃拉托斯特尼筛法，简称埃氏筛）</h2><p>埃氏筛算法的主要思想是：如果我们从小到大考虑每个数，然后同时把当前这个数的所有（比自己大的）倍数记为合数，那么运行结束的时候没有被标记的数就是素数了。具体算法如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">Eratosthenes</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> is_prime<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  is_prime<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> is_prime<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>is_prime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      prime<span class="token punctuation">[</span>p<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>  <span class="token comment">// prime[p]是i,后置自增运算代表当前素数数量</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">*</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>           j <span class="token operator">+=</span> i<span class="token punctuation">)</span>  <span class="token comment">// 因为从 2 到 i - 1 的倍数我们之前筛过了，这里直接从 i</span>                    <span class="token comment">// 的倍数开始，提高了运行速度</span>        is_prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">//是i的倍数的均不是素数</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>埃氏筛通常可以称为普通筛，结构比较简单，也比较容易理解，其核心就是对找到的素数的倍数通过一次循环进行标记，虽然要额外占用O(n)的内存空间保存标记，但非常高效地减少了程序复杂度。</p><p>我们应该注意到，埃氏筛在对数字进行标记筛选时，存在重复筛选，比如6既可以被2筛掉，又可以被3筛掉。原因：任意一个整数可以写成一些素数的乘积 </p><script type="math/tex; mode=display">n=p1^ip2^jp3^k</script><p>其中p1&lt;p2&lt;p3，这样这个数n能被p1,p2和p3筛掉,反复被标记，尤其在n比较大的时候，n可能有相当多个素因子，被多次标记，显然浪费了时间。</p><h2 id="Euler筛法-线性筛"><a href="#Euler筛法-线性筛" class="headerlink" title="Euler筛法(线性筛)"></a>Euler筛法(线性筛)</h2><p>基于普通筛的不足之处，Euler对其做出了修改——直观地来说，当我们用埃氏筛法对一个素数的n倍进行筛选时，若正在被标记的这个倍数已经足够大，大到超过一特定的数字后，那这个数一定有更大的素因子，能在后续过程中再次被标记，此时就可以停止循环，算法继续对下一个未标记的数进行是否为素数的判断。</p><p>通过观察不难发现，若当前正在处理n的i倍数in，i能整除n，那么i与下一个要进行筛选的数的乘积这个合数肯定会被n乘以某个数提前筛掉。因此这里的i便是我们要找的“特定的数字”，利用这一数字提前break掉循环，可以使得每个数字均被筛选一次，将时间复杂度降到最低，这也就是Euler筛的算法思想，实现代码如下所示。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  phi<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAXN<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      phi<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>      pri<span class="token punctuation">[</span>cnt<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> cnt<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">1ll</span> <span class="token operator">*</span> i <span class="token operator">*</span> pri<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> MAXN<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>      vis<span class="token punctuation">[</span>i <span class="token operator">*</span> pri<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> pri<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        phi<span class="token punctuation">[</span>i <span class="token operator">*</span> pri<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> phi<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>pri<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment">// i % pri[j] == 0</span>        <span class="token comment">// 换言之，i 之前被 pri[j] 筛过了</span>        <span class="token comment">// 由于 pri 里面质数是从小到大的，所以 i 乘上其他的质数的结果一定会被</span>        <span class="token comment">// pri[j] 的倍数筛掉，就不需要在这里先筛一次，所以这里直接 break</span>        <span class="token comment">// 掉就好了</span>        phi<span class="token punctuation">[</span>i <span class="token operator">*</span> pri<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> phi<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> pri<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关键之处在：if(i%prime[j]==0) break;</p><p>这句代码保证了每个数最多被筛一次，将时间复杂度降到了线性。</p><p>证：prime[]数组中的素数是递增的,当i能整除prime[j]，那么i<em>prime[j+1]这个合数肯定会被prime[j]乘以某个数筛掉。因此，这里直接break掉，将i</em>prime[j+1]及之后的给后面的数去筛。这种方法能保证每个数只被筛一遍，又能保证每个数都被筛到。</p><p>为了更好的理解，画出前面几次筛的情况:</p><p><img src="C:\Users\李\AppData\Roaming\Typora\typora-user-images\image-20211029190053110.png" alt="image-20211029190053110"></p><p>一般来说，当筛选范围n较小时，埃氏筛和欧氏筛复杂度较相近，甚至埃氏筛表现更好，但随着n的增大，欧氏筛的优越性也逐渐体现出来，可以达到埃氏筛3-4倍的速度。</p><p>参考：</p><p>1.<a href="https://www.cnblogs.com/lfri/p/11679306.html">线性筛的理解及应用 - Rogn - 博客园 (cnblogs.com)</a></p><p>2.<a href="https://blog.csdn.net/qq_41653433/article/details/88976544">线性筛_历尽千帆-CSDN博客_线性筛</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线性筛的理解和应用&quot;&gt;&lt;a href=&quot;#线性筛的理解和应用&quot; class=&quot;headerlink&quot; title=&quot;线性筛的理解和应用&quot;&gt;&lt;/a&gt;线性筛的理解和应用&lt;/h1&gt;&lt;p&gt;最近在准备相关算法竞赛，正好班里有写博客的活动，就在此记录下自己菜不成声学习的过程。</summary>
      
    
    
    
    <category term="算法" scheme="http://sn1987a-1.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://sn1987a-1.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
